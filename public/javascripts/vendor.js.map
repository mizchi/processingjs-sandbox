{"version":3,"file":"public/javascripts/vendor.js","sources":["bower_components/jquery/jquery.js","bower_components/chai/chai.js","bower_components/processing/processing.js","node_modules/handlebars-brunch/vendor/handlebars.runtime-1.0.0.beta.6.js","node_modules/jade-brunch/node_modules/jade/runtime.js","test/initialize.coffee"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCv5RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCvlJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCv1nBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACjNA,CAAS,CAAO,GAAhB,IAAgB;CACX,CAAH,CAAmB,MAAnB;CACS,CAAQ,EAAf;CADF,EAAmB;CADL;A","sourcesContent":["/*!\n * jQuery JavaScript Library v2.1.0\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-01-23T21:10Z\n */\n\n(function( global, factory ) {\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper window is present,\n\t\t// execute the factory and get jQuery\n\t\t// For environments that do not inherently posses a window with a document\n\t\t// (such as Node.js), expose a jQuery-making factory as module.exports\n\t\t// This accentuates the need for the creation of a real window\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Can't do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n//\n\nvar arr = [];\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar trim = \"\".trim;\n\nvar support = {};\n\n\n\nvar\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\n\tversion = \"2.1.0\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return a 'clean' array\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return just the object\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\treturn obj - parseFloat( obj ) >= 0;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Support: Firefox <20\n\t\t// The try/catch suppresses exceptions thrown when attempting to access\n\t\t// the \"constructor\" property of certain host objects, ie. |window.location|\n\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=814622\n\t\ttry {\n\t\t\tif ( obj.constructor &&\n\t\t\t\t\t!hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the function hasn't returned already, we're confident that\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\treturn true;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\t\t// Support: Android < 4.0, iOS < 6 (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\n\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t// and removal by using an indirect global eval\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\ttrim: function( text ) {\n\t\treturn text == null ? \"\" : trim.call( text );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n});\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\tvar length = obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v1.10.16\n * http://sizzlejs.com/\n *\n * Copyright 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-01-13\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\tcompile,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + -(new Date()),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tstrundefined = typeof undefined,\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf if we can't use a native one\n\tindexOf = arr.indexOf || function( elem ) {\n\t\tvar i = 0,\n\t\t\tlen = this.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( this[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace +\n\t\t\"*(?:([*^$|!~]?=)\" + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\n\n\t// Prefer arguments quoted,\n\t//   then not containing pseudos/brackets,\n\t//   then attribute selectors/non-parenthetical expressions,\n\t//   then anything else\n\t// These preferences are here to reduce the number of selectors\n\t//   needing tokenize in the PSEUDO preFilter\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace( 3, 8 ) + \")*)|.*)\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tif ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\n\tif ( documentIsHTML && !seed ) {\n\n\t\t// Shortcuts\n\t\tif ( (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType === 9 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== strundefined && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc,\n\t\tparent = doc.defaultView;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\n\t// Support tests\n\tdocumentIsHTML = !isXML( doc );\n\n\t// Support: IE>8\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent !== parent.top ) {\n\t\t// IE11 does not have attachEvent, so all must suffer\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( \"unload\", function() {\n\t\t\t\tsetDocument();\n\t\t\t}, false );\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( \"onunload\", function() {\n\t\t\t\tsetDocument();\n\t\t\t});\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Check if getElementsByClassName can be trusted\n\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {\n\t\tdiv.innerHTML = \"<div class='a'></div><div class='a i'></div>\";\n\n\t\t// Support: Safari<4\n\t\t// Catch class over-caching\n\t\tdiv.firstChild.className = \"i\";\n\t\t// Support: Opera<10\n\t\t// Catch gEBCN failure to find non-leading classes\n\t\treturn div.getElementsByClassName(\"i\").length === 2;\n\t});\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== strundefined && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [m] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\t\t\t}\n\t\t} :\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdiv.innerHTML = \"<select t=''><option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 10-12\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\tif ( div.querySelectorAll(\"[t^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch(e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [elem] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[5] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] && match[4] !== undefined ) {\n\t\t\t\tmatch[2] = match[4];\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\nfunction tokenize( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n}\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf.call( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\treturn ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !group ) {\n\t\t\tgroup = tokenize( selector );\n\t\t}\n\t\ti = group.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( group[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\t}\n\treturn cached;\n};\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction select( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tmatch = tokenize( selector );\n\n\tif ( !seed ) {\n\t\t// Try to minimize operations if there is only one group\n\t\tif ( match.length === 1 ) {\n\n\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t\t)) ) {\n\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\tcompile( selector, match )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n}\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome<14\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t});\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tlen = this.length,\n\t\t\tret = [],\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n});\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[0] === \"<\" && selector[ selector.length - 1 ] === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ?\n\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.extend({\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar matched = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t}\n});\n\njQuery.fn.extend({\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.unique(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.unique( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n});\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend({\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.trigger ) {\n\t\t\tjQuery( document ).trigger(\"ready\").off(\"ready\");\n\t\t}\n\t}\n});\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\twindow.removeEventListener( \"load\", completed, false );\n\tjQuery.ready();\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlen ? fn( elems[0], key ) : emptyGet;\n};\n\n\n/**\n * Determines whether an object can have data\n */\njQuery.acceptData = function( owner ) {\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\t/* jshint -W018 */\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\nfunction Data() {\n\t// Support: Android < 4,\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t// return new empty object instead with no [[set]] accessor\n\tObject.defineProperty( this.cache = {}, 0, {\n\t\tget: function() {\n\t\t\treturn {};\n\t\t}\n\t});\n\n\tthis.expando = jQuery.expando + Math.random();\n}\n\nData.uid = 1;\nData.accepts = jQuery.acceptData;\n\nData.prototype = {\n\tkey: function( owner ) {\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return the key for a frozen object.\n\t\tif ( !Data.accepts( owner ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar descriptor = {},\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !unlock ) {\n\t\t\tunlock = Data.uid++;\n\n\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\ttry {\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t// Support: Android < 4\n\t\t\t// Fallback to a less secure definition\n\t\t\t} catch ( e ) {\n\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the cache object\n\t\tif ( !this.cache[ unlock ] ) {\n\t\t\tthis.cache[ unlock ] = {};\n\t\t}\n\n\t\treturn unlock;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\t\t\t// Fresh assignments by object are shallow copied\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t} else {\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\t// Either a valid cache is found, or will be created.\n\t\t// New caches will be created and the unlock returned,\n\t\t// allowing direct access to the newly created\n\t\t// empty data object. A valid owner object must be provided.\n\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\treturn key === undefined ?\n\t\t\tcache : cache[ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t}\n\n\t\t// [*]When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.cache[ unlock ] = {};\n\n\t\t} else {\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\treturn !jQuery.isEmptyObject(\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t);\n\t},\n\tdiscard: function( owner ) {\n\t\tif ( owner[ this.expando ] ) {\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t}\n\t}\n};\nvar data_priv = new Data();\n\nvar data_user = new Data();\n\n\n\n/*\n\tImplementation Summary\n\n\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t2. Improve the module's maintainability by reducing the storage\n\t\tpaths to a single mechanism.\n\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n*/\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdata_user.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend({\n\thasData: function( elem ) {\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn data_user.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdata_user.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to data_priv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn data_priv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdata_priv.remove( elem, name );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = data_user.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tname = attrs[ i ].name;\n\n\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.set( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data,\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each(function() {\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\tvar data = data_user.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdata_user.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t}\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tdata_user.remove( this, key );\n\t\t});\n\t}\n});\n\n\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = data_priv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHidden = function( elem, el ) {\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\t};\n\nvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n(function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) );\n\n\t// #11217 - WebKit loses check when the name is after the checked attribute\n\tdiv.innerHTML = \"<input type='radio' checked='checked' name='t'/>\";\n\n\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n\t// old WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t// Support: IE9-IE11+\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n})();\nvar strundefined = typeof undefined;\n\n\n\nsupport.focusinBubbles = \"onfocusin\" in window;\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\t\t\tdata_priv.remove( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn't\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome < 28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle, false );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\t// Support: Android < 4.0\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\tsrc.getPreventDefault && src.getPreventDefault() ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && e.preventDefault ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// Support: Chrome 15+\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// Create \"bubbling\" focus and blur events\n// Support: Firefox, Chrome, Safari\nif ( !support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdata_priv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdata_priv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdata_priv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\n\n\nvar\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\n\t\t// Support: IE 9\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\n// Support: IE 9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: 1.x compatibility\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdata_priv.set(\n\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( data_priv.hasData( src ) ) {\n\t\tpdataOld = data_priv.access( src );\n\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( data_user.hasData( src ) ) {\n\t\tudataOld = data_user.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdata_user.set( dest, udataCur );\n\t}\n}\n\nfunction getAll( context, tag ) {\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n// Support: IE >= 9\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Support: IE >= 9\n\t\t// Fix Cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [],\n\t\t\ti = 0,\n\t\t\tl = elems.length;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Fixes #12346\n\t\t\t\t\t// Support: Webkit, IE\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, events, type, key, j,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\tif ( jQuery.acceptData( elem ) ) {\n\t\t\t\tkey = elem[ data_priv.expando ];\n\n\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\tevents = Object.keys( data.events || {} );\n\t\t\t\t\tif ( events.length ) {\n\t\t\t\t\t\tfor ( j = 0; (type = events[j]) !== undefined; j++ ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Discard any remaining `user` data\n\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t}\n\t}\n});\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each(function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map(function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar arg = arguments[ 0 ];\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\targ = this.parentNode;\n\n\t\t\tjQuery.cleanData( getAll( this ) );\n\n\t\t\tif ( arg ) {\n\t\t\t\targ.replaceChild( elem, this );\n\t\t\t}\n\t\t});\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\n\nvar iframe,\n\telemdisplay = {};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\tdisplay = window.getDefaultComputedStyle ?\n\n\t\t\t// Use of this method is a temporary fix (more like optmization) until something better comes along,\n\t\t\t// since it was removed from specification and supported only in FF\n\t\t\twindow.getDefaultComputedStyle( elem[ 0 ] ).display : jQuery.css( elem[ 0 ], \"display\" );\n\n\t// We don't have any data stored on the element,\n\t// so use \"detach\" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = iframe[ 0 ].contentDocument;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\nvar rmargin = (/^margin/);\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t};\n\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE9\n\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t}\n\n\tif ( computed ) {\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// Support: iOS < 6\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\t\t\t\t// Hook not needed (or it's not possible to use it due to missing dependency),\n\t\t\t\t// remove it.\n\t\t\t\t// Since there are no other hooks for marginRight, remove the whole object.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\n\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\n(function() {\n\tvar pixelPositionVal, boxSizingReliableVal,\n\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\n\t\tdivReset = \"padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;\" +\n\t\t\t\"-moz-box-sizing:content-box;box-sizing:content-box\",\n\t\tdocElem = document.documentElement,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;\" +\n\t\t\"margin-top:1px\";\n\tcontainer.appendChild( div );\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computePixelPositionAndBoxSizingReliable() {\n\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\n\t\tdiv.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n\t\t\t\"box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;\" +\n\t\t\t\"position:absolute;top:1%\";\n\t\tdocElem.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div, null );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\tdocElem.removeChild( container );\n\t}\n\n\t// Use window.getComputedStyle because jsdom on node.js will break without it.\n\tif ( window.getComputedStyle ) {\n\t\tjQuery.extend(support, {\n\t\t\tpixelPosition: function() {\n\t\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t\t// No need to check if the test was already performed, though.\n\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t}\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\treliableMarginRight: function() {\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\t\tvar ret,\n\t\t\t\t\tmarginDiv = div.appendChild( document.createElement( \"div\" ) );\n\t\t\t\tmarginDiv.style.cssText = div.style.cssText = divReset;\n\t\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\t\tdiv.style.width = \"1px\";\n\t\t\t\tdocElem.appendChild( container );\n\n\t\t\t\tret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );\n\n\t\t\t\tdocElem.removeChild( container );\n\n\t\t\t\t// Clean up the div for other support tests.\n\t\t\t\tdiv.innerHTML = \"\";\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t});\n\t}\n})();\n\n\n// A method for quickly swapping in/out CSS properties to get correct calculations.\njQuery.swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: 0,\n\t\tfontWeight: 400\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// check for vendor prefixed names\n\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// at this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\n\t\t\tif ( !values[ index ] ) {\n\t\t\t\thidden = isHidden( elem );\n\n\t\t\t\tif ( display && display !== \"none\" || !hidden ) {\n\t\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.extend({\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t// normalize float css property\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set. See: #7116\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,\n\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\t// Support: Chrome, Safari\n\t\t\t\t// Setting style to blank string required to delete \"style: x !important;\"\n\t\t\t\tstyle[ name ] = \"\";\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t//convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\treturn elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, \"display\" ) ) ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\n// Support: Android 2.3\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t// available and use plain properties where available\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t}\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t} ]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// if we include width, step value is 1 to do all cssExpand values,\n\t// if we don't include width, step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// we're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = data_priv.get( elem, \"fxshow\" );\n\n\t// handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t// before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t// Get default display if display is currently \"none\"\n\t\tif ( display === \"none\" ) {\n\t\t\tdisplay = defaultDisplay( elem.nodeName );\n\t\t}\n\t\tif ( display === \"inline\" &&\n\t\t\t\tjQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\tstyle.display = \"inline-block\";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always(function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t});\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\n\t\t\tdata_priv.remove( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = data_priv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t// but only if they were gotoEnd\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\tclearTimeout( timeout );\n\t\t};\n\t});\n};\n\n\n(function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: iOS 5.1, Android 4.x, Android 2.3\n\t// Check the default checkbox/radio value (\"\" on old WebKit; \"on\" elsewhere)\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Must access the parent to make an option select properly\n\t// Support: IE9, IE10\n\tsupport.optSelected = opt.selected;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as disabled)\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Check if an input maintains its value after becoming a radio\n\t// Support: IE9, IE10\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n})();\n\n\nvar nodeHook, boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle;\n\t\tif ( !isXML ) {\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ name ];\n\t\t\tattrHandle[ name ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tname.toLowerCase() :\n\t\t\t\tnull;\n\t\t\tattrHandle[ name ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n});\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i;\n\njQuery.fn.extend({\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Support: IE9+\n// Selectedness for an option in an optgroup can be inaccurate\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\njQuery.fn.extend({\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n});\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend({\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute( \"disabled\" ) === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t// Support: Webkit\n\t\t\t// \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t};\n\t}\n});\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t}\n});\n\n\nvar nonce = jQuery.now();\n\nvar rquery = (/\\?/);\n\n\n\n// Support: Android 2.3\n// Workaround failure to string-cast null input\njQuery.parseJSON = function( data ) {\n\treturn JSON.parse( data + \"\" );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, tmp;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE9\n\ttry {\n\t\ttmp = new DOMParser();\n\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\t// Document location\n\tajaxLocParts,\n\tajaxLocation,\n\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n\tajaxLocation = location.href;\n} catch( e ) {\n\t// Use the href attribute of an A element\n\t// since IE will modify it given document.location\n\tajaxLocation = document.createElement( \"a\" );\n\tajaxLocation.href = \"\";\n\tajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\tfireGlobals = s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n});\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax({\n\t\turl: url,\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t});\n};\n\n\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\n\n\njQuery.expr.filters.hidden = function( elem ) {\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n};\njQuery.expr.filters.visible = function( elem ) {\n\treturn !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function() {\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new XMLHttpRequest();\n\t} catch( e ) {}\n};\n\nvar xhrId = 0,\n\txhrCallbacks = {},\n\txhrSuccessStatus = {\n\t\t// file protocol always yields status code 0, assume 200\n\t\t0: 200,\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE9\n// Open requests must be manually aborted on unload (#5280)\nif ( window.ActiveXObject ) {\n\tjQuery( window ).on( \"unload\", function() {\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]();\n\t\t}\n\t});\n}\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport(function( options ) {\n\tvar callback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t// file: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\txhr.onerror = callback(\"error\");\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = xhrCallbacks[ id ] = callback(\"abort\");\n\n\t\t\t\t// Do send the request\n\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\tasync: true,\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t}).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context, defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[1] ) ];\n\t}\n\n\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = url.slice( off );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t}).length;\n};\n\n\n\n\nvar docElem = window.document.documentElement;\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n\n\t\t// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend({\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t});\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\telem = this[ 0 ],\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it's not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\t// BlackBerry 5, iOS 3 (original iPhone)\n\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\tbox = elem.getBoundingClientRect();\n\t\t}\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// We assume that getBoundingClientRect is available when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// getComputedStyle returns percent when specified for top/left/bottom/right\n// rather than make the css module depend on the offset module, we just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n});\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t});\n}\n\n\n\n\nvar\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in\n// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n\n}));\n",";(function(){\n\n/**\n * Require the given path.\n *\n * @param {String} path\n * @return {Object} exports\n * @api public\n */\n\nfunction require(path, parent, orig) {\n  var resolved = require.resolve(path);\n\n  // lookup failed\n  if (null == resolved) {\n    orig = orig || path;\n    parent = parent || 'root';\n    var err = new Error('Failed to require \"' + orig + '\" from \"' + parent + '\"');\n    err.path = orig;\n    err.parent = parent;\n    err.require = true;\n    throw err;\n  }\n\n  var module = require.modules[resolved];\n\n  // perform real require()\n  // by invoking the module's\n  // registered function\n  if (!module._resolving && !module.exports) {\n    var mod = {};\n    mod.exports = {};\n    mod.client = mod.component = true;\n    module._resolving = true;\n    module.call(this, mod.exports, require.relative(resolved), mod);\n    delete module._resolving;\n    module.exports = mod.exports;\n  }\n\n  return module.exports;\n}\n\n/**\n * Registered modules.\n */\n\nrequire.modules = {};\n\n/**\n * Registered aliases.\n */\n\nrequire.aliases = {};\n\n/**\n * Resolve `path`.\n *\n * Lookup:\n *\n *   - PATH/index.js\n *   - PATH.js\n *   - PATH\n *\n * @param {String} path\n * @return {String} path or null\n * @api private\n */\n\nrequire.resolve = function(path) {\n  if (path.charAt(0) === '/') path = path.slice(1);\n\n  var paths = [\n    path,\n    path + '.js',\n    path + '.json',\n    path + '/index.js',\n    path + '/index.json'\n  ];\n\n  for (var i = 0; i < paths.length; i++) {\n    var path = paths[i];\n    if (require.modules.hasOwnProperty(path)) return path;\n    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];\n  }\n};\n\n/**\n * Normalize `path` relative to the current path.\n *\n * @param {String} curr\n * @param {String} path\n * @return {String}\n * @api private\n */\n\nrequire.normalize = function(curr, path) {\n  var segs = [];\n\n  if ('.' != path.charAt(0)) return path;\n\n  curr = curr.split('/');\n  path = path.split('/');\n\n  for (var i = 0; i < path.length; ++i) {\n    if ('..' == path[i]) {\n      curr.pop();\n    } else if ('.' != path[i] && '' != path[i]) {\n      segs.push(path[i]);\n    }\n  }\n\n  return curr.concat(segs).join('/');\n};\n\n/**\n * Register module at `path` with callback `definition`.\n *\n * @param {String} path\n * @param {Function} definition\n * @api private\n */\n\nrequire.register = function(path, definition) {\n  require.modules[path] = definition;\n};\n\n/**\n * Alias a module definition.\n *\n * @param {String} from\n * @param {String} to\n * @api private\n */\n\nrequire.alias = function(from, to) {\n  if (!require.modules.hasOwnProperty(from)) {\n    throw new Error('Failed to alias \"' + from + '\", it does not exist');\n  }\n  require.aliases[to] = from;\n};\n\n/**\n * Return a require function relative to the `parent` path.\n *\n * @param {String} parent\n * @return {Function}\n * @api private\n */\n\nrequire.relative = function(parent) {\n  var p = require.normalize(parent, '..');\n\n  /**\n   * lastIndexOf helper.\n   */\n\n  function lastIndexOf(arr, obj) {\n    var i = arr.length;\n    while (i--) {\n      if (arr[i] === obj) return i;\n    }\n    return -1;\n  }\n\n  /**\n   * The relative require() itself.\n   */\n\n  function localRequire(path) {\n    var resolved = localRequire.resolve(path);\n    return require(resolved, parent, path);\n  }\n\n  /**\n   * Resolve relative to the parent.\n   */\n\n  localRequire.resolve = function(path) {\n    var c = path.charAt(0);\n    if ('/' == c) return path.slice(1);\n    if ('.' == c) return require.normalize(p, path);\n\n    // resolve deps by returning\n    // the dep in the nearest \"deps\"\n    // directory\n    var segs = parent.split('/');\n    var i = lastIndexOf(segs, 'deps') + 1;\n    if (!i) i = 0;\n    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;\n    return path;\n  };\n\n  /**\n   * Check if module is defined at `path`.\n   */\n\n  localRequire.exists = function(path) {\n    return require.modules.hasOwnProperty(localRequire.resolve(path));\n  };\n\n  return localRequire;\n};\nrequire.register(\"chaijs-assertion-error/index.js\", function(exports, require, module){\n/*!\n * assertion-error\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Return a function that will copy properties from\n * one object to another excluding any originally\n * listed. Returned function will create a new `{}`.\n *\n * @param {String} excluded properties ...\n * @return {Function}\n */\n\nfunction exclude () {\n  var excludes = [].slice.call(arguments);\n\n  function excludeProps (res, obj) {\n    Object.keys(obj).forEach(function (key) {\n      if (!~excludes.indexOf(key)) res[key] = obj[key];\n    });\n  }\n\n  return function extendExclude () {\n    var args = [].slice.call(arguments)\n      , i = 0\n      , res = {};\n\n    for (; i < args.length; i++) {\n      excludeProps(res, args[i]);\n    }\n\n    return res;\n  };\n};\n\n/*!\n * Primary Exports\n */\n\nmodule.exports = AssertionError;\n\n/**\n * ### AssertionError\n *\n * An extension of the JavaScript `Error` constructor for\n * assertion and validation scenarios.\n *\n * @param {String} message\n * @param {Object} properties to include (optional)\n * @param {callee} start stack function (optional)\n */\n\nfunction AssertionError (message, _props, ssf) {\n  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')\n    , props = extend(_props || {});\n\n  // default values\n  this.message = message || 'Unspecified AssertionError';\n  this.showDiff = false;\n\n  // copy from properties\n  for (var key in props) {\n    this[key] = props[key];\n  }\n\n  // capture stack trace\n  ssf = ssf || arguments.callee;\n  if (ssf && Error.captureStackTrace) {\n    Error.captureStackTrace(this, ssf);\n  }\n}\n\n/*!\n * Inherit from Error.prototype\n */\n\nAssertionError.prototype = Object.create(Error.prototype);\n\n/*!\n * Statically set name\n */\n\nAssertionError.prototype.name = 'AssertionError';\n\n/*!\n * Ensure correct constructor\n */\n\nAssertionError.prototype.constructor = AssertionError;\n\n/**\n * Allow errors to be converted to JSON for static transfer.\n *\n * @param {Boolean} include stack (default: `true`)\n * @return {Object} object that can be `JSON.stringify`\n */\n\nAssertionError.prototype.toJSON = function (stack) {\n  var extend = exclude('constructor', 'toJSON', 'stack')\n    , props = extend({ name: this.name }, this);\n\n  // include stack if exists and not turned off\n  if (false !== stack && this.stack) {\n    props.stack = this.stack;\n  }\n\n  return props;\n};\n\n});\nrequire.register(\"chaijs-type-detect/lib/type.js\", function(exports, require, module){\n/*!\n * type-detect\n * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Primary Exports\n */\n\nvar exports = module.exports = getType;\n\n/*!\n * Detectable javascript natives\n */\n\nvar natives = {\n    '[object Array]': 'array'\n  , '[object RegExp]': 'regexp'\n  , '[object Function]': 'function'\n  , '[object Arguments]': 'arguments'\n  , '[object Date]': 'date'\n};\n\n/**\n * ### typeOf (obj)\n *\n * Use several different techniques to determine\n * the type of object being tested.\n *\n *\n * @param {Mixed} object\n * @return {String} object type\n * @api public\n */\n\nfunction getType (obj) {\n  var str = Object.prototype.toString.call(obj);\n  if (natives[str]) return natives[str];\n  if (obj === null) return 'null';\n  if (obj === undefined) return 'undefined';\n  if (obj === Object(obj)) return 'object';\n  return typeof obj;\n}\n\nexports.Library = Library;\n\n/**\n * ### Library\n *\n * Create a repository for custom type detection.\n *\n * ```js\n * var lib = new type.Library;\n * ```\n *\n */\n\nfunction Library () {\n  this.tests = {};\n}\n\n/**\n * #### .of (obj)\n *\n * Expose replacement `typeof` detection to the library.\n *\n * ```js\n * if ('string' === lib.of('hello world')) {\n *   // ...\n * }\n * ```\n *\n * @param {Mixed} object to test\n * @return {String} type\n */\n\nLibrary.prototype.of = getType;\n\n/**\n * #### .define (type, test)\n *\n * Add a test to for the `.test()` assertion.\n *\n * Can be defined as a regular expression:\n *\n * ```js\n * lib.define('int', /^[0-9]+$/);\n * ```\n *\n * ... or as a function:\n *\n * ```js\n * lib.define('bln', function (obj) {\n *   if ('boolean' === lib.of(obj)) return true;\n *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n *   return !! ~blns.indexOf(obj);\n * });\n * ```\n *\n * @param {String} type\n * @param {RegExp|Function} test\n * @api public\n */\n\nLibrary.prototype.define = function (type, test) {\n  if (arguments.length === 1) return this.tests[type];\n  this.tests[type] = test;\n  return this;\n};\n\n/**\n * #### .test (obj, test)\n *\n * Assert that an object is of type. Will first\n * check natives, and if that does not pass it will\n * use the user defined custom tests.\n *\n * ```js\n * assert(lib.test('1', 'int'));\n * assert(lib.test('yes', 'bln'));\n * ```\n *\n * @param {Mixed} object\n * @param {String} type\n * @return {Boolean} result\n * @api public\n */\n\nLibrary.prototype.test = function (obj, type) {\n  if (type === getType(obj)) return true;\n  var test = this.tests[type];\n\n  if (test && 'regexp' === getType(test)) {\n    return test.test(obj);\n  } else if (test && 'function' === getType(test)) {\n    return test(obj);\n  } else {\n    throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n  }\n};\n\n});\nrequire.register(\"chaijs-deep-eql/lib/eql.js\", function(exports, require, module){\n/*!\n * deep-eql\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar type = require('type-detect');\n\n/*!\n * Buffer.isBuffer browser shim\n */\n\nvar Buffer;\ntry { Buffer = require('buffer').Buffer; }\ncatch(ex) {\n  Buffer = {};\n  Buffer.isBuffer = function() { return false; }\n}\n\n/*!\n * Primary Export\n */\n\nmodule.exports = deepEqual;\n\n/**\n * Assert super-strict (egal) equality between\n * two objects of any type.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @param {Array} memoised (optional)\n * @return {Boolean} equal match\n */\n\nfunction deepEqual(a, b, m) {\n  if (sameValue(a, b)) {\n    return true;\n  } else if ('date' === type(a)) {\n    return dateEqual(a, b);\n  } else if ('regexp' === type(a)) {\n    return regexpEqual(a, b);\n  } else if (Buffer.isBuffer(a)) {\n    return bufferEqual(a, b);\n  } else if ('arguments' === type(a)) {\n    return argumentsEqual(a, b, m);\n  } else if (!typeEqual(a, b)) {\n    return false;\n  } else if (('object' !== type(a) && 'object' !== type(b))\n  && ('array' !== type(a) && 'array' !== type(b))) {\n    return sameValue(a, b);\n  } else {\n    return objectEqual(a, b, m);\n  }\n}\n\n/*!\n * Strict (egal) equality test. Ensures that NaN always\n * equals NaN and `-0` does not equal `+0`.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} equal match\n */\n\nfunction sameValue(a, b) {\n  if (a === b) return a !== 0 || 1 / a === 1 / b;\n  return a !== a && b !== b;\n}\n\n/*!\n * Compare the types of two given objects and\n * return if they are equal. Note that an Array\n * has a type of `array` (not `object`) and arguments\n * have a type of `arguments` (not `array`/`object`).\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction typeEqual(a, b) {\n  return type(a) === type(b);\n}\n\n/*!\n * Compare two Date objects by asserting that\n * the time values are equal using `saveValue`.\n *\n * @param {Date} a\n * @param {Date} b\n * @return {Boolean} result\n */\n\nfunction dateEqual(a, b) {\n  if ('date' !== type(b)) return false;\n  return sameValue(a.getTime(), b.getTime());\n}\n\n/*!\n * Compare two regular expressions by converting them\n * to string and checking for `sameValue`.\n *\n * @param {RegExp} a\n * @param {RegExp} b\n * @return {Boolean} result\n */\n\nfunction regexpEqual(a, b) {\n  if ('regexp' !== type(b)) return false;\n  return sameValue(a.toString(), b.toString());\n}\n\n/*!\n * Assert deep equality of two `arguments` objects.\n * Unfortunately, these must be sliced to arrays\n * prior to test to ensure no bad behavior.\n *\n * @param {Arguments} a\n * @param {Arguments} b\n * @param {Array} memoize (optional)\n * @return {Boolean} result\n */\n\nfunction argumentsEqual(a, b, m) {\n  if ('arguments' !== type(b)) return false;\n  a = [].slice.call(a);\n  b = [].slice.call(b);\n  return deepEqual(a, b, m);\n}\n\n/*!\n * Get enumerable properties of a given object.\n *\n * @param {Object} a\n * @return {Array} property names\n */\n\nfunction enumerable(a) {\n  var res = [];\n  for (var key in a) res.push(key);\n  return res;\n}\n\n/*!\n * Simple equality for flat iterable objects\n * such as Arrays or Node.js buffers.\n *\n * @param {Iterable} a\n * @param {Iterable} b\n * @return {Boolean} result\n */\n\nfunction iterableEqual(a, b) {\n  if (a.length !==  b.length) return false;\n\n  var i = 0;\n  var match = true;\n\n  for (; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      match = false;\n      break;\n    }\n  }\n\n  return match;\n}\n\n/*!\n * Extension to `iterableEqual` specifically\n * for Node.js Buffers.\n *\n * @param {Buffer} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction bufferEqual(a, b) {\n  if (!Buffer.isBuffer(b)) return false;\n  return iterableEqual(a, b);\n}\n\n/*!\n * Block for `objectEqual` ensuring non-existing\n * values don't get in.\n *\n * @param {Mixed} object\n * @return {Boolean} result\n */\n\nfunction isValue(a) {\n  return a !== null && a !== undefined;\n}\n\n/*!\n * Recursively check the equality of two objects.\n * Once basic sameness has been established it will\n * defer to `deepEqual` for each enumerable key\n * in the object.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction objectEqual(a, b, m) {\n  if (!isValue(a) || !isValue(b)) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  var i;\n  if (m) {\n    for (i = 0; i < m.length; i++) {\n      if ((m[i][0] === a && m[i][1] === b)\n      ||  (m[i][0] === b && m[i][1] === a)) {\n        return true;\n      }\n    }\n  } else {\n    m = [];\n  }\n\n  try {\n    var ka = enumerable(a);\n    var kb = enumerable(b);\n  } catch (ex) {\n    return false;\n  }\n\n  ka.sort();\n  kb.sort();\n\n  if (!iterableEqual(ka, kb)) {\n    return false;\n  }\n\n  m.push([ a, b ]);\n\n  var key;\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], m)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n});\nrequire.register(\"chai/index.js\", function(exports, require, module){\nmodule.exports = require('./lib/chai');\n\n});\nrequire.register(\"chai/lib/chai.js\", function(exports, require, module){\n/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar used = []\n  , exports = module.exports = {};\n\n/*!\n * Chai version\n */\n\nexports.version = '1.8.1';\n\n/*!\n * Assertion Error\n */\n\nexports.AssertionError = require('assertion-error');\n\n/*!\n * Utils for plugins (not exported)\n */\n\nvar util = require('./chai/utils');\n\n/**\n * # .use(function)\n *\n * Provides a way to extend the internals of Chai\n *\n * @param {Function}\n * @returns {this} for chaining\n * @api public\n */\n\nexports.use = function (fn) {\n  if (!~used.indexOf(fn)) {\n    fn(this, util);\n    used.push(fn);\n  }\n\n  return this;\n};\n\n/*!\n * Primary `Assertion` prototype\n */\n\nvar assertion = require('./chai/assertion');\nexports.use(assertion);\n\n/*!\n * Core Assertions\n */\n\nvar core = require('./chai/core/assertions');\nexports.use(core);\n\n/*!\n * Expect interface\n */\n\nvar expect = require('./chai/interface/expect');\nexports.use(expect);\n\n/*!\n * Should interface\n */\n\nvar should = require('./chai/interface/should');\nexports.use(should);\n\n/*!\n * Assert interface\n */\n\nvar assert = require('./chai/interface/assert');\nexports.use(assert);\n\n});\nrequire.register(\"chai/lib/chai/assertion.js\", function(exports, require, module){\n/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (_chai, util) {\n  /*!\n   * Module dependencies.\n   */\n\n  var AssertionError = _chai.AssertionError\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  _chai.Assertion = Assertion;\n\n  /*!\n   * Assertion Constructor\n   *\n   * Creates object for chaining.\n   *\n   * @api private\n   */\n\n  function Assertion (obj, msg, stack) {\n    flag(this, 'ssfi', stack || arguments.callee);\n    flag(this, 'object', obj);\n    flag(this, 'message', msg);\n  }\n\n  /*!\n    * ### Assertion.includeStack\n    *\n    * User configurable property, influences whether stack trace\n    * is included in Assertion error message. Default of false\n    * suppresses stack trace in the error message\n    *\n    *     Assertion.includeStack = true;  // enable stack on error\n    *\n    * @api public\n    */\n\n  Assertion.includeStack = false;\n\n  /*!\n   * ### Assertion.showDiff\n   *\n   * User configurable property, influences whether or not\n   * the `showDiff` flag should be included in the thrown\n   * AssertionErrors. `false` will always be `false`; `true`\n   * will be true when the assertion has requested a diff\n   * be shown.\n   *\n   * @api public\n   */\n\n  Assertion.showDiff = true;\n\n  Assertion.addProperty = function (name, fn) {\n    util.addProperty(this.prototype, name, fn);\n  };\n\n  Assertion.addMethod = function (name, fn) {\n    util.addMethod(this.prototype, name, fn);\n  };\n\n  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\n    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  Assertion.overwriteProperty = function (name, fn) {\n    util.overwriteProperty(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteMethod = function (name, fn) {\n    util.overwriteMethod(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  /*!\n   * ### .assert(expression, message, negateMessage, expected, actual)\n   *\n   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\n   *\n   * @name assert\n   * @param {Philosophical} expression to be tested\n   * @param {String} message to display if fails\n   * @param {String} negatedMessage to display if negated expression fails\n   * @param {Mixed} expected value (remember to check for negation)\n   * @param {Mixed} actual (optional) will default to `this.obj`\n   * @api private\n   */\n\n  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n    var ok = util.test(this, arguments);\n    if (true !== showDiff) showDiff = false;\n    if (true !== Assertion.showDiff) showDiff = false;\n\n    if (!ok) {\n      var msg = util.getMessage(this, arguments)\n        , actual = util.getActual(this, arguments);\n      throw new AssertionError(msg, {\n          actual: actual\n        , expected: expected\n        , showDiff: showDiff\n      }, (Assertion.includeStack) ? this.assert : flag(this, 'ssfi'));\n    }\n  };\n\n  /*!\n   * ### ._obj\n   *\n   * Quick reference to stored `actual` value for plugin developers.\n   *\n   * @api private\n   */\n\n  Object.defineProperty(Assertion.prototype, '_obj',\n    { get: function () {\n        return flag(this, 'object');\n      }\n    , set: function (val) {\n        flag(this, 'object', val);\n      }\n  });\n};\n\n});\nrequire.register(\"chai/lib/chai/core/assertions.js\", function(exports, require, module){\n/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, _) {\n  var Assertion = chai.Assertion\n    , toString = Object.prototype.toString\n    , flag = _.flag;\n\n  /**\n   * ### Language Chains\n   *\n   * The following are provided as chainable getters to\n   * improve the readability of your assertions. They\n   * do not provide an testing capability unless they\n   * have been overwritten by a plugin.\n   *\n   * **Chains**\n   *\n   * - to\n   * - be\n   * - been\n   * - is\n   * - that\n   * - and\n   * - has\n   * - have\n   * - with\n   * - at\n   * - of\n   * - same\n   *\n   * @name language chains\n   * @api public\n   */\n\n  [ 'to', 'be', 'been'\n  , 'is', 'and', 'has', 'have'\n  , 'with', 'that', 'at'\n  , 'of', 'same' ].forEach(function (chain) {\n    Assertion.addProperty(chain, function () {\n      return this;\n    });\n  });\n\n  /**\n   * ### .not\n   *\n   * Negates any of assertions following in the chain.\n   *\n   *     expect(foo).to.not.equal('bar');\n   *     expect(goodFn).to.not.throw(Error);\n   *     expect({ foo: 'baz' }).to.have.property('foo')\n   *       .and.not.equal('bar');\n   *\n   * @name not\n   * @api public\n   */\n\n  Assertion.addProperty('not', function () {\n    flag(this, 'negate', true);\n  });\n\n  /**\n   * ### .deep\n   *\n   * Sets the `deep` flag, later used by the `equal` and\n   * `property` assertions.\n   *\n   *     expect(foo).to.deep.equal({ bar: 'baz' });\n   *     expect({ foo: { bar: { baz: 'quux' } } })\n   *       .to.have.deep.property('foo.bar.baz', 'quux');\n   *\n   * @name deep\n   * @api public\n   */\n\n  Assertion.addProperty('deep', function () {\n    flag(this, 'deep', true);\n  });\n\n  /**\n   * ### .a(type)\n   *\n   * The `a` and `an` assertions are aliases that can be\n   * used either as language chains or to assert a value's\n   * type.\n   *\n   *     // typeof\n   *     expect('test').to.be.a('string');\n   *     expect({ foo: 'bar' }).to.be.an('object');\n   *     expect(null).to.be.a('null');\n   *     expect(undefined).to.be.an('undefined');\n   *\n   *     // language chain\n   *     expect(foo).to.be.an.instanceof(Foo);\n   *\n   * @name a\n   * @alias an\n   * @param {String} type\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function an (type, msg) {\n    if (msg) flag(this, 'message', msg);\n    type = type.toLowerCase();\n    var obj = flag(this, 'object')\n      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n\n    this.assert(\n        type === _.type(obj)\n      , 'expected #{this} to be ' + article + type\n      , 'expected #{this} not to be ' + article + type\n    );\n  }\n\n  Assertion.addChainableMethod('an', an);\n  Assertion.addChainableMethod('a', an);\n\n  /**\n   * ### .include(value)\n   *\n   * The `include` and `contain` assertions can be used as either property\n   * based language chains or as methods to assert the inclusion of an object\n   * in an array or a substring in a string. When used as language chains,\n   * they toggle the `contain` flag for the `keys` assertion.\n   *\n   *     expect([1,2,3]).to.include(2);\n   *     expect('foobar').to.contain('foo');\n   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');\n   *\n   * @name include\n   * @alias contain\n   * @param {Object|String|Number} obj\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function includeChainingBehavior () {\n    flag(this, 'contains', true);\n  }\n\n  function include (val, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n\n    if (_.type(val) === 'object') {\n      if (!flag(this, 'negate')) {\n        for (var k in val) new Assertion(obj).property(k, val[k]);\n        return;\n      }\n      var subset = {}\n      for (var k in val) subset[k] = obj[k]\n      var expected = _.eql(subset, val);\n    } else {\n      var expected = obj && ~obj.indexOf(val)\n    }\n    this.assert(\n        expected\n      , 'expected #{this} to include ' + _.inspect(val)\n      , 'expected #{this} to not include ' + _.inspect(val));\n  }\n\n  Assertion.addChainableMethod('include', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contain', include, includeChainingBehavior);\n\n  /**\n   * ### .ok\n   *\n   * Asserts that the target is truthy.\n   *\n   *     expect('everthing').to.be.ok;\n   *     expect(1).to.be.ok;\n   *     expect(false).to.not.be.ok;\n   *     expect(undefined).to.not.be.ok;\n   *     expect(null).to.not.be.ok;\n   *\n   * @name ok\n   * @api public\n   */\n\n  Assertion.addProperty('ok', function () {\n    this.assert(\n        flag(this, 'object')\n      , 'expected #{this} to be truthy'\n      , 'expected #{this} to be falsy');\n  });\n\n  /**\n   * ### .true\n   *\n   * Asserts that the target is `true`.\n   *\n   *     expect(true).to.be.true;\n   *     expect(1).to.not.be.true;\n   *\n   * @name true\n   * @api public\n   */\n\n  Assertion.addProperty('true', function () {\n    this.assert(\n        true === flag(this, 'object')\n      , 'expected #{this} to be true'\n      , 'expected #{this} to be false'\n      , this.negate ? false : true\n    );\n  });\n\n  /**\n   * ### .false\n   *\n   * Asserts that the target is `false`.\n   *\n   *     expect(false).to.be.false;\n   *     expect(0).to.not.be.false;\n   *\n   * @name false\n   * @api public\n   */\n\n  Assertion.addProperty('false', function () {\n    this.assert(\n        false === flag(this, 'object')\n      , 'expected #{this} to be false'\n      , 'expected #{this} to be true'\n      , this.negate ? true : false\n    );\n  });\n\n  /**\n   * ### .null\n   *\n   * Asserts that the target is `null`.\n   *\n   *     expect(null).to.be.null;\n   *     expect(undefined).not.to.be.null;\n   *\n   * @name null\n   * @api public\n   */\n\n  Assertion.addProperty('null', function () {\n    this.assert(\n        null === flag(this, 'object')\n      , 'expected #{this} to be null'\n      , 'expected #{this} not to be null'\n    );\n  });\n\n  /**\n   * ### .undefined\n   *\n   * Asserts that the target is `undefined`.\n   *\n   *     expect(undefined).to.be.undefined;\n   *     expect(null).to.not.be.undefined;\n   *\n   * @name undefined\n   * @api public\n   */\n\n  Assertion.addProperty('undefined', function () {\n    this.assert(\n        undefined === flag(this, 'object')\n      , 'expected #{this} to be undefined'\n      , 'expected #{this} not to be undefined'\n    );\n  });\n\n  /**\n   * ### .exist\n   *\n   * Asserts that the target is neither `null` nor `undefined`.\n   *\n   *     var foo = 'hi'\n   *       , bar = null\n   *       , baz;\n   *\n   *     expect(foo).to.exist;\n   *     expect(bar).to.not.exist;\n   *     expect(baz).to.not.exist;\n   *\n   * @name exist\n   * @api public\n   */\n\n  Assertion.addProperty('exist', function () {\n    this.assert(\n        null != flag(this, 'object')\n      , 'expected #{this} to exist'\n      , 'expected #{this} to not exist'\n    );\n  });\n\n\n  /**\n   * ### .empty\n   *\n   * Asserts that the target's length is `0`. For arrays, it checks\n   * the `length` property. For objects, it gets the count of\n   * enumerable keys.\n   *\n   *     expect([]).to.be.empty;\n   *     expect('').to.be.empty;\n   *     expect({}).to.be.empty;\n   *\n   * @name empty\n   * @api public\n   */\n\n  Assertion.addProperty('empty', function () {\n    var obj = flag(this, 'object')\n      , expected = obj;\n\n    if (Array.isArray(obj) || 'string' === typeof object) {\n      expected = obj.length;\n    } else if (typeof obj === 'object') {\n      expected = Object.keys(obj).length;\n    }\n\n    this.assert(\n        !expected\n      , 'expected #{this} to be empty'\n      , 'expected #{this} not to be empty'\n    );\n  });\n\n  /**\n   * ### .arguments\n   *\n   * Asserts that the target is an arguments object.\n   *\n   *     function test () {\n   *       expect(arguments).to.be.arguments;\n   *     }\n   *\n   * @name arguments\n   * @alias Arguments\n   * @api public\n   */\n\n  function checkArguments () {\n    var obj = flag(this, 'object')\n      , type = Object.prototype.toString.call(obj);\n    this.assert(\n        '[object Arguments]' === type\n      , 'expected #{this} to be arguments but got ' + type\n      , 'expected #{this} to not be arguments'\n    );\n  }\n\n  Assertion.addProperty('arguments', checkArguments);\n  Assertion.addProperty('Arguments', checkArguments);\n\n  /**\n   * ### .equal(value)\n   *\n   * Asserts that the target is strictly equal (`===`) to `value`.\n   * Alternately, if the `deep` flag is set, asserts that\n   * the target is deeply equal to `value`.\n   *\n   *     expect('hello').to.equal('hello');\n   *     expect(42).to.equal(42);\n   *     expect(1).to.not.equal(true);\n   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });\n   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });\n   *\n   * @name equal\n   * @alias equals\n   * @alias eq\n   * @alias deep.equal\n   * @param {Mixed} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertEqual (val, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'deep')) {\n      return this.eql(val);\n    } else {\n      this.assert(\n          val === obj\n        , 'expected #{this} to equal #{exp}'\n        , 'expected #{this} to not equal #{exp}'\n        , val\n        , this._obj\n        , true\n      );\n    }\n  }\n\n  Assertion.addMethod('equal', assertEqual);\n  Assertion.addMethod('equals', assertEqual);\n  Assertion.addMethod('eq', assertEqual);\n\n  /**\n   * ### .eql(value)\n   *\n   * Asserts that the target is deeply equal to `value`.\n   *\n   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });\n   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);\n   *\n   * @name eql\n   * @alias eqls\n   * @param {Mixed} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertEql(obj, msg) {\n    if (msg) flag(this, 'message', msg);\n    this.assert(\n        _.eql(obj, flag(this, 'object'))\n      , 'expected #{this} to deeply equal #{exp}'\n      , 'expected #{this} to not deeply equal #{exp}'\n      , obj\n      , this._obj\n      , true\n    );\n  }\n\n  Assertion.addMethod('eql', assertEql);\n  Assertion.addMethod('eqls', assertEql);\n\n  /**\n   * ### .above(value)\n   *\n   * Asserts that the target is greater than `value`.\n   *\n   *     expect(10).to.be.above(5);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a minimum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.above(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n   *\n   * @name above\n   * @alias gt\n   * @alias greaterThan\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertAbove (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len > n\n        , 'expected #{this} to have a length above #{exp} but got #{act}'\n        , 'expected #{this} to not have a length above #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj > n\n        , 'expected #{this} to be above ' + n\n        , 'expected #{this} to be at most ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('above', assertAbove);\n  Assertion.addMethod('gt', assertAbove);\n  Assertion.addMethod('greaterThan', assertAbove);\n\n  /**\n   * ### .least(value)\n   *\n   * Asserts that the target is greater than or equal to `value`.\n   *\n   *     expect(10).to.be.at.least(10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a minimum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.of.at.least(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);\n   *\n   * @name least\n   * @alias gte\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertLeast (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len >= n\n        , 'expected #{this} to have a length at least #{exp} but got #{act}'\n        , 'expected #{this} to have a length below #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj >= n\n        , 'expected #{this} to be at least ' + n\n        , 'expected #{this} to be below ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('least', assertLeast);\n  Assertion.addMethod('gte', assertLeast);\n\n  /**\n   * ### .below(value)\n   *\n   * Asserts that the target is less than `value`.\n   *\n   *     expect(5).to.be.below(10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a maximum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.below(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n   *\n   * @name below\n   * @alias lt\n   * @alias lessThan\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertBelow (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len < n\n        , 'expected #{this} to have a length below #{exp} but got #{act}'\n        , 'expected #{this} to not have a length below #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj < n\n        , 'expected #{this} to be below ' + n\n        , 'expected #{this} to be at least ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('below', assertBelow);\n  Assertion.addMethod('lt', assertBelow);\n  Assertion.addMethod('lessThan', assertBelow);\n\n  /**\n   * ### .most(value)\n   *\n   * Asserts that the target is less than or equal to `value`.\n   *\n   *     expect(5).to.be.at.most(5);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a maximum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.of.at.most(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);\n   *\n   * @name most\n   * @alias lte\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertMost (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len <= n\n        , 'expected #{this} to have a length at most #{exp} but got #{act}'\n        , 'expected #{this} to have a length above #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj <= n\n        , 'expected #{this} to be at most ' + n\n        , 'expected #{this} to be above ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('most', assertMost);\n  Assertion.addMethod('lte', assertMost);\n\n  /**\n   * ### .within(start, finish)\n   *\n   * Asserts that the target is within a range.\n   *\n   *     expect(7).to.be.within(5,10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a length range. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.within(2,4);\n   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n   *\n   * @name within\n   * @param {Number} start lowerbound inclusive\n   * @param {Number} finish upperbound inclusive\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('within', function (start, finish, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , range = start + '..' + finish;\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len >= start && len <= finish\n        , 'expected #{this} to have a length within ' + range\n        , 'expected #{this} to not have a length within ' + range\n      );\n    } else {\n      this.assert(\n          obj >= start && obj <= finish\n        , 'expected #{this} to be within ' + range\n        , 'expected #{this} to not be within ' + range\n      );\n    }\n  });\n\n  /**\n   * ### .instanceof(constructor)\n   *\n   * Asserts that the target is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , Chai = new Tea('chai');\n   *\n   *     expect(Chai).to.be.an.instanceof(Tea);\n   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);\n   *\n   * @name instanceof\n   * @param {Constructor} constructor\n   * @param {String} message _optional_\n   * @alias instanceOf\n   * @api public\n   */\n\n  function assertInstanceOf (constructor, msg) {\n    if (msg) flag(this, 'message', msg);\n    var name = _.getName(constructor);\n    this.assert(\n        flag(this, 'object') instanceof constructor\n      , 'expected #{this} to be an instance of ' + name\n      , 'expected #{this} to not be an instance of ' + name\n    );\n  };\n\n  Assertion.addMethod('instanceof', assertInstanceOf);\n  Assertion.addMethod('instanceOf', assertInstanceOf);\n\n  /**\n   * ### .property(name, [value])\n   *\n   * Asserts that the target has a property `name`, optionally asserting that\n   * the value of that property is strictly equal to  `value`.\n   * If the `deep` flag is set, you can use dot- and bracket-notation for deep\n   * references into objects and arrays.\n   *\n   *     // simple referencing\n   *     var obj = { foo: 'bar' };\n   *     expect(obj).to.have.property('foo');\n   *     expect(obj).to.have.property('foo', 'bar');\n   *\n   *     // deep referencing\n   *     var deepObj = {\n   *         green: { tea: 'matcha' }\n   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]\n   *     };\n\n   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');\n   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');\n   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');\n   *\n   * You can also use an array as the starting point of a `deep.property`\n   * assertion, or traverse nested arrays.\n   *\n   *     var arr = [\n   *         [ 'chai', 'matcha', 'konacha' ]\n   *       , [ { tea: 'chai' }\n   *         , { tea: 'matcha' }\n   *         , { tea: 'konacha' } ]\n   *     ];\n   *\n   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');\n   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');\n   *\n   * Furthermore, `property` changes the subject of the assertion\n   * to be the value of that property from the original object. This\n   * permits for further chainable assertions on that property.\n   *\n   *     expect(obj).to.have.property('foo')\n   *       .that.is.a('string');\n   *     expect(deepObj).to.have.property('green')\n   *       .that.is.an('object')\n   *       .that.deep.equals({ tea: 'matcha' });\n   *     expect(deepObj).to.have.property('teas')\n   *       .that.is.an('array')\n   *       .with.deep.property('[2]')\n   *         .that.deep.equals({ tea: 'konacha' });\n   *\n   * @name property\n   * @alias deep.property\n   * @param {String} name\n   * @param {Mixed} value (optional)\n   * @param {String} message _optional_\n   * @returns value of property for chaining\n   * @api public\n   */\n\n  Assertion.addMethod('property', function (name, val, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '\n      , negate = flag(this, 'negate')\n      , obj = flag(this, 'object')\n      , value = flag(this, 'deep')\n        ? _.getPathValue(name, obj)\n        : obj[name];\n\n    if (negate && undefined !== val) {\n      if (undefined === value) {\n        msg = (msg != null) ? msg + ': ' : '';\n        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));\n      }\n    } else {\n      this.assert(\n          undefined !== value\n        , 'expected #{this} to have a ' + descriptor + _.inspect(name)\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name));\n    }\n\n    if (undefined !== val) {\n      this.assert(\n          val === value\n        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\n        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'\n        , val\n        , value\n      );\n    }\n\n    flag(this, 'object', value);\n  });\n\n\n  /**\n   * ### .ownProperty(name)\n   *\n   * Asserts that the target has an own property `name`.\n   *\n   *     expect('test').to.have.ownProperty('length');\n   *\n   * @name ownProperty\n   * @alias haveOwnProperty\n   * @param {String} name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertOwnProperty (name, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        obj.hasOwnProperty(name)\n      , 'expected #{this} to have own property ' + _.inspect(name)\n      , 'expected #{this} to not have own property ' + _.inspect(name)\n    );\n  }\n\n  Assertion.addMethod('ownProperty', assertOwnProperty);\n  Assertion.addMethod('haveOwnProperty', assertOwnProperty);\n\n  /**\n   * ### .length(value)\n   *\n   * Asserts that the target's `length` property has\n   * the expected value.\n   *\n   *     expect([ 1, 2, 3]).to.have.length(3);\n   *     expect('foobar').to.have.length(6);\n   *\n   * Can also be used as a chain precursor to a value\n   * comparison for the length property.\n   *\n   *     expect('foo').to.have.length.above(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n   *     expect('foo').to.have.length.below(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n   *     expect('foo').to.have.length.within(2,4);\n   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n   *\n   * @name length\n   * @alias lengthOf\n   * @param {Number} length\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertLengthChain () {\n    flag(this, 'doLength', true);\n  }\n\n  function assertLength (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).to.have.property('length');\n    var len = obj.length;\n\n    this.assert(\n        len == n\n      , 'expected #{this} to have a length of #{exp} but got #{act}'\n      , 'expected #{this} to not have a length of #{act}'\n      , n\n      , len\n    );\n  }\n\n  Assertion.addChainableMethod('length', assertLength, assertLengthChain);\n  Assertion.addMethod('lengthOf', assertLength, assertLengthChain);\n\n  /**\n   * ### .match(regexp)\n   *\n   * Asserts that the target matches a regular expression.\n   *\n   *     expect('foobar').to.match(/^foo/);\n   *\n   * @name match\n   * @param {RegExp} RegularExpression\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('match', function (re, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        re.exec(obj)\n      , 'expected #{this} to match ' + re\n      , 'expected #{this} not to match ' + re\n    );\n  });\n\n  /**\n   * ### .string(string)\n   *\n   * Asserts that the string target contains another string.\n   *\n   *     expect('foobar').to.have.string('bar');\n   *\n   * @name string\n   * @param {String} string\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('string', function (str, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).is.a('string');\n\n    this.assert(\n        ~obj.indexOf(str)\n      , 'expected #{this} to contain ' + _.inspect(str)\n      , 'expected #{this} to not contain ' + _.inspect(str)\n    );\n  });\n\n\n  /**\n   * ### .keys(key1, [key2], [...])\n   *\n   * Asserts that the target has exactly the given keys, or\n   * asserts the inclusion of some keys when using the\n   * `include` or `contain` modifiers.\n   *\n   *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);\n   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');\n   *\n   * @name keys\n   * @alias key\n   * @param {String...|Array} keys\n   * @api public\n   */\n\n  function assertKeys (keys) {\n    var obj = flag(this, 'object')\n      , str\n      , ok = true;\n\n    keys = keys instanceof Array\n      ? keys\n      : Array.prototype.slice.call(arguments);\n\n    if (!keys.length) throw new Error('keys required');\n\n    var actual = Object.keys(obj)\n      , len = keys.length;\n\n    // Inclusion\n    ok = keys.every(function(key){\n      return ~actual.indexOf(key);\n    });\n\n    // Strict\n    if (!flag(this, 'negate') && !flag(this, 'contains')) {\n      ok = ok && keys.length == actual.length;\n    }\n\n    // Key string\n    if (len > 1) {\n      keys = keys.map(function(key){\n        return _.inspect(key);\n      });\n      var last = keys.pop();\n      str = keys.join(', ') + ', and ' + last;\n    } else {\n      str = _.inspect(keys[0]);\n    }\n\n    // Form\n    str = (len > 1 ? 'keys ' : 'key ') + str;\n\n    // Have / include\n    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\n\n    // Assertion\n    this.assert(\n        ok\n      , 'expected #{this} to ' + str\n      , 'expected #{this} to not ' + str\n    );\n  }\n\n  Assertion.addMethod('keys', assertKeys);\n  Assertion.addMethod('key', assertKeys);\n\n  /**\n   * ### .throw(constructor)\n   *\n   * Asserts that the function target will throw a specific error, or specific type of error\n   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test\n   * for the error's message.\n   *\n   *     var err = new ReferenceError('This is a bad function.');\n   *     var fn = function () { throw err; }\n   *     expect(fn).to.throw(ReferenceError);\n   *     expect(fn).to.throw(Error);\n   *     expect(fn).to.throw(/bad function/);\n   *     expect(fn).to.not.throw('good function');\n   *     expect(fn).to.throw(ReferenceError, /bad function/);\n   *     expect(fn).to.throw(err);\n   *     expect(fn).to.not.throw(new RangeError('Out of range.'));\n   *\n   * Please note that when a throw expectation is negated, it will check each\n   * parameter independently, starting with error constructor type. The appropriate way\n   * to check for the existence of a type of error but for a message that does not match\n   * is to use `and`.\n   *\n   *     expect(fn).to.throw(ReferenceError)\n   *        .and.not.throw(/good function/);\n   *\n   * @name throw\n   * @alias throws\n   * @alias Throw\n   * @param {ErrorConstructor} constructor\n   * @param {String|RegExp} expected error message\n   * @param {String} message _optional_\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @returns error for chaining (null if no error)\n   * @api public\n   */\n\n  function assertThrows (constructor, errMsg, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).is.a('function');\n\n    var thrown = false\n      , desiredError = null\n      , name = null\n      , thrownError = null;\n\n    if (arguments.length === 0) {\n      errMsg = null;\n      constructor = null;\n    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {\n      errMsg = constructor;\n      constructor = null;\n    } else if (constructor && constructor instanceof Error) {\n      desiredError = constructor;\n      constructor = null;\n      errMsg = null;\n    } else if (typeof constructor === 'function') {\n      name = constructor.prototype.name || constructor.name;\n      if (name === 'Error' && constructor !== Error) {\n        name = (new constructor()).name;\n      }\n    } else {\n      constructor = null;\n    }\n\n    try {\n      obj();\n    } catch (err) {\n      // first, check desired error\n      if (desiredError) {\n        this.assert(\n            err === desiredError\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n          , 'expected #{this} to not throw #{exp}'\n          , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n          , (err instanceof Error ? err.toString() : err)\n        );\n\n        flag(this, 'object', err);\n        return this;\n      }\n\n      // next, check constructor\n      if (constructor) {\n        this.assert(\n            err instanceof constructor\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n          , 'expected #{this} to not throw #{exp} but #{act} was thrown'\n          , name\n          , (err instanceof Error ? err.toString() : err)\n        );\n\n        if (!errMsg) {\n          flag(this, 'object', err);\n          return this;\n        }\n      }\n\n      // next, check message\n      var message = 'object' === _.type(err) && \"message\" in err\n        ? err.message\n        : '' + err;\n\n      if ((message != null) && errMsg && errMsg instanceof RegExp) {\n        this.assert(\n            errMsg.exec(message)\n          , 'expected #{this} to throw error matching #{exp} but got #{act}'\n          , 'expected #{this} to throw error not matching #{exp}'\n          , errMsg\n          , message\n        );\n\n        flag(this, 'object', err);\n        return this;\n      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {\n        this.assert(\n            ~message.indexOf(errMsg)\n          , 'expected #{this} to throw error including #{exp} but got #{act}'\n          , 'expected #{this} to throw error not including #{act}'\n          , errMsg\n          , message\n        );\n\n        flag(this, 'object', err);\n        return this;\n      } else {\n        thrown = true;\n        thrownError = err;\n      }\n    }\n\n    var actuallyGot = ''\n      , expectedThrown = name !== null\n        ? name\n        : desiredError\n          ? '#{exp}' //_.inspect(desiredError)\n          : 'an error';\n\n    if (thrown) {\n      actuallyGot = ' but #{act} was thrown'\n    }\n\n    this.assert(\n        thrown === true\n      , 'expected #{this} to throw ' + expectedThrown + actuallyGot\n      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot\n      , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n      , (thrownError instanceof Error ? thrownError.toString() : thrownError)\n    );\n\n    flag(this, 'object', thrownError);\n  };\n\n  Assertion.addMethod('throw', assertThrows);\n  Assertion.addMethod('throws', assertThrows);\n  Assertion.addMethod('Throw', assertThrows);\n\n  /**\n   * ### .respondTo(method)\n   *\n   * Asserts that the object or class target will respond to a method.\n   *\n   *     Klass.prototype.bar = function(){};\n   *     expect(Klass).to.respondTo('bar');\n   *     expect(obj).to.respondTo('bar');\n   *\n   * To check if a constructor will respond to a static function,\n   * set the `itself` flag.\n   *\n   *     Klass.baz = function(){};\n   *     expect(Klass).itself.to.respondTo('baz');\n   *\n   * @name respondTo\n   * @param {String} method\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('respondTo', function (method, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , itself = flag(this, 'itself')\n      , context = ('function' === _.type(obj) && !itself)\n        ? obj.prototype[method]\n        : obj[method];\n\n    this.assert(\n        'function' === typeof context\n      , 'expected #{this} to respond to ' + _.inspect(method)\n      , 'expected #{this} to not respond to ' + _.inspect(method)\n    );\n  });\n\n  /**\n   * ### .itself\n   *\n   * Sets the `itself` flag, later used by the `respondTo` assertion.\n   *\n   *     function Foo() {}\n   *     Foo.bar = function() {}\n   *     Foo.prototype.baz = function() {}\n   *\n   *     expect(Foo).itself.to.respondTo('bar');\n   *     expect(Foo).itself.not.to.respondTo('baz');\n   *\n   * @name itself\n   * @api public\n   */\n\n  Assertion.addProperty('itself', function () {\n    flag(this, 'itself', true);\n  });\n\n  /**\n   * ### .satisfy(method)\n   *\n   * Asserts that the target passes a given truth test.\n   *\n   *     expect(1).to.satisfy(function(num) { return num > 0; });\n   *\n   * @name satisfy\n   * @param {Function} matcher\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('satisfy', function (matcher, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        matcher(obj)\n      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\n      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\n      , this.negate ? false : true\n      , matcher(obj)\n    );\n  });\n\n  /**\n   * ### .closeTo(expected, delta)\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     expect(1.5).to.be.closeTo(1, 0.5);\n   *\n   * @name closeTo\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('closeTo', function (expected, delta, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        Math.abs(obj - expected) <= delta\n      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\n      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\n    );\n  });\n\n  function isSubsetOf(subset, superset) {\n    return subset.every(function(elem) {\n      return superset.indexOf(elem) !== -1;\n    })\n  }\n\n  /**\n   * ### .members(set)\n   *\n   * Asserts that the target is a superset of `set`,\n   * or that the target and `set` have the same members.\n   *\n   *     expect([1, 2, 3]).to.include.members([3, 2]);\n   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);\n   *\n   *     expect([4, 2]).to.have.members([2, 4]);\n   *     expect([5, 2]).to.not.have.members([5, 2, 1]);\n   *\n   * @name members\n   * @param {Array} set\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('members', function (subset, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n\n    new Assertion(obj).to.be.an('array');\n    new Assertion(subset).to.be.an('array');\n\n    if (flag(this, 'contains')) {\n      return this.assert(\n          isSubsetOf(subset, obj)\n        , 'expected #{this} to be a superset of #{act}'\n        , 'expected #{this} to not be a superset of #{act}'\n        , obj\n        , subset\n      );\n    }\n\n    this.assert(\n        isSubsetOf(obj, subset) && isSubsetOf(subset, obj)\n        , 'expected #{this} to have the same members as #{act}'\n        , 'expected #{this} to not have the same members as #{act}'\n        , obj\n        , subset\n    );\n  });\n};\n\n});\nrequire.register(\"chai/lib/chai/interface/assert.js\", function(exports, require, module){\n/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n\nmodule.exports = function (chai, util) {\n\n  /*!\n   * Chai dependencies.\n   */\n\n  var Assertion = chai.Assertion\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  /**\n   * ### assert(expression, message)\n   *\n   * Write your own test expressions.\n   *\n   *     assert('foo' !== 'bar', 'foo is not bar');\n   *     assert(Array.isArray([]), 'empty arrays are arrays');\n   *\n   * @param {Mixed} expression to test for truthiness\n   * @param {String} message to display on error\n   * @name assert\n   * @api public\n   */\n\n  var assert = chai.assert = function (express, errmsg) {\n    var test = new Assertion(null);\n    test.assert(\n        express\n      , errmsg\n      , '[ negation message unavailable ]'\n    );\n  };\n\n  /**\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure. Node.js `assert` module-compatible.\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @api public\n   */\n\n  assert.fail = function (actual, expected, message, operator) {\n    message = message || 'assert.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, assert.fail);\n  };\n\n  /**\n   * ### .ok(object, [message])\n   *\n   * Asserts that `object` is truthy.\n   *\n   *     assert.ok('everything', 'everything is ok');\n   *     assert.ok(false, 'this will fail');\n   *\n   * @name ok\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @api public\n   */\n\n  assert.ok = function (val, msg) {\n    new Assertion(val, msg).is.ok;\n  };\n\n  /**\n   * ### .notOk(object, [message])\n   *\n   * Asserts that `object` is falsy.\n   *\n   *     assert.notOk('everything', 'this will fail');\n   *     assert.notOk(false, 'this will pass');\n   *\n   * @name notOk\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notOk = function (val, msg) {\n    new Assertion(val, msg).is.not.ok;\n  };\n\n  /**\n   * ### .equal(actual, expected, [message])\n   *\n   * Asserts non-strict equality (`==`) of `actual` and `expected`.\n   *\n   *     assert.equal(3, '3', '== coerces values to strings');\n   *\n   * @name equal\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.equal = function (act, exp, msg) {\n    var test = new Assertion(act, msg);\n\n    test.assert(\n        exp == flag(test, 'object')\n      , 'expected #{this} to equal #{exp}'\n      , 'expected #{this} to not equal #{act}'\n      , exp\n      , act\n    );\n  };\n\n  /**\n   * ### .notEqual(actual, expected, [message])\n   *\n   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n   *\n   *     assert.notEqual(3, 4, 'these numbers are not equal');\n   *\n   * @name notEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notEqual = function (act, exp, msg) {\n    var test = new Assertion(act, msg);\n\n    test.assert(\n        exp != flag(test, 'object')\n      , 'expected #{this} to not equal #{exp}'\n      , 'expected #{this} to equal #{act}'\n      , exp\n      , act\n    );\n  };\n\n  /**\n   * ### .strictEqual(actual, expected, [message])\n   *\n   * Asserts strict equality (`===`) of `actual` and `expected`.\n   *\n   *     assert.strictEqual(true, true, 'these booleans are strictly equal');\n   *\n   * @name strictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.strictEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.equal(exp);\n  };\n\n  /**\n   * ### .notStrictEqual(actual, expected, [message])\n   *\n   * Asserts strict inequality (`!==`) of `actual` and `expected`.\n   *\n   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\n   *\n   * @name notStrictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notStrictEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.not.equal(exp);\n  };\n\n  /**\n   * ### .deepEqual(actual, expected, [message])\n   *\n   * Asserts that `actual` is deeply equal to `expected`.\n   *\n   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\n   *\n   * @name deepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.eql(exp);\n  };\n\n  /**\n   * ### .notDeepEqual(actual, expected, [message])\n   *\n   * Assert that `actual` is not deeply equal to `expected`.\n   *\n   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\n   *\n   * @name notDeepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.not.eql(exp);\n  };\n\n  /**\n   * ### .isTrue(value, [message])\n   *\n   * Asserts that `value` is true.\n   *\n   *     var teaServed = true;\n   *     assert.isTrue(teaServed, 'the tea has been served');\n   *\n   * @name isTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isTrue = function (val, msg) {\n    new Assertion(val, msg).is['true'];\n  };\n\n  /**\n   * ### .isFalse(value, [message])\n   *\n   * Asserts that `value` is false.\n   *\n   *     var teaServed = false;\n   *     assert.isFalse(teaServed, 'no tea yet? hmm...');\n   *\n   * @name isFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isFalse = function (val, msg) {\n    new Assertion(val, msg).is['false'];\n  };\n\n  /**\n   * ### .isNull(value, [message])\n   *\n   * Asserts that `value` is null.\n   *\n   *     assert.isNull(err, 'there was no error');\n   *\n   * @name isNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNull = function (val, msg) {\n    new Assertion(val, msg).to.equal(null);\n  };\n\n  /**\n   * ### .isNotNull(value, [message])\n   *\n   * Asserts that `value` is not null.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotNull(tea, 'great, time for tea!');\n   *\n   * @name isNotNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotNull = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(null);\n  };\n\n  /**\n   * ### .isUndefined(value, [message])\n   *\n   * Asserts that `value` is `undefined`.\n   *\n   *     var tea;\n   *     assert.isUndefined(tea, 'no tea defined');\n   *\n   * @name isUndefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isUndefined = function (val, msg) {\n    new Assertion(val, msg).to.equal(undefined);\n  };\n\n  /**\n   * ### .isDefined(value, [message])\n   *\n   * Asserts that `value` is not `undefined`.\n   *\n   *     var tea = 'cup of chai';\n   *     assert.isDefined(tea, 'tea has been defined');\n   *\n   * @name isDefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isDefined = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(undefined);\n  };\n\n  /**\n   * ### .isFunction(value, [message])\n   *\n   * Asserts that `value` is a function.\n   *\n   *     function serveTea() { return 'cup of tea'; };\n   *     assert.isFunction(serveTea, 'great, we can have tea now');\n   *\n   * @name isFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isFunction = function (val, msg) {\n    new Assertion(val, msg).to.be.a('function');\n  };\n\n  /**\n   * ### .isNotFunction(value, [message])\n   *\n   * Asserts that `value` is _not_ a function.\n   *\n   *     var serveTea = [ 'heat', 'pour', 'sip' ];\n   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\n   *\n   * @name isNotFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotFunction = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('function');\n  };\n\n  /**\n   * ### .isObject(value, [message])\n   *\n   * Asserts that `value` is an object (as revealed by\n   * `Object.prototype.toString`).\n   *\n   *     var selection = { name: 'Chai', serve: 'with spices' };\n   *     assert.isObject(selection, 'tea selection is an object');\n   *\n   * @name isObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isObject = function (val, msg) {\n    new Assertion(val, msg).to.be.a('object');\n  };\n\n  /**\n   * ### .isNotObject(value, [message])\n   *\n   * Asserts that `value` is _not_ an object.\n   *\n   *     var selection = 'chai'\n   *     assert.isObject(selection, 'tea selection is not an object');\n   *     assert.isObject(null, 'null is not an object');\n   *\n   * @name isNotObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotObject = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('object');\n  };\n\n  /**\n   * ### .isArray(value, [message])\n   *\n   * Asserts that `value` is an array.\n   *\n   *     var menu = [ 'green', 'chai', 'oolong' ];\n   *     assert.isArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isArray = function (val, msg) {\n    new Assertion(val, msg).to.be.an('array');\n  };\n\n  /**\n   * ### .isNotArray(value, [message])\n   *\n   * Asserts that `value` is _not_ an array.\n   *\n   *     var menu = 'green|chai|oolong';\n   *     assert.isNotArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isNotArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotArray = function (val, msg) {\n    new Assertion(val, msg).to.not.be.an('array');\n  };\n\n  /**\n   * ### .isString(value, [message])\n   *\n   * Asserts that `value` is a string.\n   *\n   *     var teaOrder = 'chai';\n   *     assert.isString(teaOrder, 'order placed');\n   *\n   * @name isString\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isString = function (val, msg) {\n    new Assertion(val, msg).to.be.a('string');\n  };\n\n  /**\n   * ### .isNotString(value, [message])\n   *\n   * Asserts that `value` is _not_ a string.\n   *\n   *     var teaOrder = 4;\n   *     assert.isNotString(teaOrder, 'order placed');\n   *\n   * @name isNotString\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotString = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('string');\n  };\n\n  /**\n   * ### .isNumber(value, [message])\n   *\n   * Asserts that `value` is a number.\n   *\n   *     var cups = 2;\n   *     assert.isNumber(cups, 'how many cups');\n   *\n   * @name isNumber\n   * @param {Number} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNumber = function (val, msg) {\n    new Assertion(val, msg).to.be.a('number');\n  };\n\n  /**\n   * ### .isNotNumber(value, [message])\n   *\n   * Asserts that `value` is _not_ a number.\n   *\n   *     var cups = '2 cups please';\n   *     assert.isNotNumber(cups, 'how many cups');\n   *\n   * @name isNotNumber\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotNumber = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('number');\n  };\n\n  /**\n   * ### .isBoolean(value, [message])\n   *\n   * Asserts that `value` is a boolean.\n   *\n   *     var teaReady = true\n   *       , teaServed = false;\n   *\n   *     assert.isBoolean(teaReady, 'is the tea ready');\n   *     assert.isBoolean(teaServed, 'has tea been served');\n   *\n   * @name isBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isBoolean = function (val, msg) {\n    new Assertion(val, msg).to.be.a('boolean');\n  };\n\n  /**\n   * ### .isNotBoolean(value, [message])\n   *\n   * Asserts that `value` is _not_ a boolean.\n   *\n   *     var teaReady = 'yep'\n   *       , teaServed = 'nope';\n   *\n   *     assert.isNotBoolean(teaReady, 'is the tea ready');\n   *     assert.isNotBoolean(teaServed, 'has tea been served');\n   *\n   * @name isNotBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotBoolean = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('boolean');\n  };\n\n  /**\n   * ### .typeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n   *     assert.typeOf('tea', 'string', 'we have a string');\n   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n   *     assert.typeOf(null, 'null', 'we have a null');\n   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\n   *\n   * @name typeOf\n   * @param {Mixed} value\n   * @param {String} name\n   * @param {String} message\n   * @api public\n   */\n\n  assert.typeOf = function (val, type, msg) {\n    new Assertion(val, msg).to.be.a(type);\n  };\n\n  /**\n   * ### .notTypeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is _not_ `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\n   *\n   * @name notTypeOf\n   * @param {Mixed} value\n   * @param {String} typeof name\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notTypeOf = function (val, type, msg) {\n    new Assertion(val, msg).to.not.be.a(type);\n  };\n\n  /**\n   * ### .instanceOf(object, constructor, [message])\n   *\n   * Asserts that `value` is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new Tea('chai');\n   *\n   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\n   *\n   * @name instanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @api public\n   */\n\n  assert.instanceOf = function (val, type, msg) {\n    new Assertion(val, msg).to.be.instanceOf(type);\n  };\n\n  /**\n   * ### .notInstanceOf(object, constructor, [message])\n   *\n   * Asserts `value` is not an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new String('chai');\n   *\n   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\n   *\n   * @name notInstanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notInstanceOf = function (val, type, msg) {\n    new Assertion(val, msg).to.not.be.instanceOf(type);\n  };\n\n  /**\n   * ### .include(haystack, needle, [message])\n   *\n   * Asserts that `haystack` includes `needle`. Works\n   * for strings and arrays.\n   *\n   *     assert.include('foobar', 'bar', 'foobar contains string \"bar\"');\n   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');\n   *\n   * @name include\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @api public\n   */\n\n  assert.include = function (exp, inc, msg) {\n    new Assertion(exp, msg).include(inc);\n  };\n\n  /**\n   * ### .notInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` does not include `needle`. Works\n   * for strings and arrays.\n   *i\n   *     assert.notInclude('foobar', 'baz', 'string not include substring');\n   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');\n   *\n   * @name notInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg).not.include(inc);\n  };\n\n  /**\n   * ### .match(value, regexp, [message])\n   *\n   * Asserts that `value` matches the regular expression `regexp`.\n   *\n   *     assert.match('foobar', /^foo/, 'regexp matches');\n   *\n   * @name match\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @api public\n   */\n\n  assert.match = function (exp, re, msg) {\n    new Assertion(exp, msg).to.match(re);\n  };\n\n  /**\n   * ### .notMatch(value, regexp, [message])\n   *\n   * Asserts that `value` does not match the regular expression `regexp`.\n   *\n   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\n   *\n   * @name notMatch\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notMatch = function (exp, re, msg) {\n    new Assertion(exp, msg).to.not.match(re);\n  };\n\n  /**\n   * ### .property(object, property, [message])\n   *\n   * Asserts that `object` has a property named by `property`.\n   *\n   *     assert.property({ tea: { green: 'matcha' }}, 'tea');\n   *\n   * @name property\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.property = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.have.property(prop);\n  };\n\n  /**\n   * ### .notProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`.\n   *\n   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\n   *\n   * @name notProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.not.have.property(prop);\n  };\n\n  /**\n   * ### .deepProperty(object, property, [message])\n   *\n   * Asserts that `object` has a property named by `property`, which can be a\n   * string using dot- and bracket-notation for deep reference.\n   *\n   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');\n   *\n   * @name deepProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.have.deep.property(prop);\n  };\n\n  /**\n   * ### .notDeepProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`, which\n   * can be a string using dot- and bracket-notation for deep reference.\n   *\n   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\n   *\n   * @name notDeepProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.not.have.deep.property(prop);\n  };\n\n  /**\n   * ### .propertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`.\n   *\n   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\n   *\n   * @name propertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.propertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.have.property(prop, val);\n  };\n\n  /**\n   * ### .propertyNotVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property`, but with a value\n   * different from that given by `value`.\n   *\n   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');\n   *\n   * @name propertyNotVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.propertyNotVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.not.have.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`. `property` can use dot- and bracket-notation for deep\n   * reference.\n   *\n   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\n   *\n   * @name deepPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyNotVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property`, but with a value\n   * different from that given by `value`. `property` can use dot- and\n   * bracket-notation for deep reference.\n   *\n   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n   *\n   * @name deepPropertyNotVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepPropertyNotVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.not.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .lengthOf(object, length, [message])\n   *\n   * Asserts that `object` has a `length` property with the expected value.\n   *\n   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\n   *     assert.lengthOf('foobar', 5, 'string has length of 6');\n   *\n   * @name lengthOf\n   * @param {Mixed} object\n   * @param {Number} length\n   * @param {String} message\n   * @api public\n   */\n\n  assert.lengthOf = function (exp, len, msg) {\n    new Assertion(exp, msg).to.have.length(len);\n  };\n\n  /**\n   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])\n   *\n   * Asserts that `function` will throw an error that is an instance of\n   * `constructor`, or alternately that it will throw an error with message\n   * matching `regexp`.\n   *\n   *     assert.throw(fn, 'function throws a reference error');\n   *     assert.throw(fn, /function throws a reference error/);\n   *     assert.throw(fn, ReferenceError);\n   *     assert.throw(fn, ReferenceError, 'function throws a reference error');\n   *     assert.throw(fn, ReferenceError, /function throws a reference error/);\n   *\n   * @name throws\n   * @alias throw\n   * @alias Throw\n   * @param {Function} function\n   * @param {ErrorConstructor} constructor\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @api public\n   */\n\n  assert.Throw = function (fn, errt, errs, msg) {\n    if ('string' === typeof errt || errt instanceof RegExp) {\n      errs = errt;\n      errt = null;\n    }\n\n    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);\n    return flag(assertErr, 'object');\n  };\n\n  /**\n   * ### .doesNotThrow(function, [constructor/regexp], [message])\n   *\n   * Asserts that `function` will _not_ throw an error that is an instance of\n   * `constructor`, or alternately that it will not throw an error with message\n   * matching `regexp`.\n   *\n   *     assert.doesNotThrow(fn, Error, 'function does not throw');\n   *\n   * @name doesNotThrow\n   * @param {Function} function\n   * @param {ErrorConstructor} constructor\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @api public\n   */\n\n  assert.doesNotThrow = function (fn, type, msg) {\n    if ('string' === typeof type) {\n      msg = type;\n      type = null;\n    }\n\n    new Assertion(fn, msg).to.not.Throw(type);\n  };\n\n  /**\n   * ### .operator(val1, operator, val2, [message])\n   *\n   * Compares two values using `operator`.\n   *\n   *     assert.operator(1, '<', 2, 'everything is ok');\n   *     assert.operator(1, '>', 2, 'this will fail');\n   *\n   * @name operator\n   * @param {Mixed} val1\n   * @param {String} operator\n   * @param {Mixed} val2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.operator = function (val, operator, val2, msg) {\n    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {\n      throw new Error('Invalid operator \"' + operator + '\"');\n    }\n    var test = new Assertion(eval(val + operator + val2), msg);\n    test.assert(\n        true === flag(test, 'object')\n      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\n      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\n  };\n\n  /**\n   * ### .closeTo(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name closeTo\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @api public\n   */\n\n  assert.closeTo = function (act, exp, delta, msg) {\n    new Assertion(act, msg).to.be.closeTo(exp, delta);\n  };\n\n  /**\n   * ### .sameMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members.\n   * Order is not taken into account.\n   *\n   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\n   *\n   * @name sameMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @api public\n   */\n\n  assert.sameMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg).to.have.same.members(set2);\n  }\n\n  /**\n   * ### .includeMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset`.\n   * Order is not taken into account.\n   *\n   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');\n   *\n   * @name includeMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @api public\n   */\n\n  assert.includeMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg).to.include.members(subset);\n  }\n\n  /*!\n   * Undocumented / untested\n   */\n\n  assert.ifError = function (val, msg) {\n    new Assertion(val, msg).to.not.be.ok;\n  };\n\n  /*!\n   * Aliases.\n   */\n\n  (function alias(name, as){\n    assert[as] = assert[name];\n    return alias;\n  })\n  ('Throw', 'throw')\n  ('Throw', 'throws');\n};\n\n});\nrequire.register(\"chai/lib/chai/interface/expect.js\", function(exports, require, module){\n/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  chai.expect = function (val, message) {\n    return new chai.Assertion(val, message);\n  };\n};\n\n\n});\nrequire.register(\"chai/lib/chai/interface/should.js\", function(exports, require, module){\n/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  var Assertion = chai.Assertion;\n\n  function loadShould () {\n    // modify Object.prototype to have `should`\n    Object.defineProperty(Object.prototype, 'should',\n      {\n        set: function (value) {\n          // See https://github.com/chaijs/chai/issues/86: this makes\n          // `whatever.should = someValue` actually set `someValue`, which is\n          // especially useful for `global.should = require('chai').should()`.\n          //\n          // Note that we have to use [[DefineProperty]] instead of [[Put]]\n          // since otherwise we would trigger this very setter!\n          Object.defineProperty(this, 'should', {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        }\n      , get: function(){\n          if (this instanceof String || this instanceof Number) {\n            return new Assertion(this.constructor(this));\n          } else if (this instanceof Boolean) {\n            return new Assertion(this == true);\n          }\n          return new Assertion(this);\n        }\n      , configurable: true\n    });\n\n    var should = {};\n\n    should.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.equal(val2);\n    };\n\n    should.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.Throw(errt, errs);\n    };\n\n    should.exist = function (val, msg) {\n      new Assertion(val, msg).to.exist;\n    }\n\n    // negation\n    should.not = {}\n\n    should.not.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.not.equal(val2);\n    };\n\n    should.not.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.not.Throw(errt, errs);\n    };\n\n    should.not.exist = function (val, msg) {\n      new Assertion(val, msg).to.not.exist;\n    }\n\n    should['throw'] = should['Throw'];\n    should.not['throw'] = should.not['Throw'];\n\n    return should;\n  };\n\n  chai.should = loadShould;\n  chai.Should = loadShould;\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/addChainableMethod.js\", function(exports, require, module){\n/*!\n * Chai - addChainingMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar transferFlags = require('./transferFlags');\n\n/*!\n * Module variables\n */\n\n// Check whether `__proto__` is supported\nvar hasProtoSupport = '__proto__' in Object;\n\n// Without `__proto__` support, this module will need to add properties to a function.\n// However, some Function.prototype methods cannot be overwritten,\n// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).\nvar excludeNames = /^(?:length|name|arguments|caller)$/;\n\n// Cache `Function` properties\nvar call  = Function.prototype.call,\n    apply = Function.prototype.apply;\n\n/**\n * ### addChainableMethod (ctx, name, method, chainingBehavior)\n *\n * Adds a method to an object, such that the method can also be chained.\n *\n *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n *\n * The result can then be used as both a method assertion, executing both `method` and\n * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n *\n *     expect(fooStr).to.be.foo('bar');\n *     expect(fooStr).to.be.foo.equal('foo');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for `name`, when called\n * @param {Function} chainingBehavior function to be called every time the property is accessed\n * @name addChainableMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method, chainingBehavior) {\n  if (typeof chainingBehavior !== 'function') {\n    chainingBehavior = function () { };\n  }\n\n  var chainableBehavior = {\n      method: method\n    , chainingBehavior: chainingBehavior\n  };\n\n  // save the methods so we can overwrite them later, if we need to.\n  if (!ctx.__methods) {\n    ctx.__methods = {};\n  }\n  ctx.__methods[name] = chainableBehavior;\n\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        chainableBehavior.chainingBehavior.call(this);\n\n        var assert = function () {\n          var result = chainableBehavior.method.apply(this, arguments);\n          return result === undefined ? this : result;\n        };\n\n        // Use `__proto__` if available\n        if (hasProtoSupport) {\n          // Inherit all properties from the object by replacing the `Function` prototype\n          var prototype = assert.__proto__ = Object.create(this);\n          // Restore the `call` and `apply` methods from `Function`\n          prototype.call = call;\n          prototype.apply = apply;\n        }\n        // Otherwise, redefine all properties (slow!)\n        else {\n          var asserterNames = Object.getOwnPropertyNames(ctx);\n          asserterNames.forEach(function (asserterName) {\n            if (!excludeNames.test(asserterName)) {\n              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n              Object.defineProperty(assert, asserterName, pd);\n            }\n          });\n        }\n\n        transferFlags(this, assert);\n        return assert;\n      }\n    , configurable: true\n  });\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/addMethod.js\", function(exports, require, module){\n/*!\n * Chai - addMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .addMethod (ctx, name, method)\n *\n * Adds a method to the prototype of an object.\n *\n *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(fooStr).to.be.foo('bar');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for name\n * @name addMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method) {\n  ctx[name] = function () {\n    var result = method.apply(this, arguments);\n    return result === undefined ? this : result;\n  };\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/addProperty.js\", function(exports, require, module){\n/*!\n * Chai - addProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### addProperty (ctx, name, getter)\n *\n * Adds a property to the prototype of an object.\n *\n *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.instanceof(Foo);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.foo;\n *\n * @param {Object} ctx object to which the property is added\n * @param {String} name of property to add\n * @param {Function} getter function to be used for name\n * @name addProperty\n * @api public\n */\n\nmodule.exports = function (ctx, name, getter) {\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        var result = getter.call(this);\n        return result === undefined ? this : result;\n      }\n    , configurable: true\n  });\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/flag.js\", function(exports, require, module){\n/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### flag(object ,key, [value])\n *\n * Get or set a flag value on an object. If a\n * value is provided it will be set, else it will\n * return the currently set value or `undefined` if\n * the value is not set.\n *\n *     utils.flag(this, 'foo', 'bar'); // setter\n *     utils.flag(this, 'foo'); // getter, returns `bar`\n *\n * @param {Object} object (constructed Assertion\n * @param {String} key\n * @param {Mixed} value (optional)\n * @name flag\n * @api private\n */\n\nmodule.exports = function (obj, key, value) {\n  var flags = obj.__flags || (obj.__flags = Object.create(null));\n  if (arguments.length === 3) {\n    flags[key] = value;\n  } else {\n    return flags[key];\n  }\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/getActual.js\", function(exports, require, module){\n/*!\n * Chai - getActual utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * # getActual(object, [actual])\n *\n * Returns the `actual` value for an Assertion\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n */\n\nmodule.exports = function (obj, args) {\n  var actual = args[4];\n  return 'undefined' !== typeof actual ? actual : obj._obj;\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/getEnumerableProperties.js\", function(exports, require, module){\n/*!\n * Chai - getEnumerableProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getEnumerableProperties(object)\n *\n * This allows the retrieval of enumerable property names of an object,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @name getEnumerableProperties\n * @api public\n */\n\nmodule.exports = function getEnumerableProperties(object) {\n  var result = [];\n  for (var name in object) {\n    result.push(name);\n  }\n  return result;\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/getMessage.js\", function(exports, require, module){\n/*!\n * Chai - message composition utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar flag = require('./flag')\n  , getActual = require('./getActual')\n  , inspect = require('./inspect')\n  , objDisplay = require('./objDisplay');\n\n/**\n * ### .getMessage(object, message, negateMessage)\n *\n * Construct the error message based on flags\n * and template tags. Template tags will return\n * a stringified inspection of the object referenced.\n *\n * Message template tags:\n * - `#{this}` current asserted object\n * - `#{act}` actual value\n * - `#{exp}` expected value\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @name getMessage\n * @api public\n */\n\nmodule.exports = function (obj, args) {\n  var negate = flag(obj, 'negate')\n    , val = flag(obj, 'object')\n    , expected = args[3]\n    , actual = getActual(obj, args)\n    , msg = negate ? args[2] : args[1]\n    , flagMsg = flag(obj, 'message');\n\n  msg = msg || '';\n  msg = msg\n    .replace(/#{this}/g, objDisplay(val))\n    .replace(/#{act}/g, objDisplay(actual))\n    .replace(/#{exp}/g, objDisplay(expected));\n\n  return flagMsg ? flagMsg + ': ' + msg : msg;\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/getName.js\", function(exports, require, module){\n/*!\n * Chai - getName utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * # getName(func)\n *\n * Gets the name of a function, in a cross-browser way.\n *\n * @param {Function} a function (usually a constructor)\n */\n\nmodule.exports = function (func) {\n  if (func.name) return func.name;\n\n  var match = /^\\s?function ([^(]*)\\(/.exec(func);\n  return match && match[1] ? match[1] : \"\";\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/getPathValue.js\", function(exports, require, module){\n/*!\n * Chai - getPathValue utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * @see https://github.com/logicalparadox/filtr\n * MIT Licensed\n */\n\n/**\n * ### .getPathValue(path, object)\n *\n * This allows the retrieval of values in an\n * object given a string path.\n *\n *     var obj = {\n *         prop1: {\n *             arr: ['a', 'b', 'c']\n *           , str: 'Hello'\n *         }\n *       , prop2: {\n *             arr: [ { nested: 'Universe' } ]\n *           , str: 'Hello again!'\n *         }\n *     }\n *\n * The following would be the results.\n *\n *     getPathValue('prop1.str', obj); // Hello\n *     getPathValue('prop1.att[2]', obj); // b\n *     getPathValue('prop2.arr[0].nested', obj); // Universe\n *\n * @param {String} path\n * @param {Object} object\n * @returns {Object} value or `undefined`\n * @name getPathValue\n * @api public\n */\n\nvar getPathValue = module.exports = function (path, obj) {\n  var parsed = parsePath(path);\n  return _getPathValue(parsed, obj);\n};\n\n/*!\n * ## parsePath(path)\n *\n * Helper function used to parse string object\n * paths. Use in conjunction with `_getPathValue`.\n *\n *      var parsed = parsePath('myobject.property.subprop');\n *\n * ### Paths:\n *\n * * Can be as near infinitely deep and nested\n * * Arrays are also valid using the formal `myobject.document[3].property`.\n *\n * @param {String} path\n * @returns {Object} parsed\n * @api private\n */\n\nfunction parsePath (path) {\n  var str = path.replace(/\\[/g, '.[')\n    , parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n  return parts.map(function (value) {\n    var re = /\\[(\\d+)\\]$/\n      , mArr = re.exec(value)\n    if (mArr) return { i: parseFloat(mArr[1]) };\n    else return { p: value };\n  });\n};\n\n/*!\n * ## _getPathValue(parsed, obj)\n *\n * Helper companion function for `.parsePath` that returns\n * the value located at the parsed address.\n *\n *      var value = getPathValue(parsed, obj);\n *\n * @param {Object} parsed definition from `parsePath`.\n * @param {Object} object to search against\n * @returns {Object|Undefined} value\n * @api private\n */\n\nfunction _getPathValue (parsed, obj) {\n  var tmp = obj\n    , res;\n  for (var i = 0, l = parsed.length; i < l; i++) {\n    var part = parsed[i];\n    if (tmp) {\n      if ('undefined' !== typeof part.p)\n        tmp = tmp[part.p];\n      else if ('undefined' !== typeof part.i)\n        tmp = tmp[part.i];\n      if (i == (l - 1)) res = tmp;\n    } else {\n      res = undefined;\n    }\n  }\n  return res;\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/getProperties.js\", function(exports, require, module){\n/*!\n * Chai - getProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getProperties(object)\n *\n * This allows the retrieval of property names of an object, enumerable or not,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @name getProperties\n * @api public\n */\n\nmodule.exports = function getProperties(object) {\n  var result = Object.getOwnPropertyNames(subject);\n\n  function addProperty(property) {\n    if (result.indexOf(property) === -1) {\n      result.push(property);\n    }\n  }\n\n  var proto = Object.getPrototypeOf(subject);\n  while (proto !== null) {\n    Object.getOwnPropertyNames(proto).forEach(addProperty);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return result;\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/index.js\", function(exports, require, module){\n/*!\n * chai\n * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Main exports\n */\n\nvar exports = module.exports = {};\n\n/*!\n * test utility\n */\n\nexports.test = require('./test');\n\n/*!\n * type utility\n */\n\nexports.type = require('./type');\n\n/*!\n * message utility\n */\n\nexports.getMessage = require('./getMessage');\n\n/*!\n * actual utility\n */\n\nexports.getActual = require('./getActual');\n\n/*!\n * Inspect util\n */\n\nexports.inspect = require('./inspect');\n\n/*!\n * Object Display util\n */\n\nexports.objDisplay = require('./objDisplay');\n\n/*!\n * Flag utility\n */\n\nexports.flag = require('./flag');\n\n/*!\n * Flag transferring utility\n */\n\nexports.transferFlags = require('./transferFlags');\n\n/*!\n * Deep equal utility\n */\n\nexports.eql = require('deep-eql');\n\n/*!\n * Deep path value\n */\n\nexports.getPathValue = require('./getPathValue');\n\n/*!\n * Function name\n */\n\nexports.getName = require('./getName');\n\n/*!\n * add Property\n */\n\nexports.addProperty = require('./addProperty');\n\n/*!\n * add Method\n */\n\nexports.addMethod = require('./addMethod');\n\n/*!\n * overwrite Property\n */\n\nexports.overwriteProperty = require('./overwriteProperty');\n\n/*!\n * overwrite Method\n */\n\nexports.overwriteMethod = require('./overwriteMethod');\n\n/*!\n * Add a chainable method\n */\n\nexports.addChainableMethod = require('./addChainableMethod');\n\n/*!\n * Overwrite chainable method\n */\n\nexports.overwriteChainableMethod = require('./overwriteChainableMethod');\n\n\n});\nrequire.register(\"chai/lib/chai/utils/inspect.js\", function(exports, require, module){\n// This is (almost) directly from Node.js utils\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n\nvar getName = require('./getName');\nvar getProperties = require('./getProperties');\nvar getEnumerableProperties = require('./getEnumerableProperties');\n\nmodule.exports = inspect;\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n *    properties of objects.\n * @param {Number} depth Depth in which to descend in object. Default is 2.\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n *    output. Default is false (no coloring).\n */\nfunction inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: function (str) { return str; }\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\n\n// https://gist.github.com/1044128/\nvar getOuterHTML = function(element) {\n  if ('outerHTML' in element) return element.outerHTML;\n  var ns = \"http://www.w3.org/1999/xhtml\";\n  var container = document.createElementNS(ns, '_');\n  var elemProto = (window.HTMLElement || window.Element).prototype;\n  var xmlSerializer = new XMLSerializer();\n  var html;\n  if (document.xmlVersion) {\n    return xmlSerializer.serializeToString(element);\n  } else {\n    container.appendChild(element.cloneNode(false));\n    html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');\n    container.innerHTML = '';\n    return html;\n  }\n};\n\n// Returns true if object is a DOM element.\nvar isDOMElement = function (object) {\n  if (typeof HTMLElement === 'object') {\n    return object instanceof HTMLElement;\n  } else {\n    return object &&\n      typeof object === 'object' &&\n      object.nodeType === 1 &&\n      typeof object.nodeName === 'string';\n  }\n};\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes);\n    if (typeof ret !== 'string') {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // If it's DOM elem, get outer HTML.\n  if (isDOMElement(value)) {\n    return getOuterHTML(value);\n  }\n\n  // Look up the keys of the object.\n  var visibleKeys = getEnumerableProperties(value);\n  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\n\n  // Some type of object without properties can be shortcutted.\n  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n  // a `stack` plus `description` property; ignore those for consistency.\n  if (keys.length === 0 || (isError(value) && (\n      (keys.length === 1 && keys[0] === 'stack') ||\n      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\n     ))) {\n    if (typeof value === 'function') {\n      var name = getName(value);\n      var nameSuffix = name ? ': ' + name : '';\n      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    var name = getName(value);\n    var nameSuffix = name ? ': ' + name : '';\n    base = ' [Function' + nameSuffix + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    return formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str;\n  if (value.__lookupGetter__) {\n    if (value.__lookupGetter__(key)) {\n      if (value.__lookupSetter__(key)) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (value.__lookupSetter__(key)) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n  }\n  if (visibleKeys.indexOf(key) < 0) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(value[key]) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, value[key], null);\n      } else {\n        str = formatValue(ctx, value[key], recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n}\n\nfunction isRegExp(re) {\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n}\n\nfunction isDate(d) {\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n});\nrequire.register(\"chai/lib/chai/utils/objDisplay.js\", function(exports, require, module){\n/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar inspect = require('./inspect');\n\n/**\n * ### .objDisplay (object)\n *\n * Determines if an object or an array matches\n * criteria to be inspected in-line for error\n * messages or should be truncated.\n *\n * @param {Mixed} javascript object to inspect\n * @name objDisplay\n * @api public\n */\n\nmodule.exports = function (obj) {\n  var str = inspect(obj)\n    , type = Object.prototype.toString.call(obj);\n\n  if (str.length >= 40) {\n    if (type === '[object Function]') {\n      return !obj.name || obj.name === ''\n        ? '[Function]'\n        : '[Function: ' + obj.name + ']';\n    } else if (type === '[object Array]') {\n      return '[ Array(' + obj.length + ') ]';\n    } else if (type === '[object Object]') {\n      var keys = Object.keys(obj)\n        , kstr = keys.length > 2\n          ? keys.splice(0, 2).join(', ') + ', ...'\n          : keys.join(', ');\n      return '{ Object (' + kstr + ') }';\n    } else {\n      return str;\n    }\n  } else {\n    return str;\n  }\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/overwriteMethod.js\", function(exports, require, module){\n/*!\n * Chai - overwriteMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteMethod (ctx, name, fn)\n *\n * Overwites an already existing method and provides\n * access to previous function. Must return function\n * to be used for name.\n *\n *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n *       return function (str) {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.value).to.equal(str);\n *         } else {\n *           _super.apply(this, arguments);\n *         }\n *       }\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.equal('bar');\n *\n * @param {Object} ctx object whose method is to be overwritten\n * @param {String} name of method to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @name overwriteMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method) {\n  var _method = ctx[name]\n    , _super = function () { return this; };\n\n  if (_method && 'function' === typeof _method)\n    _super = _method;\n\n  ctx[name] = function () {\n    var result = method(_super).apply(this, arguments);\n    return result === undefined ? this : result;\n  }\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/overwriteProperty.js\", function(exports, require, module){\n/*!\n * Chai - overwriteProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteProperty (ctx, name, fn)\n *\n * Overwites an already existing property getter and provides\n * access to previous value. Must return function to use as getter.\n *\n *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n *       return function () {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.name).to.equal('bar');\n *         } else {\n *           _super.call(this);\n *         }\n *       }\n *     });\n *\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.ok;\n *\n * @param {Object} ctx object whose property is to be overwritten\n * @param {String} name of property to overwrite\n * @param {Function} getter function that returns a getter function to be used for name\n * @name overwriteProperty\n * @api public\n */\n\nmodule.exports = function (ctx, name, getter) {\n  var _get = Object.getOwnPropertyDescriptor(ctx, name)\n    , _super = function () {};\n\n  if (_get && 'function' === typeof _get.get)\n    _super = _get.get\n\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        var result = getter(_super).call(this);\n        return result === undefined ? this : result;\n      }\n    , configurable: true\n  });\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/overwriteChainableMethod.js\", function(exports, require, module){\n/*!\n * Chai - overwriteChainableMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteChainableMethod (ctx, name, fn)\n *\n * Overwites an already existing chainable method\n * and provides access to the previous function or\n * property.  Must return functions to be used for\n * name.\n *\n *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',\n *       function (_super) {\n *       }\n *     , function (_super) {\n *       }\n *     );\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.have.length(3);\n *     expect(myFoo).to.have.length.above(3);\n *\n * @param {Object} ctx object whose method / property is to be overwritten\n * @param {String} name of method / property to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @param {Function} chainingBehavior function that returns a function to be used for property\n * @name overwriteChainableMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method, chainingBehavior) {\n  var chainableBehavior = ctx.__methods[name];\n\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\n  chainableBehavior.chainingBehavior = function () {\n    var result = chainingBehavior(_chainingBehavior).call(this);\n    return result === undefined ? this : result;\n  };\n\n  var _method = chainableBehavior.method;\n  chainableBehavior.method = function () {\n    var result = method(_method).apply(this, arguments);\n    return result === undefined ? this : result;\n  };\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/test.js\", function(exports, require, module){\n/*!\n * Chai - test utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar flag = require('./flag');\n\n/**\n * # test(object, expression)\n *\n * Test and object for expression.\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n */\n\nmodule.exports = function (obj, args) {\n  var negate = flag(obj, 'negate')\n    , expr = args[0];\n  return negate ? !expr : expr;\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/transferFlags.js\", function(exports, require, module){\n/*!\n * Chai - transferFlags utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### transferFlags(assertion, object, includeAll = true)\n *\n * Transfer all the flags for `assertion` to `object`. If\n * `includeAll` is set to `false`, then the base Chai\n * assertion flags (namely `object`, `ssfi`, and `message`)\n * will not be transferred.\n *\n *\n *     var newAssertion = new Assertion();\n *     utils.transferFlags(assertion, newAssertion);\n *\n *     var anotherAsseriton = new Assertion(myObj);\n *     utils.transferFlags(assertion, anotherAssertion, false);\n *\n * @param {Assertion} assertion the assertion to transfer the flags from\n * @param {Object} object the object to transfer the flags too; usually a new assertion\n * @param {Boolean} includeAll\n * @name getAllFlags\n * @api private\n */\n\nmodule.exports = function (assertion, object, includeAll) {\n  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\n  if (!object.__flags) {\n    object.__flags = Object.create(null);\n  }\n\n  includeAll = arguments.length === 3 ? includeAll : true;\n\n  for (var flag in flags) {\n    if (includeAll ||\n        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {\n      object.__flags[flag] = flags[flag];\n    }\n  }\n};\n\n});\nrequire.register(\"chai/lib/chai/utils/type.js\", function(exports, require, module){\n/*!\n * Chai - type utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Detectable javascript natives\n */\n\nvar natives = {\n    '[object Arguments]': 'arguments'\n  , '[object Array]': 'array'\n  , '[object Date]': 'date'\n  , '[object Function]': 'function'\n  , '[object Number]': 'number'\n  , '[object RegExp]': 'regexp'\n  , '[object String]': 'string'\n};\n\n/**\n * ### type(object)\n *\n * Better implementation of `typeof` detection that can\n * be used cross-browser. Handles the inconsistencies of\n * Array, `null`, and `undefined` detection.\n *\n *     utils.type({}) // 'object'\n *     utils.type(null) // `null'\n *     utils.type(undefined) // `undefined`\n *     utils.type([]) // `array`\n *\n * @param {Mixed} object to detect type of\n * @name type\n * @api private\n */\n\nmodule.exports = function (obj) {\n  var str = Object.prototype.toString.call(obj);\n  if (natives[str]) return natives[str];\n  if (obj === null) return 'null';\n  if (obj === undefined) return 'undefined';\n  if (obj === Object(obj)) return 'object';\n  return typeof obj;\n};\n\n});\n\n\n\n\nrequire.alias(\"chaijs-assertion-error/index.js\", \"chai/deps/assertion-error/index.js\");\nrequire.alias(\"chaijs-assertion-error/index.js\", \"chai/deps/assertion-error/index.js\");\nrequire.alias(\"chaijs-assertion-error/index.js\", \"assertion-error/index.js\");\nrequire.alias(\"chaijs-assertion-error/index.js\", \"chaijs-assertion-error/index.js\");\nrequire.alias(\"chaijs-deep-eql/lib/eql.js\", \"chai/deps/deep-eql/lib/eql.js\");\nrequire.alias(\"chaijs-deep-eql/lib/eql.js\", \"chai/deps/deep-eql/index.js\");\nrequire.alias(\"chaijs-deep-eql/lib/eql.js\", \"deep-eql/index.js\");\nrequire.alias(\"chaijs-type-detect/lib/type.js\", \"chaijs-deep-eql/deps/type-detect/lib/type.js\");\nrequire.alias(\"chaijs-type-detect/lib/type.js\", \"chaijs-deep-eql/deps/type-detect/index.js\");\nrequire.alias(\"chaijs-type-detect/lib/type.js\", \"chaijs-type-detect/index.js\");\nrequire.alias(\"chaijs-deep-eql/lib/eql.js\", \"chaijs-deep-eql/index.js\");\nrequire.alias(\"chai/index.js\", \"chai/index.js\");if (typeof exports == \"object\") {\n  module.exports = require(\"chai\");\n} else if (typeof define == \"function\" && define.amd) {\n  define([], function(){ return require(\"chai\"); });\n} else {\n  this[\"chai\"] = require(\"chai\");\n}})();","\n(function(window, document, Math, undef) {\n\n  var nop = function(){};\n\n  var debug = (function() {\n    if (\"console\" in window) {\n      return function(msg) {\n        window.console.log('Processing.js: ' + msg);\n      };\n    }\n    return nop;\n  }());\n\n  var ajax = function(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n    if (xhr.overrideMimeType) {\n      xhr.overrideMimeType(\"text/plain\");\n    }\n    xhr.setRequestHeader(\"If-Modified-Since\", \"Fri, 01 Jan 1960 00:00:00 GMT\");\n    xhr.send(null);\n    // failed request?\n    if (xhr.status !== 200 && xhr.status !== 0) { throw (\"XMLHttpRequest failed, status code \" + xhr.status); }\n    return xhr.responseText;\n  };\n\n  var isDOMPresent = (\"document\" in this) && !(\"fake\" in this.document);\n\n  // document.head polyfill for the benefit of Firefox 3.6\n  document.head = document.head || document.getElementsByTagName('head')[0];\n\n  // Typed Arrays: fallback to WebGL arrays or Native JS arrays if unavailable\n  function setupTypedArray(name, fallback) {\n    // Check if TypedArray exists, and use if so.\n    if (name in window) {\n      return window[name];\n    }\n\n    // Check if WebGLArray exists\n    if (typeof window[fallback] === \"function\") {\n      return window[fallback];\n    }\n\n    // Use Native JS array\n    return function(obj) {\n      if (obj instanceof Array) {\n        return obj;\n      }\n      if (typeof obj === \"number\") {\n        var arr = [];\n        arr.length = obj;\n        return arr;\n      }\n    };\n  }\n\n  /* IE9+ quirks mode check - ticket #1606 */\n  if (document.documentMode >= 9 && !document.doctype) {\n    throw(\"The doctype directive is missing. The recommended doctype in Internet Explorer is the HTML5 doctype: <!DOCTYPE html>\");\n  }\n\n  var Float32Array = setupTypedArray(\"Float32Array\", \"WebGLFloatArray\"),\n      Int32Array   = setupTypedArray(\"Int32Array\",   \"WebGLIntArray\"),\n      Uint16Array  = setupTypedArray(\"Uint16Array\",  \"WebGLUnsignedShortArray\"),\n      Uint8Array   = setupTypedArray(\"Uint8Array\",   \"WebGLUnsignedByteArray\");\n\n  /* Browsers fixes end */\n\n  /**\n   * NOTE: in releases we replace symbolic PConstants.* names with their values.\n   * Using PConstants.* in code below is fine.  See tools/rewrite-pconstants.js.\n   */\n  var PConstants = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n\n    R: 3,\n    G: 4,\n    B: 5,\n    A: 6,\n\n    U: 7,\n    V: 8,\n\n    NX: 9,\n    NY: 10,\n    NZ: 11,\n\n    EDGE: 12,\n\n    // Stroke\n    SR: 13,\n    SG: 14,\n    SB: 15,\n    SA: 16,\n\n    SW: 17,\n\n    // Transformations (2D and 3D)\n    TX: 18,\n    TY: 19,\n    TZ: 20,\n\n    VX: 21,\n    VY: 22,\n    VZ: 23,\n    VW: 24,\n\n    // Material properties\n    AR: 25,\n    AG: 26,\n    AB: 27,\n\n    DR: 3,\n    DG: 4,\n    DB: 5,\n    DA: 6,\n\n    SPR: 28,\n    SPG: 29,\n    SPB: 30,\n\n    SHINE: 31,\n\n    ER: 32,\n    EG: 33,\n    EB: 34,\n\n    BEEN_LIT: 35,\n\n    VERTEX_FIELD_COUNT: 36,\n\n    // Renderers\n    P2D:    1,\n    JAVA2D: 1,\n    WEBGL:  2,\n    P3D:    2,\n    OPENGL: 2,\n    PDF:    0,\n    DXF:    0,\n\n    // Platform IDs\n    OTHER:   0,\n    WINDOWS: 1,\n    MAXOSX:  2,\n    LINUX:   3,\n\n    EPSILON: 0.0001,\n\n    MAX_FLOAT:  3.4028235e+38,\n    MIN_FLOAT: -3.4028235e+38,\n    MAX_INT:    2147483647,\n    MIN_INT:   -2147483648,\n\n    PI:         Math.PI,\n    TWO_PI:     2 * Math.PI,\n    HALF_PI:    Math.PI / 2,\n    THIRD_PI:   Math.PI / 3,\n    QUARTER_PI: Math.PI / 4,\n\n    DEG_TO_RAD: Math.PI / 180,\n    RAD_TO_DEG: 180 / Math.PI,\n\n    WHITESPACE: \" \\t\\n\\r\\f\\u00A0\",\n\n    // Color modes\n    RGB:   1,\n    ARGB:  2,\n    HSB:   3,\n    ALPHA: 4,\n    CMYK:  5,\n\n    // Image file types\n    TIFF:  0,\n    TARGA: 1,\n    JPEG:  2,\n    GIF:   3,\n\n    // Filter/convert types\n    BLUR:      11,\n    GRAY:      12,\n    INVERT:    13,\n    OPAQUE:    14,\n    POSTERIZE: 15,\n    THRESHOLD: 16,\n    ERODE:     17,\n    DILATE:    18,\n\n    // Blend modes\n    REPLACE:    0,\n    BLEND:      1 << 0,\n    ADD:        1 << 1,\n    SUBTRACT:   1 << 2,\n    LIGHTEST:   1 << 3,\n    DARKEST:    1 << 4,\n    DIFFERENCE: 1 << 5,\n    EXCLUSION:  1 << 6,\n    MULTIPLY:   1 << 7,\n    SCREEN:     1 << 8,\n    OVERLAY:    1 << 9,\n    HARD_LIGHT: 1 << 10,\n    SOFT_LIGHT: 1 << 11,\n    DODGE:      1 << 12,\n    BURN:       1 << 13,\n\n    // Color component bit masks\n    ALPHA_MASK: 0xff000000,\n    RED_MASK:   0x00ff0000,\n    GREEN_MASK: 0x0000ff00,\n    BLUE_MASK:  0x000000ff,\n\n    // Projection matrices\n    CUSTOM:       0,\n    ORTHOGRAPHIC: 2,\n    PERSPECTIVE:  3,\n\n    // Shapes\n    POINT:          2,\n    POINTS:         2,\n    LINE:           4,\n    LINES:          4,\n    TRIANGLE:       8,\n    TRIANGLES:      9,\n    TRIANGLE_STRIP: 10,\n    TRIANGLE_FAN:   11,\n    QUAD:           16,\n    QUADS:          16,\n    QUAD_STRIP:     17,\n    POLYGON:        20,\n    PATH:           21,\n    RECT:           30,\n    ELLIPSE:        31,\n    ARC:            32,\n    SPHERE:         40,\n    BOX:            41,\n\n    GROUP:          0,\n    PRIMITIVE:      1,\n    //PATH:         21, // shared with Shape PATH\n    GEOMETRY:       3,\n\n    // Shape Vertex\n    VERTEX:        0,\n    BEZIER_VERTEX: 1,\n    CURVE_VERTEX:  2,\n    BREAK:         3,\n    CLOSESHAPE:    4,\n\n    // Shape closing modes\n    OPEN:  1,\n    CLOSE: 2,\n\n    // Shape drawing modes\n    CORNER:          0, // Draw mode convention to use (x, y) to (width, height)\n    CORNERS:         1, // Draw mode convention to use (x1, y1) to (x2, y2) coordinates\n    RADIUS:          2, // Draw mode from the center, and using the radius\n    CENTER_RADIUS:   2, // Deprecated! Use RADIUS instead\n    CENTER:          3, // Draw from the center, using second pair of values as the diameter\n    DIAMETER:        3, // Synonym for the CENTER constant. Draw from the center\n    CENTER_DIAMETER: 3, // Deprecated! Use DIAMETER instead\n\n    // Text vertical alignment modes\n    BASELINE: 0,   // Default vertical alignment for text placement\n    TOP:      101, // Align text to the top\n    BOTTOM:   102, // Align text from the bottom, using the baseline\n\n    // UV Texture coordinate modes\n    NORMAL:     1,\n    NORMALIZED: 1,\n    IMAGE:      2,\n\n    // Text placement modes\n    MODEL: 4,\n    SHAPE: 5,\n\n    // Stroke modes\n    SQUARE:  'butt',\n    ROUND:   'round',\n    PROJECT: 'square',\n    MITER:   'miter',\n    BEVEL:   'bevel',\n\n    // Lighting modes\n    AMBIENT:     0,\n    DIRECTIONAL: 1,\n    //POINT:     2, Shared with Shape constant\n    SPOT:        3,\n\n    // Key constants\n\n    // Both key and keyCode will be equal to these values\n    BACKSPACE: 8,\n    TAB:       9,\n    ENTER:     10,\n    RETURN:    13,\n    ESC:       27,\n    DELETE:    127,\n    CODED:     0xffff,\n\n    // p.key will be CODED and p.keyCode will be this value\n    SHIFT:     16,\n    CONTROL:   17,\n    ALT:       18,\n    CAPSLK:    20,\n    PGUP:      33,\n    PGDN:      34,\n    END:       35,\n    HOME:      36,\n    LEFT:      37,\n    UP:        38,\n    RIGHT:     39,\n    DOWN:      40,\n    F1:        112,\n    F2:        113,\n    F3:        114,\n    F4:        115,\n    F5:        116,\n    F6:        117,\n    F7:        118,\n    F8:        119,\n    F9:        120,\n    F10:       121,\n    F11:       122,\n    F12:       123,\n    NUMLK:     144,\n    META:      157,\n    INSERT:    155,\n\n    // Cursor types\n    ARROW:    'default',\n    CROSS:    'crosshair',\n    HAND:     'pointer',\n    MOVE:     'move',\n    TEXT:     'text',\n    WAIT:     'wait',\n    NOCURSOR: \"url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto\",\n\n    // Hints\n    DISABLE_OPENGL_2X_SMOOTH:     1,\n    ENABLE_OPENGL_2X_SMOOTH:     -1,\n    ENABLE_OPENGL_4X_SMOOTH:      2,\n    ENABLE_NATIVE_FONTS:          3,\n    DISABLE_DEPTH_TEST:           4,\n    ENABLE_DEPTH_TEST:           -4,\n    ENABLE_DEPTH_SORT:            5,\n    DISABLE_DEPTH_SORT:          -5,\n    DISABLE_OPENGL_ERROR_REPORT:  6,\n    ENABLE_OPENGL_ERROR_REPORT:  -6,\n    ENABLE_ACCURATE_TEXTURES:     7,\n    DISABLE_ACCURATE_TEXTURES:   -7,\n    HINT_COUNT:                  10,\n\n    // PJS defined constants\n    SINCOS_LENGTH:      720, // every half degree\n    PRECISIONB:         15, // fixed point precision is limited to 15 bits!!\n    PRECISIONF:         1 << 15,\n    PREC_MAXVAL:        (1 << 15) - 1,\n    PREC_ALPHA_SHIFT:   24 - 15,\n    PREC_RED_SHIFT:     16 - 15,\n    NORMAL_MODE_AUTO:   0,\n    NORMAL_MODE_SHAPE:  1,\n    NORMAL_MODE_VERTEX: 2,\n    MAX_LIGHTS:         8\n  };\n\n  /**\n   * Returns Java hashCode() result for the object. If the object has the \"hashCode\" function,\n   * it preforms the call of this function. Otherwise it uses/creates the \"$id\" property,\n   * which is used as the hashCode.\n   *\n   * @param {Object} obj          The object.\n   * @returns {int}               The object's hash code.\n   */\n  function virtHashCode(obj) {\n    if (typeof(obj) === \"string\") {\n      var hash = 0;\n      for (var i = 0; i < obj.length; ++i) {\n        hash = (hash * 31 + obj.charCodeAt(i)) & 0xFFFFFFFF;\n      }\n      return hash;\n    }\n    if (typeof(obj) !== \"object\") {\n      return obj & 0xFFFFFFFF;\n    }\n    if (obj.hashCode instanceof Function) {\n      return obj.hashCode();\n    }\n    if (obj.$id === undef) {\n        obj.$id = ((Math.floor(Math.random() * 0x10000) - 0x8000) << 16) | Math.floor(Math.random() * 0x10000);\n    }\n    return obj.$id;\n  }\n\n  /**\n   * Returns Java equals() result for two objects. If the first object\n   * has the \"equals\" function, it preforms the call of this function.\n   * Otherwise the method uses the JavaScript === operator.\n   *\n   * @param {Object} obj          The first object.\n   * @param {Object} other        The second object.\n   *\n   * @returns {boolean}           true if the objects are equal.\n   */\n  function virtEquals(obj, other) {\n    if (obj === null || other === null) {\n      return (obj === null) && (other === null);\n    }\n    if (typeof (obj) === \"string\") {\n      return obj === other;\n    }\n    if (typeof(obj) !== \"object\") {\n      return obj === other;\n    }\n    if (obj.equals instanceof Function) {\n      return obj.equals(other);\n    }\n    return obj === other;\n  }\n\n  /**\n  * A ObjectIterator is an iterator wrapper for objects. If passed object contains\n  * the iterator method, the object instance will be replaced by the result returned by\n  * this method call. If passed object is an array, the ObjectIterator instance iterates\n  * through its items.\n  *\n  * @param {Object} obj          The object to be iterated.\n  */\n  var ObjectIterator = function(obj) {\n    if (obj.iterator instanceof Function) {\n      return obj.iterator();\n    }\n    if (obj instanceof Array) {\n      // iterate through array items\n      var index = -1;\n      this.hasNext = function() {\n        return ++index < obj.length;\n      };\n      this.next = function() {\n        return obj[index];\n      };\n    } else {\n      throw \"Unable to iterate: \" + obj;\n    }\n  };\n\n  /**\n   * An ArrayList stores a variable number of objects.\n   *\n   * @param {int} initialCapacity optional defines the initial capacity of the list, it's empty by default\n   *\n   * @returns {ArrayList} new ArrayList object\n   */\n  var ArrayList = (function() {\n    function Iterator(array) {\n      var index = 0;\n      this.hasNext = function() {\n        return index < array.length;\n      };\n\n      this.next = function() {\n        return array[index++];\n      };\n\n      this.remove = function() {\n        array.splice(index, 1);\n      };\n    }\n\n    function ArrayList(a) {\n      var array;\n\n      if (a instanceof ArrayList) {\n        array = a.toArray();\n      } else {\n        array = [];\n        if (typeof a === \"number\") {\n          array.length = a > 0 ? a : 0;\n        }\n      }\n\n      /**\n       * @member ArrayList\n       * ArrayList.get() Returns the element at the specified position in this list.\n       *\n       * @param {int} i index of element to return\n       *\n       * @returns {Object} the element at the specified position in this list.\n       */\n      this.get = function(i) {\n        return array[i];\n      };\n      /**\n       * @member ArrayList\n       * ArrayList.contains() Returns true if this list contains the specified element.\n       *\n       * @param {Object} item element whose presence in this List is to be tested.\n       *\n       * @returns {boolean} true if the specified element is present; false otherwise.\n       */\n      this.contains = function(item) {\n        return this.indexOf(item)>-1;\n      };\n      /**\n       * @member ArrayList\n       * ArrayList.indexOf() Returns the position this element takes in the list, or -1 if the element is not found.\n       *\n       * @param {Object} item element whose position in this List is to be tested.\n       *\n       * @returns {int} the list position that the first match for this element holds in the list, or -1 if it is not in the list.\n       */\n      this.indexOf = function(item) {\n        for (var i = 0, len = array.length; i < len; ++i) {\n          if (virtEquals(item, array[i])) {\n            return i;\n          }\n        }\n        return -1;\n      };\n      /**\n       * @member ArrayList\n       * ArrayList.lastIndexOf() Returns the index of the last occurrence of the specified element in this list,\n       * or -1 if this list does not contain the element. More formally, returns the highest index i such that\n       * (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.\n       *\n       * @param {Object} item element to search for.\n       *\n       * @returns {int} the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element.\n       */\n      this.lastIndexOf = function(item) {\n        for (var i = array.length-1; i >= 0; --i) {\n          if (virtEquals(item, array[i])) {\n            return i;\n          }\n        }\n        return -1;\n      };\n      /**\n       * @member ArrayList\n       * ArrayList.add() Adds the specified element to this list.\n       *\n       * @param {int}    index  optional index at which the specified element is to be inserted\n       * @param {Object} object element to be added to the list\n       */\n      this.add = function() {\n        if (arguments.length === 1) {\n          array.push(arguments[0]); // for add(Object)\n        } else if (arguments.length === 2) {\n          var arg0 = arguments[0];\n          if (typeof arg0 === 'number') {\n            if (arg0 >= 0 && arg0 <= array.length) {\n              array.splice(arg0, 0, arguments[1]); // for add(i, Object)\n            } else {\n              throw(arg0 + \" is not a valid index\");\n            }\n          } else {\n            throw(typeof arg0 + \" is not a number\");\n          }\n        } else {\n          throw(\"Please use the proper number of parameters.\");\n        }\n      };\n      /**\n       * @member ArrayList\n       * ArrayList.addAll(collection) appends all of the elements in the specified\n       * Collection to the end of this list, in the order that they are returned by\n       * the specified Collection's Iterator.\n       *\n       * When called as addAll(index, collection) the elements are inserted into\n       * this list at the position indicated by index.\n       *\n       * @param {index} Optional; specifies the position the colletion should be inserted at\n       * @param {collection} Any iterable object (ArrayList, HashMap.keySet(), etc.)\n       * @throws out of bounds error for negative index, or index greater than list size.\n       */\n      this.addAll = function(arg1, arg2) {\n        // addAll(int, Collection)\n        var it;\n        if (typeof arg1 === \"number\") {\n          if (arg1 < 0 || arg1 > array.length) {\n            throw(\"Index out of bounds for addAll: \" + arg1 + \" greater or equal than \" + array.length);\n          }\n          it = new ObjectIterator(arg2);\n          while (it.hasNext()) {\n            array.splice(arg1++, 0, it.next());\n          }\n        }\n        // addAll(Collection)\n        else {\n          it = new ObjectIterator(arg1);\n          while (it.hasNext()) {\n            array.push(it.next());\n          }\n        }\n      };\n      /**\n       * @member ArrayList\n       * ArrayList.set() Replaces the element at the specified position in this list with the specified element.\n       *\n       * @param {int}    index  index of element to replace\n       * @param {Object} object element to be stored at the specified position\n       */\n      this.set = function() {\n        if (arguments.length === 2) {\n          var arg0 = arguments[0];\n          if (typeof arg0 === 'number') {\n            if (arg0 >= 0 && arg0 < array.length) {\n              array.splice(arg0, 1, arguments[1]);\n            } else {\n              throw(arg0 + \" is not a valid index.\");\n            }\n          } else {\n            throw(typeof arg0 + \" is not a number\");\n          }\n        } else {\n          throw(\"Please use the proper number of parameters.\");\n        }\n      };\n\n      /**\n       * @member ArrayList\n       * ArrayList.size() Returns the number of elements in this list.\n       *\n       * @returns {int} the number of elements in this list\n       */\n      this.size = function() {\n        return array.length;\n      };\n\n      /**\n       * @member ArrayList\n       * ArrayList.clear() Removes all of the elements from this list. The list will be empty after this call returns.\n       */\n      this.clear = function() {\n        array.length = 0;\n      };\n\n      /**\n       * @member ArrayList\n       * ArrayList.remove() Removes an element either based on index, if the argument is a number, or\n       * by equality check, if the argument is an object.\n       *\n       * @param {int|Object} item either the index of the element to be removed, or the element itself.\n       *\n       * @returns {Object|boolean} If removal is by index, the element that was removed, or null if nothing was removed. If removal is by object, true if removal occurred, otherwise false.\n       */\n      this.remove = function(item) {\n        if (typeof item === 'number') {\n          return array.splice(item, 1)[0];\n        }\n        item = this.indexOf(item);\n        if (item > -1) {\n          array.splice(item, 1);\n          return true;\n        }\n        return false;\n      };\n\n       /**\n       * @member ArrayList\n       * ArrayList.removeAll Removes from this List all of the elements from\n       * the current ArrayList which are present in the passed in paramater ArrayList 'c'.\n       * Shifts any succeeding elements to the left (reduces their index).\n       *\n       * @param {ArrayList} the ArrayList to compare to the current ArrayList\n       *\n       * @returns {boolean} true if the ArrayList had an element removed; false otherwise\n       */\n      this.removeAll = function(c) {\n        var i, x, item,\n            newList = new ArrayList();\n        newList.addAll(this);\n        this.clear();\n        // For every item that exists in the original ArrayList and not in the c ArrayList\n        // copy it into the empty 'this' ArrayList to create the new 'this' Array.\n        for (i = 0, x = 0; i < newList.size(); i++) {\n          item = newList.get(i);\n          if (!c.contains(item)) {\n            this.add(x++, item);\n          }\n        }\n        if (this.size() < newList.size()) {\n          return true;\n        }\n        return false;\n      };\n\n      /**\n       * @member ArrayList\n       * ArrayList.isEmpty() Tests if this list has no elements.\n       *\n       * @returns {boolean} true if this list has no elements; false otherwise\n       */\n      this.isEmpty = function() {\n         return !array.length;\n      };\n\n      /**\n       * @member ArrayList\n       * ArrayList.clone() Returns a shallow copy of this ArrayList instance. (The elements themselves are not copied.)\n       *\n       * @returns {ArrayList} a clone of this ArrayList instance\n       */\n      this.clone = function() {\n        return new ArrayList(this);\n      };\n\n      /**\n       * @member ArrayList\n       * ArrayList.toArray() Returns an array containing all of the elements in this list in the correct order.\n       *\n       * @returns {Object[]} Returns an array containing all of the elements in this list in the correct order\n       */\n      this.toArray = function() {\n        return array.slice(0);\n      };\n\n      this.iterator = function() {\n        return new Iterator(array);\n      };\n    }\n\n    return ArrayList;\n  }());\n\n  /**\n  * A HashMap stores a collection of objects, each referenced by a key. This is similar to an Array, only\n  * instead of accessing elements with a numeric index, a String  is used. (If you are familiar with\n  * associative arrays from other languages, this is the same idea.)\n  *\n  * @param {int} initialCapacity          defines the initial capacity of the map, it's 16 by default\n  * @param {float} loadFactor             the load factor for the map, the default is 0.75\n  * @param {Map} m                        gives the new HashMap the same mappings as this Map\n  */\n  var HashMap = (function() {\n    /**\n    * @member HashMap\n    * A HashMap stores a collection of objects, each referenced by a key. This is similar to an Array, only\n    * instead of accessing elements with a numeric index, a String  is used. (If you are familiar with\n    * associative arrays from other languages, this is the same idea.)\n    *\n    * @param {int} initialCapacity          defines the initial capacity of the map, it's 16 by default\n    * @param {float} loadFactor             the load factor for the map, the default is 0.75\n    * @param {Map} m                        gives the new HashMap the same mappings as this Map\n    */\n    function HashMap() {\n      if (arguments.length === 1 && arguments[0] instanceof HashMap) {\n        return arguments[0].clone();\n      }\n\n      var initialCapacity = arguments.length > 0 ? arguments[0] : 16;\n      var loadFactor = arguments.length > 1 ? arguments[1] : 0.75;\n      var buckets = [];\n      buckets.length = initialCapacity;\n      var count = 0;\n      var hashMap = this;\n\n      function getBucketIndex(key) {\n        var index = virtHashCode(key) % buckets.length;\n        return index < 0 ? buckets.length + index : index;\n      }\n      function ensureLoad() {\n        if (count <= loadFactor * buckets.length) {\n          return;\n        }\n        var allEntries = [];\n        for (var i = 0; i < buckets.length; ++i) {\n          if (buckets[i] !== undef) {\n            allEntries = allEntries.concat(buckets[i]);\n          }\n        }\n        var newBucketsLength = buckets.length * 2;\n        buckets = [];\n        buckets.length = newBucketsLength;\n        for (var j = 0; j < allEntries.length; ++j) {\n          var index = getBucketIndex(allEntries[j].key);\n          var bucket = buckets[index];\n          if (bucket === undef) {\n            buckets[index] = bucket = [];\n          }\n          bucket.push(allEntries[j]);\n        }\n      }\n\n      function Iterator(conversion, removeItem) {\n        var bucketIndex = 0;\n        var itemIndex = -1;\n        var endOfBuckets = false;\n        var currentItem;\n\n        function findNext() {\n          while (!endOfBuckets) {\n            ++itemIndex;\n            if (bucketIndex >= buckets.length) {\n              endOfBuckets = true;\n            } else if (buckets[bucketIndex] === undef || itemIndex >= buckets[bucketIndex].length) {\n              itemIndex = -1;\n              ++bucketIndex;\n            } else {\n              return;\n            }\n          }\n        }\n\n        /*\n        * @member Iterator\n        * Checks if the Iterator has more items\n        */\n        this.hasNext = function() {\n          return !endOfBuckets;\n        };\n\n        /*\n        * @member Iterator\n        * Return the next Item\n        */\n        this.next = function() {\n          currentItem = conversion(buckets[bucketIndex][itemIndex]);\n          findNext();\n          return currentItem;\n        };\n\n        /*\n        * @member Iterator\n        * Remove the current item\n        */\n        this.remove = function() {\n          if (currentItem !== undef) {\n            removeItem(currentItem);\n            --itemIndex;\n            findNext();\n          }\n        };\n\n        findNext();\n      }\n\n      function Set(conversion, isIn, removeItem) {\n        this.clear = function() {\n          hashMap.clear();\n        };\n\n        this.contains = function(o) {\n          return isIn(o);\n        };\n\n        this.containsAll = function(o) {\n          var it = o.iterator();\n          while (it.hasNext()) {\n            if (!this.contains(it.next())) {\n              return false;\n            }\n          }\n          return true;\n        };\n\n        this.isEmpty = function() {\n          return hashMap.isEmpty();\n        };\n\n        this.iterator = function() {\n          return new Iterator(conversion, removeItem);\n        };\n\n        this.remove = function(o) {\n          if (this.contains(o)) {\n            removeItem(o);\n            return true;\n          }\n          return false;\n        };\n\n        this.removeAll = function(c) {\n          var it = c.iterator();\n          var changed = false;\n          while (it.hasNext()) {\n            var item = it.next();\n            if (this.contains(item)) {\n              removeItem(item);\n              changed = true;\n            }\n          }\n          return true;\n        };\n\n        this.retainAll = function(c) {\n          var it = this.iterator();\n          var toRemove = [];\n          while (it.hasNext()) {\n            var entry = it.next();\n            if (!c.contains(entry)) {\n              toRemove.push(entry);\n            }\n          }\n          for (var i = 0; i < toRemove.length; ++i) {\n            removeItem(toRemove[i]);\n          }\n          return toRemove.length > 0;\n        };\n\n        this.size = function() {\n          return hashMap.size();\n        };\n\n        this.toArray = function() {\n          var result = [];\n          var it = this.iterator();\n          while (it.hasNext()) {\n            result.push(it.next());\n          }\n          return result;\n        };\n      }\n\n      function Entry(pair) {\n        this._isIn = function(map) {\n          return map === hashMap && (pair.removed === undef);\n        };\n\n        this.equals = function(o) {\n          return virtEquals(pair.key, o.getKey());\n        };\n\n        this.getKey = function() {\n          return pair.key;\n        };\n\n        this.getValue = function() {\n          return pair.value;\n        };\n\n        this.hashCode = function(o) {\n          return virtHashCode(pair.key);\n        };\n\n        this.setValue = function(value) {\n          var old = pair.value;\n          pair.value = value;\n          return old;\n        };\n      }\n\n      this.clear = function() {\n        count = 0;\n        buckets = [];\n        buckets.length = initialCapacity;\n      };\n\n      this.clone = function() {\n        var map = new HashMap();\n        map.putAll(this);\n        return map;\n      };\n\n      this.containsKey = function(key) {\n        var index = getBucketIndex(key);\n        var bucket = buckets[index];\n        if (bucket === undef) {\n          return false;\n        }\n        for (var i = 0; i < bucket.length; ++i) {\n          if (virtEquals(bucket[i].key, key)) {\n            return true;\n          }\n        }\n        return false;\n      };\n\n      this.containsValue = function(value) {\n        for (var i = 0; i < buckets.length; ++i) {\n          var bucket = buckets[i];\n          if (bucket === undef) {\n            continue;\n          }\n          for (var j = 0; j < bucket.length; ++j) {\n            if (virtEquals(bucket[j].value, value)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      };\n\n      this.entrySet = function() {\n        return new Set(\n\n        function(pair) {\n          return new Entry(pair);\n        },\n\n        function(pair) {\n          return (pair instanceof Entry) && pair._isIn(hashMap);\n        },\n\n        function(pair) {\n          return hashMap.remove(pair.getKey());\n        });\n      };\n\n      this.get = function(key) {\n        var index = getBucketIndex(key);\n        var bucket = buckets[index];\n        if (bucket === undef) {\n          return null;\n        }\n        for (var i = 0; i < bucket.length; ++i) {\n          if (virtEquals(bucket[i].key, key)) {\n            return bucket[i].value;\n          }\n        }\n        return null;\n      };\n\n      this.isEmpty = function() {\n        return count === 0;\n      };\n\n      this.keySet = function() {\n        return new Set(\n          // get key from pair\n          function(pair) {\n            return pair.key;\n          },\n          // is-in test\n          function(key) {\n            return hashMap.containsKey(key);\n          },\n          // remove from hashmap by key\n          function(key) {\n            return hashMap.remove(key);\n          }\n        );\n      };\n\n      this.values = function() {\n        return new Set(\n          // get value from pair\n          function(pair) {\n            return pair.value;\n          },\n          // is-in test\n          function(value) {\n            return hashMap.containsValue(value);\n          },\n          // remove from hashmap by value\n          function(value) {\n            return hashMap.removeByValue(value);\n          }\n        );\n      };\n\n      this.put = function(key, value) {\n        var index = getBucketIndex(key);\n        var bucket = buckets[index];\n        if (bucket === undef) {\n          ++count;\n          buckets[index] = [{\n            key: key,\n            value: value\n          }];\n          ensureLoad();\n          return null;\n        }\n        for (var i = 0; i < bucket.length; ++i) {\n          if (virtEquals(bucket[i].key, key)) {\n            var previous = bucket[i].value;\n            bucket[i].value = value;\n            return previous;\n          }\n        }\n        ++count;\n        bucket.push({\n          key: key,\n          value: value\n        });\n        ensureLoad();\n        return null;\n      };\n\n      this.putAll = function(m) {\n        var it = m.entrySet().iterator();\n        while (it.hasNext()) {\n          var entry = it.next();\n          this.put(entry.getKey(), entry.getValue());\n        }\n      };\n\n      this.remove = function(key) {\n        var index = getBucketIndex(key);\n        var bucket = buckets[index];\n        if (bucket === undef) {\n          return null;\n        }\n        for (var i = 0; i < bucket.length; ++i) {\n          if (virtEquals(bucket[i].key, key)) {\n            --count;\n            var previous = bucket[i].value;\n            bucket[i].removed = true;\n            if (bucket.length > 1) {\n              bucket.splice(i, 1);\n            } else {\n              buckets[index] = undef;\n            }\n            return previous;\n          }\n        }\n        return null;\n      };\n\n      this.removeByValue = function(value) {\n        var bucket, i, ilen, pair;\n        for (bucket in buckets) {\n          if (buckets.hasOwnProperty(bucket)) {\n            for (i = 0, ilen = buckets[bucket].length; i < ilen; i++) {\n              pair = buckets[bucket][i];\n              // removal on values is based on identity, not equality\n              if (pair.value === value) {\n                buckets[bucket].splice(i, 1);\n                return true;\n              }\n            }\n          }\n        }\n        return false;\n      };\n\n      this.size = function() {\n        return count;\n      };\n    }\n\n    return HashMap;\n  }());\n\n  var PVector = (function() {\n    function PVector(x, y, z) {\n      this.x = x || 0;\n      this.y = y || 0;\n      this.z = z || 0;\n    }\n\n    PVector.dist = function(v1, v2) {\n      return v1.dist(v2);\n    };\n\n    PVector.dot = function(v1, v2) {\n      return v1.dot(v2);\n    };\n\n    PVector.cross = function(v1, v2) {\n      return v1.cross(v2);\n    };\n\n    PVector.angleBetween = function(v1, v2) {\n      return Math.acos(v1.dot(v2) / (v1.mag() * v2.mag()));\n    };\n\n    // Common vector operations for PVector\n    PVector.prototype = {\n      set: function(v, y, z) {\n        if (arguments.length === 1) {\n          this.set(v.x || v[0] || 0,\n                   v.y || v[1] || 0,\n                   v.z || v[2] || 0);\n        } else {\n          this.x = v;\n          this.y = y;\n          this.z = z;\n        }\n      },\n      get: function() {\n        return new PVector(this.x, this.y, this.z);\n      },\n      mag: function() {\n        var x = this.x,\n            y = this.y,\n            z = this.z;\n        return Math.sqrt(x * x + y * y + z * z);\n      },\n      add: function(v, y, z) {\n        if (arguments.length === 1) {\n          this.x += v.x;\n          this.y += v.y;\n          this.z += v.z;\n        } else {\n          this.x += v;\n          this.y += y;\n          this.z += z;\n        }\n      },\n      sub: function(v, y, z) {\n        if (arguments.length === 1) {\n          this.x -= v.x;\n          this.y -= v.y;\n          this.z -= v.z;\n        } else {\n          this.x -= v;\n          this.y -= y;\n          this.z -= z;\n        }\n      },\n      mult: function(v) {\n        if (typeof v === 'number') {\n          this.x *= v;\n          this.y *= v;\n          this.z *= v;\n        } else {\n          this.x *= v.x;\n          this.y *= v.y;\n          this.z *= v.z;\n        }\n      },\n      div: function(v) {\n        if (typeof v === 'number') {\n          this.x /= v;\n          this.y /= v;\n          this.z /= v;\n        } else {\n          this.x /= v.x;\n          this.y /= v.y;\n          this.z /= v.z;\n        }\n      },\n      dist: function(v) {\n        var dx = this.x - v.x,\n            dy = this.y - v.y,\n            dz = this.z - v.z;\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n      },\n      dot: function(v, y, z) {\n        if (arguments.length === 1) {\n          return (this.x * v.x + this.y * v.y + this.z * v.z);\n        }\n        return (this.x * v + this.y * y + this.z * z);\n      },\n      cross: function(v) {\n        var x = this.x,\n            y = this.y,\n            z = this.z;\n        return new PVector(y * v.z - v.y * z,\n                           z * v.x - v.z * x,\n                           x * v.y - v.x * y);\n      },\n      normalize: function() {\n        var m = this.mag();\n        if (m > 0) {\n          this.div(m);\n        }\n      },\n      limit: function(high) {\n        if (this.mag() > high) {\n          this.normalize();\n          this.mult(high);\n        }\n      },\n      heading2D: function() {\n        return (-Math.atan2(-this.y, this.x));\n      },\n      toString: function() {\n        return \"[\" + this.x + \", \" + this.y + \", \" + this.z + \"]\";\n      },\n      array: function() {\n        return [this.x, this.y, this.z];\n      }\n    };\n\n    function createPVectorMethod(method) {\n      return function(v1, v2) {\n        var v = v1.get();\n        v[method](v2);\n        return v;\n      };\n    }\n\n    for (var method in PVector.prototype) {\n      if (PVector.prototype.hasOwnProperty(method) && !PVector.hasOwnProperty(method)) {\n        PVector[method] = createPVectorMethod(method);\n      }\n    }\n\n    return PVector;\n  }());\n\n  // Building defaultScope. Changing of the prototype protects\n  // internal Processing code from the changes in defaultScope\n  function DefaultScope() {}\n  DefaultScope.prototype = PConstants;\n\n  var defaultScope = new DefaultScope();\n  defaultScope.ArrayList   = ArrayList;\n  defaultScope.HashMap     = HashMap;\n  defaultScope.PVector     = PVector;\n  defaultScope.ObjectIterator = ObjectIterator;\n  defaultScope.PConstants  = PConstants;\n  //defaultScope.PImage    = PImage;     // TODO\n  //defaultScope.PShape    = PShape;     // TODO\n  //defaultScope.PShapeSVG = PShapeSVG;  // TODO\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Class inheritance helper methods\n  ////////////////////////////////////////////////////////////////////////////\n\n  defaultScope.defineProperty = function(obj, name, desc) {\n    if(\"defineProperty\" in Object) {\n      Object.defineProperty(obj, name, desc);\n    } else {\n      if (desc.hasOwnProperty(\"get\")) {\n        obj.__defineGetter__(name, desc.get);\n      }\n      if (desc.hasOwnProperty(\"set\")) {\n        obj.__defineSetter__(name, desc.set);\n      }\n    }\n  };\n\n  function overloadBaseClassFunction(object, name, basefn) {\n    if (!object.hasOwnProperty(name) || typeof object[name] !== 'function') {\n      // object method is not a function or just inherited from Object.prototype\n      object[name] = basefn;\n      return;\n    }\n    var fn = object[name];\n    if (\"$overloads\" in fn) {\n      // the object method already overloaded (see defaultScope.addMethod)\n      // let's just change a fallback method\n      fn.$defaultOverload = basefn;\n      return;\n    }\n    if (!(\"$overloads\" in basefn) && fn.length === basefn.length) {\n      // special case when we just overriding the method\n      return;\n    }\n    var overloads, defaultOverload;\n    if (\"$overloads\" in basefn) {\n      // let's inherit base class overloads to speed up things\n      overloads = basefn.$overloads.slice(0);\n      overloads[fn.length] = fn;\n      defaultOverload = basefn.$defaultOverload;\n    } else {\n      overloads = [];\n      overloads[basefn.length] = basefn;\n      overloads[fn.length] = fn;\n      defaultOverload = fn;\n    }\n    var hubfn = function() {\n      var fn = hubfn.$overloads[arguments.length] ||\n               (\"$methodArgsIndex\" in hubfn && arguments.length > hubfn.$methodArgsIndex ?\n               hubfn.$overloads[hubfn.$methodArgsIndex] : null) ||\n               hubfn.$defaultOverload;\n      return fn.apply(this, arguments);\n    };\n    hubfn.$overloads = overloads;\n    if (\"$methodArgsIndex\" in basefn) {\n      hubfn.$methodArgsIndex = basefn.$methodArgsIndex;\n    }\n    hubfn.$defaultOverload = defaultOverload;\n    hubfn.name = name;\n    object[name] = hubfn;\n  }\n\n  function extendClass(subClass, baseClass) {\n    function extendGetterSetter(propertyName) {\n      defaultScope.defineProperty(subClass, propertyName, {\n        get: function() {\n          return baseClass[propertyName];\n        },\n        set: function(v) {\n          baseClass[propertyName]=v;\n        },\n        enumerable: true\n      });\n    }\n\n    var properties = [];\n    for (var propertyName in baseClass) {\n      if (typeof baseClass[propertyName] === 'function') {\n        overloadBaseClassFunction(subClass, propertyName, baseClass[propertyName]);\n      } else if(propertyName.charAt(0) !== \"$\" && !(propertyName in subClass)) {\n        // Delaying the properties extension due to the IE9 bug (see #918).\n        properties.push(propertyName);\n      }\n    }\n    while (properties.length > 0) {\n      extendGetterSetter(properties.shift());\n    }\n\n    subClass.$super = baseClass;\n  }\n\n  defaultScope.extendClassChain = function(base) {\n    var path = [base];\n    for (var self = base.$upcast; self; self = self.$upcast) {\n      extendClass(self, base);\n      path.push(self);\n      base = self;\n    }\n    while (path.length > 0) {\n      path.pop().$self=base;\n    }\n  };\n\n  defaultScope.extendStaticMembers = function(derived, base) {\n    extendClass(derived, base);\n  };\n\n  defaultScope.extendInterfaceMembers = function(derived, base) {\n    extendClass(derived, base);\n  };\n\n  defaultScope.addMethod = function(object, name, fn, hasMethodArgs) {\n    var existingfn = object[name];\n    if (existingfn || hasMethodArgs) {\n      var args = fn.length;\n      // builds the overload methods table\n      if (\"$overloads\" in existingfn) {\n        existingfn.$overloads[args] = fn;\n      } else {\n        var hubfn = function() {\n          var fn = hubfn.$overloads[arguments.length] ||\n                   (\"$methodArgsIndex\" in hubfn && arguments.length > hubfn.$methodArgsIndex ?\n                   hubfn.$overloads[hubfn.$methodArgsIndex] : null) ||\n                   hubfn.$defaultOverload;\n          return fn.apply(this, arguments);\n        };\n        var overloads = [];\n        if (existingfn) {\n          overloads[existingfn.length] = existingfn;\n        }\n        overloads[args] = fn;\n        hubfn.$overloads = overloads;\n        hubfn.$defaultOverload = existingfn || fn;\n        if (hasMethodArgs) {\n          hubfn.$methodArgsIndex = args;\n        }\n        hubfn.name = name;\n        object[name] = hubfn;\n      }\n    } else {\n      object[name] = fn;\n    }\n  };\n\n  function isNumericalJavaType(type) {\n    if (typeof type !== \"string\") {\n      return false;\n    }\n    return [\"byte\", \"int\", \"char\", \"color\", \"float\", \"long\", \"double\"].indexOf(type) !== -1;\n  }\n\n  defaultScope.createJavaArray = function(type, bounds) {\n    var result = null,\n        defaultValue = null;\n    if (typeof type === \"string\") {\n      if (type === \"boolean\") {\n        defaultValue = false;\n      } else if (isNumericalJavaType(type)) {\n        defaultValue = 0;\n      }\n    }\n    if (typeof bounds[0] === 'number') {\n      var itemsCount = 0 | bounds[0];\n      if (bounds.length <= 1) {\n        result = [];\n        result.length = itemsCount;\n        for (var i = 0; i < itemsCount; ++i) {\n          result[i] = defaultValue;\n        }\n      } else {\n        result = [];\n        var newBounds = bounds.slice(1);\n        for (var j = 0; j < itemsCount; ++j) {\n          result.push(defaultScope.createJavaArray(type, newBounds));\n        }\n      }\n    }\n    return result;\n  };\n\n  var colors = {\n    aliceblue:            \"#f0f8ff\",\n    antiquewhite:         \"#faebd7\",\n    aqua:                 \"#00ffff\",\n    aquamarine:           \"#7fffd4\",\n    azure:                \"#f0ffff\",\n    beige:                \"#f5f5dc\",\n    bisque:               \"#ffe4c4\",\n    black:                \"#000000\",\n    blanchedalmond:       \"#ffebcd\",\n    blue:                 \"#0000ff\",\n    blueviolet:           \"#8a2be2\",\n    brown:                \"#a52a2a\",\n    burlywood:            \"#deb887\",\n    cadetblue:            \"#5f9ea0\",\n    chartreuse:           \"#7fff00\",\n    chocolate:            \"#d2691e\",\n    coral:                \"#ff7f50\",\n    cornflowerblue:       \"#6495ed\",\n    cornsilk:             \"#fff8dc\",\n    crimson:              \"#dc143c\",\n    cyan:                 \"#00ffff\",\n    darkblue:             \"#00008b\",\n    darkcyan:             \"#008b8b\",\n    darkgoldenrod:        \"#b8860b\",\n    darkgray:             \"#a9a9a9\",\n    darkgreen:            \"#006400\",\n    darkkhaki:            \"#bdb76b\",\n    darkmagenta:          \"#8b008b\",\n    darkolivegreen:       \"#556b2f\",\n    darkorange:           \"#ff8c00\",\n    darkorchid:           \"#9932cc\",\n    darkred:              \"#8b0000\",\n    darksalmon:           \"#e9967a\",\n    darkseagreen:         \"#8fbc8f\",\n    darkslateblue:        \"#483d8b\",\n    darkslategray:        \"#2f4f4f\",\n    darkturquoise:        \"#00ced1\",\n    darkviolet:           \"#9400d3\",\n    deeppink:             \"#ff1493\",\n    deepskyblue:          \"#00bfff\",\n    dimgray:              \"#696969\",\n    dodgerblue:           \"#1e90ff\",\n    firebrick:            \"#b22222\",\n    floralwhite:          \"#fffaf0\",\n    forestgreen:          \"#228b22\",\n    fuchsia:              \"#ff00ff\",\n    gainsboro:            \"#dcdcdc\",\n    ghostwhite:           \"#f8f8ff\",\n    gold:                 \"#ffd700\",\n    goldenrod:            \"#daa520\",\n    gray:                 \"#808080\",\n    green:                \"#008000\",\n    greenyellow:          \"#adff2f\",\n    honeydew:             \"#f0fff0\",\n    hotpink:              \"#ff69b4\",\n    indianred:            \"#cd5c5c\",\n    indigo:               \"#4b0082\",\n    ivory:                \"#fffff0\",\n    khaki:                \"#f0e68c\",\n    lavender:             \"#e6e6fa\",\n    lavenderblush:        \"#fff0f5\",\n    lawngreen:            \"#7cfc00\",\n    lemonchiffon:         \"#fffacd\",\n    lightblue:            \"#add8e6\",\n    lightcoral:           \"#f08080\",\n    lightcyan:            \"#e0ffff\",\n    lightgoldenrodyellow: \"#fafad2\",\n    lightgrey:            \"#d3d3d3\",\n    lightgreen:           \"#90ee90\",\n    lightpink:            \"#ffb6c1\",\n    lightsalmon:          \"#ffa07a\",\n    lightseagreen:        \"#20b2aa\",\n    lightskyblue:         \"#87cefa\",\n    lightslategray:       \"#778899\",\n    lightsteelblue:       \"#b0c4de\",\n    lightyellow:          \"#ffffe0\",\n    lime:                 \"#00ff00\",\n    limegreen:            \"#32cd32\",\n    linen:                \"#faf0e6\",\n    magenta:              \"#ff00ff\",\n    maroon:               \"#800000\",\n    mediumaquamarine:     \"#66cdaa\",\n    mediumblue:           \"#0000cd\",\n    mediumorchid:         \"#ba55d3\",\n    mediumpurple:         \"#9370d8\",\n    mediumseagreen:       \"#3cb371\",\n    mediumslateblue:      \"#7b68ee\",\n    mediumspringgreen:    \"#00fa9a\",\n    mediumturquoise:      \"#48d1cc\",\n    mediumvioletred:      \"#c71585\",\n    midnightblue:         \"#191970\",\n    mintcream:            \"#f5fffa\",\n    mistyrose:            \"#ffe4e1\",\n    moccasin:             \"#ffe4b5\",\n    navajowhite:          \"#ffdead\",\n    navy:                 \"#000080\",\n    oldlace:              \"#fdf5e6\",\n    olive:                \"#808000\",\n    olivedrab:            \"#6b8e23\",\n    orange:               \"#ffa500\",\n    orangered:            \"#ff4500\",\n    orchid:               \"#da70d6\",\n    palegoldenrod:        \"#eee8aa\",\n    palegreen:            \"#98fb98\",\n    paleturquoise:        \"#afeeee\",\n    palevioletred:        \"#d87093\",\n    papayawhip:           \"#ffefd5\",\n    peachpuff:            \"#ffdab9\",\n    peru:                 \"#cd853f\",\n    pink:                 \"#ffc0cb\",\n    plum:                 \"#dda0dd\",\n    powderblue:           \"#b0e0e6\",\n    purple:               \"#800080\",\n    red:                  \"#ff0000\",\n    rosybrown:            \"#bc8f8f\",\n    royalblue:            \"#4169e1\",\n    saddlebrown:          \"#8b4513\",\n    salmon:               \"#fa8072\",\n    sandybrown:           \"#f4a460\",\n    seagreen:             \"#2e8b57\",\n    seashell:             \"#fff5ee\",\n    sienna:               \"#a0522d\",\n    silver:               \"#c0c0c0\",\n    skyblue:              \"#87ceeb\",\n    slateblue:            \"#6a5acd\",\n    slategray:            \"#708090\",\n    snow:                 \"#fffafa\",\n    springgreen:          \"#00ff7f\",\n    steelblue:            \"#4682b4\",\n    tan:                  \"#d2b48c\",\n    teal:                 \"#008080\",\n    thistle:              \"#d8bfd8\",\n    tomato:               \"#ff6347\",\n    turquoise:            \"#40e0d0\",\n    violet:               \"#ee82ee\",\n    wheat:                \"#f5deb3\",\n    white:                \"#ffffff\",\n    whitesmoke:           \"#f5f5f5\",\n    yellow:               \"#ffff00\",\n    yellowgreen:          \"#9acd32\"\n  };\n\n  // Unsupported Processing File and I/O operations.\n  (function(Processing) {\n    var unsupportedP5 = (\"open() createOutput() createInput() BufferedReader selectFolder() \" +\n                         \"dataPath() createWriter() selectOutput() beginRecord() \" +\n                         \"saveStream() endRecord() selectInput() saveBytes() createReader() \" +\n                         \"beginRaw() endRaw() PrintWriter delay()\").split(\" \"),\n        count = unsupportedP5.length,\n        prettyName,\n        p5Name;\n\n    function createUnsupportedFunc(n) {\n      return function() {\n        throw \"Processing.js does not support \" + n + \".\";\n      };\n    }\n\n    while (count--) {\n      prettyName = unsupportedP5[count];\n      p5Name = prettyName.replace(\"()\", \"\");\n\n      Processing[p5Name] = createUnsupportedFunc(prettyName);\n    }\n  }(defaultScope));\n\n  // screenWidth and screenHeight are shared by all instances.\n  // and return the width/height of the browser's viewport.\n  defaultScope.defineProperty(defaultScope, 'screenWidth',\n    { get: function() { return window.innerWidth; } });\n\n  defaultScope.defineProperty(defaultScope, 'screenHeight',\n    { get: function() { return window.innerHeight; } });\n\n  defaultScope.defineProperty(defaultScope, 'online',\n    { get: function() { return true; } });\n\n  // Manage multiple Processing instances\n  var processingInstances = [];\n  var processingInstanceIds = {};\n\n  var removeInstance = function(id) {\n    processingInstances.splice(processingInstanceIds[id], 1);\n    delete processingInstanceIds[id];\n  };\n\n  var addInstance = function(processing) {\n    if (processing.externals.canvas.id === undef || !processing.externals.canvas.id.length) {\n      processing.externals.canvas.id = \"__processing\" + processingInstances.length;\n    }\n    processingInstanceIds[processing.externals.canvas.id] = processingInstances.length;\n    processingInstances.push(processing);\n  };\n\n\n  ////////////////////////////////////////////////////////////////////////////\n  // PFONT.JS START\n  ////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * [internal function] computeFontMetrics() calculates various metrics for text\n   * placement. Currently this function computes the ascent, descent and leading\n   * (from \"lead\", used for vertical space) values for the currently active font.\n   */\n  function computeFontMetrics(pfont) {\n    var emQuad = 250,\n        correctionFactor = pfont.size / emQuad,\n        canvas = document.createElement(\"canvas\");\n    canvas.width = 2*emQuad;\n    canvas.height = 2*emQuad;\n    canvas.style.opacity = 0;\n    var cfmFont = pfont.getCSSDefinition(emQuad+\"px\", \"normal\"),\n        ctx = canvas.getContext(\"2d\");\n    ctx.font = cfmFont;\n\n    // Size the canvas using a string with common max-ascent and max-descent letters.\n    // Changing the canvas dimensions resets the context, so we must reset the font.\n    var protrusions = \"dbflkhyjqpg\";\n    canvas.width = ctx.measureText(protrusions).width;\n    ctx.font = cfmFont;\n\n    // for text lead values, we meaure a multiline text container.\n    var leadDiv = document.createElement(\"div\");\n    leadDiv.style.position = \"absolute\";\n    leadDiv.style.opacity = 0;\n    leadDiv.style.fontFamily = '\"' + pfont.name + '\"';\n    leadDiv.style.fontSize = emQuad + \"px\";\n    leadDiv.innerHTML = protrusions + \"<br/>\" + protrusions;\n    document.body.appendChild(leadDiv);\n\n    var w = canvas.width,\n        h = canvas.height,\n        baseline = h/2;\n\n    // Set all canvas pixeldata values to 255, with all the content\n    // data being 0. This lets us scan for data[i] != 255.\n    ctx.fillStyle = \"white\";\n    ctx.fillRect(0, 0, w, h);\n    ctx.fillStyle = \"black\";\n    ctx.fillText(protrusions, 0, baseline);\n    var pixelData = ctx.getImageData(0, 0, w, h).data;\n\n    // canvas pixel data is w*4 by h*4, because R, G, B and A are separate,\n    // consecutive values in the array, rather than stored as 32 bit ints.\n    var i = 0,\n        w4 = w * 4,\n        len = pixelData.length;\n\n    // Finding the ascent uses a normal, forward scanline\n    while (++i < len && pixelData[i] === 255) {\n      nop();\n    }\n    var ascent = Math.round(i / w4);\n\n    // Finding the descent uses a reverse scanline\n    i = len - 1;\n    while (--i > 0 && pixelData[i] === 255) {\n      nop();\n    }\n    var descent = Math.round(i / w4);\n\n    // set font metrics\n    pfont.ascent = correctionFactor * (baseline - ascent);\n    pfont.descent = correctionFactor * (descent - baseline);\n\n    // Then we try to get the real value from the browser\n    if (document.defaultView.getComputedStyle) {\n      var leadDivHeight = document.defaultView.getComputedStyle(leadDiv,null).getPropertyValue(\"height\");\n      leadDivHeight = correctionFactor * leadDivHeight.replace(\"px\",\"\");\n      if (leadDivHeight >= pfont.size * 2) {\n        pfont.leading = Math.round(leadDivHeight/2);\n      }\n    }\n    document.body.removeChild(leadDiv);\n\n    // if we're caching, cache the context used for this pfont\n    if (pfont.caching) {\n      return ctx;\n    }\n  }\n\n  /**\n   * Constructor for a system or from-file (non-SVG) font.\n   */\n  function PFont(name, size) {\n    // according to the P5 API, new PFont() is legal (albeit completely useless)\n    if (name === undef) {\n      name = \"\";\n    }\n    this.name = name;\n    if (size === undef) {\n      size = 0;\n    }\n    this.size = size;\n    this.glyph = false;\n    this.ascent = 0;\n    this.descent = 0;\n    // For leading, the \"safe\" value uses the standard TEX ratio\n    this.leading = 1.2 * size;\n\n    // Note that an italic, bold font must used \"... Bold Italic\"\n    // in P5. \"... Italic Bold\" is treated as normal/normal.\n    var illegalIndicator = name.indexOf(\" Italic Bold\");\n    if (illegalIndicator !== -1) {\n      name = name.substring(0, illegalIndicator);\n    }\n\n    // determine font style\n    this.style = \"normal\";\n    var italicsIndicator = name.indexOf(\" Italic\");\n    if (italicsIndicator !== -1) {\n      name = name.substring(0, italicsIndicator);\n      this.style = \"italic\";\n    }\n\n    // determine font weight\n    this.weight = \"normal\";\n    var boldIndicator = name.indexOf(\" Bold\");\n    if (boldIndicator !== -1) {\n      name = name.substring(0, boldIndicator);\n      this.weight = \"bold\";\n    }\n\n    // determine font-family name\n    this.family = \"sans-serif\";\n    if (name !== undef) {\n      switch(name) {\n        case \"sans-serif\":\n        case \"serif\":\n        case \"monospace\":\n        case \"fantasy\":\n        case \"cursive\":\n          this.family = name;\n          break;\n        default:\n          this.family = '\"' + name + '\", sans-serif';\n          break;\n      }\n    }\n    // Calculate the ascent/descent/leading value based on\n    // how the browser renders this font.\n    this.context2d = computeFontMetrics(this);\n    this.css = this.getCSSDefinition();\n    if (this.context2d) {\n      this.context2d.font = this.css;\n    }\n  }\n\n  /**\n   * regulates whether or not we're caching the canvas\n   * 2d context for quick text width computation.\n   */\n  PFont.prototype.caching = true;\n\n  /**\n   * This function generates the CSS \"font\" string for this PFont\n   */\n  PFont.prototype.getCSSDefinition = function(fontSize, lineHeight) {\n    if(fontSize===undef) {\n      fontSize = this.size + \"px\";\n    }\n    if(lineHeight===undef) {\n      lineHeight = this.leading + \"px\";\n    }\n    // CSS \"font\" definition: font-style font-variant font-weight font-size/line-height font-family\n    var components = [this.style, \"normal\", this.weight, fontSize + \"/\" + lineHeight, this.family];\n    return components.join(\" \");\n  };\n\n  /**\n   * Rely on the cached context2d measureText function.\n   */\n  PFont.prototype.measureTextWidth = function(string) {\n    return this.context2d.measureText(string).width;\n  };\n\n  /**\n   * FALLBACK FUNCTION -- replaces Pfont.prototype.measureTextWidth\n   * when the font cache becomes too large. This contructs a new\n   * canvas 2d context object for calling measureText on.\n   */\n  PFont.prototype.measureTextWidthFallback = function(string) {\n    var canvas = document.createElement(\"canvas\"),\n        ctx = canvas.getContext(\"2d\");\n    ctx.font = this.css;\n    return ctx.measureText(string).width;\n  };\n\n  /**\n   * Global \"loaded fonts\" list, internal to PFont\n   */\n  PFont.PFontCache = { length: 0 };\n\n  /**\n   * This function acts as single access point for getting and caching\n   * fonts across all sketches handled by an instance of Processing.js\n   */\n  PFont.get = function(fontName, fontSize) {\n    // round fontSize to one decimal point\n    fontSize = ((fontSize*10)+0.5|0)/10;\n    var cache = PFont.PFontCache,\n        idx = fontName+\"/\"+fontSize;\n    if (!cache[idx]) {\n      cache[idx] = new PFont(fontName, fontSize);\n      cache.length++;\n\n      // FALLBACK FUNCTIONALITY 1:\n      // If the cache has become large, switch over from full caching\n      // to caching only the static metrics for each new font request.\n      if (cache.length === 50) {\n        PFont.prototype.measureTextWidth = PFont.prototype.measureTextWidthFallback;\n        PFont.prototype.caching = false;\n        // clear contexts stored for each cached font\n        var entry;\n        for (entry in cache) {\n          if (entry !== \"length\") {\n            cache[entry].context2d = null;\n          }\n        }\n        return new PFont(fontName, fontSize);\n      }\n\n      // FALLBACK FUNCTIONALITY 2:\n      // If the cache has become too large, switch off font caching entirely.\n      if (cache.length === 400) {\n        PFont.PFontCache = {};\n        PFont.get = PFont.getFallback;\n        return new PFont(fontName, fontSize);\n      }\n    }\n    return cache[idx];\n  };\n\n  /**\n   * FALLBACK FUNCTION -- replaces PFont.get when the font cache\n   * becomes too large. This function bypasses font caching entirely.\n   */\n  PFont.getFallback = function(fontName, fontSize) {\n    return new PFont(fontName, fontSize);\n  };\n\n  /**\n   * Lists all standard fonts. Due to browser limitations, this list is\n   * not the system font list, like in P5, but the CSS \"genre\" list.\n   */\n  PFont.list = function() {\n    return [\"sans-serif\", \"serif\", \"monospace\", \"fantasy\", \"cursive\"];\n  };\n\n  /**\n   * Loading external fonts through @font-face rules is handled by PFont,\n   * to ensure fonts loaded in this way are globally available.\n   */\n  PFont.preloading = {\n    // template element used to compare font sizes\n    template: {},\n    // indicates whether or not the reference tiny font has been loaded\n    initialized: false,\n    // load the reference tiny font via a css @font-face rule\n    initialize: function() {\n      var generateTinyFont = function() {\n        var encoded = \"#E3KAI2wAgT1MvMg7Eo3VmNtYX7ABi3CxnbHlm\" +\n                      \"7Abw3kaGVhZ7ACs3OGhoZWE7A53CRobXR47AY3\" +\n                      \"AGbG9jYQ7G03Bm1heH7ABC3CBuYW1l7Ae3AgcG\" +\n                      \"9zd7AI3AE#B3AQ2kgTY18PPPUACwAg3ALSRoo3\" +\n                      \"#yld0xg32QAB77#E777773B#E3C#I#Q77773E#\" +\n                      \"Q7777777772CMAIw7AB77732B#M#Q3wAB#g3B#\" +\n                      \"E#E2BB//82BB////w#B7#gAEg3E77x2B32B#E#\" +\n                      \"Q#MTcBAQ32gAe#M#QQJ#E32M#QQJ#I#g32Q77#\";\n        var expand = function(input) {\n                       return \"AAAAAAAA\".substr(~~input ? 7-input : 6);\n                     };\n        return encoded.replace(/[#237]/g, expand);\n      };\n      var fontface = document.createElement(\"style\");\n      fontface.setAttribute(\"type\",\"text/css\");\n      fontface.innerHTML =  \"@font-face {\\n\" +\n                            '  font-family: \"PjsEmptyFont\";' + \"\\n\" +\n                            \"  src: url('data:application/x-font-ttf;base64,\"+generateTinyFont()+\"')\\n\" +\n                            \"       format('truetype');\\n\" +\n                            \"}\";\n      document.head.appendChild(fontface);\n\n      // set up the template element\n      var element = document.createElement(\"span\");\n      element.style.cssText = 'position: absolute; top: 0; left: 0; opacity: 0; font-family: \"PjsEmptyFont\", fantasy;';\n      element.innerHTML = \"AAAAAAAA\";\n      document.body.appendChild(element);\n      this.template = element;\n\n      this.initialized = true;\n    },\n    // Shorthand function to get the computed width for an element.\n    getElementWidth: function(element) {\n      return document.defaultView.getComputedStyle(element,\"\").getPropertyValue(\"width\");\n    },\n    // time taken so far in attempting to load a font\n    timeAttempted: 0,\n    // returns false if no fonts are pending load, or true otherwise.\n    pending: function(intervallength) {\n      if (!this.initialized) {\n        this.initialize();\n      }\n      var element,\n          computedWidthFont,\n          computedWidthRef = this.getElementWidth(this.template);\n      for (var i = 0; i < this.fontList.length; i++) {\n        // compares size of text in pixels. if equal, custom font is not yet loaded\n        element = this.fontList[i];\n        computedWidthFont = this.getElementWidth(element);\n        if (this.timeAttempted < 4000 && computedWidthFont === computedWidthRef) {\n          this.timeAttempted += intervallength;\n          return true;\n        } else {\n          document.body.removeChild(element);\n          this.fontList.splice(i--, 1);\n          this.timeAttempted = 0;\n        }\n      }\n      // if there are no more fonts to load, pending is false\n      if (this.fontList.length === 0) {\n        return false;\n      }\n      // We should have already returned before getting here.\n      // But, if we do get here, length!=0 so fonts are pending.\n      return true;\n    },\n    // fontList contains elements to compare font sizes against a template\n    fontList: [],\n    // addedList contains the fontnames of all the fonts loaded via @font-face\n    addedList: {},\n    // adds a font to the font cache\n    // creates an element using the font, to start loading the font,\n    // and compare against a default font to see if the custom font is loaded\n    add: function(fontSrc) {\n      if (!this.initialized) {\n       this.initialize();\n      }\n      // fontSrc can be a string or a javascript object\n      // acceptable fonts are .ttf, .otf, and data uri\n      var fontName = (typeof fontSrc === 'object' ? fontSrc.fontFace : fontSrc),\n          fontUrl = (typeof fontSrc === 'object' ? fontSrc.url : fontSrc);\n\n      // check whether we already created the @font-face rule for this font\n      if (this.addedList[fontName]) {\n        return;\n      }\n\n      // if we didn't, create the @font-face rule\n      var style = document.createElement(\"style\");\n      style.setAttribute(\"type\",\"text/css\");\n      style.innerHTML = \"@font-face{\\n  font-family: '\" + fontName + \"';\\n  src:  url('\" + fontUrl + \"');\\n}\\n\";\n      document.head.appendChild(style);\n      this.addedList[fontName] = true;\n\n      // also create the element to load and compare the new font\n      var element = document.createElement(\"span\");\n      element.style.cssText = \"position: absolute; top: 0; left: 0; opacity: 0;\";\n      element.style.fontFamily = '\"' + fontName + '\", \"PjsEmptyFont\", fantasy';\n      element.innerHTML = \"AAAAAAAA\";\n      document.body.appendChild(element);\n      this.fontList.push(element);\n    }\n  };\n\n  // add to the default scope\n  defaultScope.PFont = PFont;\n\n\n  ////////////////////////////////////////////////////////////////////////////\n  // PFONT.JS END\n  ////////////////////////////////////////////////////////////////////////////\n\n\n  var Processing = this.Processing = function(aCanvas, aCode) {\n    // Previously we allowed calling Processing as a func instead of ctor, but no longer.\n    if (!(this instanceof Processing)) {\n      throw(\"called Processing constructor as if it were a function: missing 'new'.\");\n    }\n\n    var curElement,\n      pgraphicsMode = (aCanvas === undef && aCode === undef);\n\n    if (pgraphicsMode) {\n      curElement = document.createElement(\"canvas\");\n    } else {\n      // We'll take a canvas element or a string for a canvas element's id\n      curElement = typeof aCanvas === \"string\" ? document.getElementById(aCanvas) : aCanvas;\n    }\n\n    if (!(curElement instanceof HTMLCanvasElement)) {\n      throw(\"called Processing constructor without passing canvas element reference or id.\");\n    }\n\n    function unimplemented(s) {\n      Processing.debug('Unimplemented - ' + s);\n    }\n\n    // When something new is added to \"p.\" it must also be added to the \"names\" array.\n    // The names array contains the names of everything that is inside \"p.\"\n    var p = this;\n\n    // PJS specific (non-p5) methods and properties to externalize\n    p.externals = {\n      canvas:  curElement,\n      context: undef,\n      sketch:  undef\n    };\n\n    p.name            = 'Processing.js Instance'; // Set Processing defaults / environment variables\n    p.use3DContext    = false; // default '2d' canvas context\n\n    /**\n     * Confirms if a Processing program is \"focused\", meaning that it is\n     * active and will accept input from mouse or keyboard. This variable\n     * is \"true\" if it is focused and \"false\" if not. This variable is\n     * often used when you want to warn people they need to click on the\n     * browser before it will work.\n    */\n    p.focused         = false;\n    p.breakShape      = false;\n\n    // Glyph path storage for textFonts\n    p.glyphTable      = {};\n\n    // Global vars for tracking mouse position\n    p.pmouseX         = 0;\n    p.pmouseY         = 0;\n    p.mouseX          = 0;\n    p.mouseY          = 0;\n    p.mouseButton     = 0;\n    p.mouseScroll     = 0;\n\n    // Undefined event handlers to be replaced by user when needed\n    p.mouseClicked    = undef;\n    p.mouseDragged    = undef;\n    p.mouseMoved      = undef;\n    p.mousePressed    = undef;\n    p.mouseReleased   = undef;\n    p.mouseScrolled   = undef;\n    p.mouseOver       = undef;\n    p.mouseOut        = undef;\n    p.touchStart      = undef;\n    p.touchEnd        = undef;\n    p.touchMove       = undef;\n    p.touchCancel     = undef;\n    p.key             = undef;\n    p.keyCode         = undef;\n    p.keyPressed      = nop; // needed to remove function checks\n    p.keyReleased     = nop;\n    p.keyTyped        = nop;\n    p.draw            = undef;\n    p.setup           = undef;\n\n    // Remapped vars\n    p.__mousePressed  = false;\n    p.__keyPressed    = false;\n    p.__frameRate     = 60;\n\n    // The current animation frame\n    p.frameCount      = 0;\n\n    // The height/width of the canvas\n    p.width           = 100;\n    p.height          = 100;\n\n    // \"Private\" variables used to maintain state\n    var curContext,\n        curSketch,\n        drawing, // hold a Drawing2D or Drawing3D object\n        online = true,\n        doFill = true,\n        fillStyle = [1.0, 1.0, 1.0, 1.0],\n        currentFillColor = 0xFFFFFFFF,\n        isFillDirty = true,\n        doStroke = true,\n        strokeStyle = [0.0, 0.0, 0.0, 1.0],\n        currentStrokeColor = 0xFF000000,\n        isStrokeDirty = true,\n        lineWidth = 1,\n        loopStarted = false,\n        renderSmooth = false,\n        doLoop = true,\n        looping = 0,\n        curRectMode = PConstants.CORNER,\n        curEllipseMode = PConstants.CENTER,\n        normalX = 0,\n        normalY = 0,\n        normalZ = 0,\n        normalMode = PConstants.NORMAL_MODE_AUTO,\n        curFrameRate = 60,\n        curMsPerFrame = 1000/curFrameRate,\n        curCursor = PConstants.ARROW,\n        oldCursor = curElement.style.cursor,\n        curShape = PConstants.POLYGON,\n        curShapeCount = 0,\n        curvePoints = [],\n        curTightness = 0,\n        curveDet = 20,\n        curveInited = false,\n        backgroundObj = -3355444, // rgb(204, 204, 204) is the default gray background colour\n        bezDetail = 20,\n        colorModeA = 255,\n        colorModeX = 255,\n        colorModeY = 255,\n        colorModeZ = 255,\n        pathOpen = false,\n        mouseDragging = false,\n        pmouseXLastFrame = 0,\n        pmouseYLastFrame = 0,\n        curColorMode = PConstants.RGB,\n        curTint = null,\n        curTint3d = null,\n        getLoaded = false,\n        start = Date.now(),\n        timeSinceLastFPS = start,\n        framesSinceLastFPS = 0,\n        textcanvas,\n        curveBasisMatrix,\n        curveToBezierMatrix,\n        curveDrawMatrix,\n        bezierDrawMatrix,\n        bezierBasisInverse,\n        bezierBasisMatrix,\n        curContextCache = { attributes: {}, locations: {} },\n        // Shaders\n        programObject3D,\n        programObject2D,\n        programObjectUnlitShape,\n        boxBuffer,\n        boxNormBuffer,\n        boxOutlineBuffer,\n        rectBuffer,\n        rectNormBuffer,\n        sphereBuffer,\n        lineBuffer,\n        fillBuffer,\n        fillColorBuffer,\n        strokeColorBuffer,\n        pointBuffer,\n        shapeTexVBO,\n        canTex,   // texture for createGraphics\n        textTex,   // texture for 3d tex\n        curTexture = {width:0,height:0},\n        curTextureMode = PConstants.IMAGE,\n        usingTexture = false,\n        textBuffer,\n        textureBuffer,\n        indexBuffer,\n        // Text alignment\n        horizontalTextAlignment = PConstants.LEFT,\n        verticalTextAlignment = PConstants.BASELINE,\n        textMode = PConstants.MODEL,\n        // Font state\n        curFontName = \"Arial\",\n        curTextSize = 12,\n        curTextAscent = 9,\n        curTextDescent = 2,\n        curTextLeading = 14,\n        curTextFont = PFont.get(curFontName, curTextSize),\n        // Pixels cache\n        originalContext,\n        proxyContext = null,\n        isContextReplaced = false,\n        setPixelsCached,\n        maxPixelsCached = 1000,\n        pressedKeysMap = [],\n        lastPressedKeyCode = null,\n        codedKeys = [ PConstants.SHIFT, PConstants.CONTROL, PConstants.ALT, PConstants.CAPSLK, PConstants.PGUP, PConstants.PGDN,\n                      PConstants.END, PConstants.HOME, PConstants.LEFT, PConstants.UP, PConstants.RIGHT, PConstants.DOWN, PConstants.NUMLK,\n                      PConstants.INSERT, PConstants.F1, PConstants.F2, PConstants.F3, PConstants.F4, PConstants.F5, PConstants.F6, PConstants.F7,\n                      PConstants.F8, PConstants.F9, PConstants.F10, PConstants.F11, PConstants.F12, PConstants.META ];\n\n    // Get padding and border style widths for mouse offsets\n    var stylePaddingLeft, stylePaddingTop, styleBorderLeft, styleBorderTop;\n\n    if (document.defaultView && document.defaultView.getComputedStyle) {\n      stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(curElement, null)['paddingLeft'], 10)      || 0;\n      stylePaddingTop  = parseInt(document.defaultView.getComputedStyle(curElement, null)['paddingTop'], 10)       || 0;\n      styleBorderLeft  = parseInt(document.defaultView.getComputedStyle(curElement, null)['borderLeftWidth'], 10)  || 0;\n      styleBorderTop   = parseInt(document.defaultView.getComputedStyle(curElement, null)['borderTopWidth'], 10)   || 0;\n    }\n\n    // User can only have MAX_LIGHTS lights\n    var lightCount = 0;\n\n    //sphere stuff\n    var sphereDetailV = 0,\n        sphereDetailU = 0,\n        sphereX = [],\n        sphereY = [],\n        sphereZ = [],\n        sinLUT = new Float32Array(PConstants.SINCOS_LENGTH),\n        cosLUT = new Float32Array(PConstants.SINCOS_LENGTH),\n        sphereVerts,\n        sphereNorms;\n\n    // Camera defaults and settings\n    var cam,\n        cameraInv,\n        modelView,\n        modelViewInv,\n        userMatrixStack,\n        userReverseMatrixStack,\n        inverseCopy,\n        projection,\n        manipulatingCamera = false,\n        frustumMode = false,\n        cameraFOV = 60 * (Math.PI / 180),\n        cameraX = p.width / 2,\n        cameraY = p.height / 2,\n        cameraZ = cameraY / Math.tan(cameraFOV / 2),\n        cameraNear = cameraZ / 10,\n        cameraFar = cameraZ * 10,\n        cameraAspect = p.width / p.height;\n\n    var vertArray = [],\n        curveVertArray = [],\n        curveVertCount = 0,\n        isCurve = false,\n        isBezier = false,\n        firstVert = true;\n\n    //PShape stuff\n    var curShapeMode = PConstants.CORNER;\n\n    // Stores states for pushStyle() and popStyle().\n    var styleArray = [];\n\n    // The vertices for the box cannot be specified using a triangle strip since each\n    // side of the cube must have its own set of normals.\n    // Vertices are specified in a counter-clockwise order.\n    // Triangles are in this order: back, front, right, bottom, left, top.\n    var boxVerts = new Float32Array([\n       0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,\n       0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,\n       0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,\n       0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,\n      -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5,\n       0.5,  0.5,  0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5]);\n\n    var boxOutlineVerts = new Float32Array([\n       0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5,\n      -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,\n       0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5,\n      -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,\n       0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5,\n      -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5]);\n\n    var boxNorms = new Float32Array([\n       0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,\n       0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,\n       1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,\n       0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,\n      -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0,\n       0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0]);\n\n    // These verts are used for the fill and stroke using TRIANGLE_FAN and LINE_LOOP.\n    var rectVerts = new Float32Array([0,0,0, 0,1,0, 1,1,0, 1,0,0]);\n\n    var rectNorms = new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1]);\n\n    // Shader for points and lines in begin/endShape.\n    var vertexShaderSrcUnlitShape =\n      \"varying vec4 vFrontColor;\" +\n\n      \"attribute vec3 aVertex;\" +\n      \"attribute vec4 aColor;\" +\n\n      \"uniform mat4 uView;\" +\n      \"uniform mat4 uProjection;\" +\n      \"uniform float uPointSize;\" +\n\n      \"void main(void) {\" +\n      \"  vFrontColor = aColor;\" +\n      \"  gl_PointSize = uPointSize;\" +\n      \"  gl_Position = uProjection * uView * vec4(aVertex, 1.0);\" +\n      \"}\";\n\n    var fragmentShaderSrcUnlitShape =\n      \"#ifdef GL_ES\\n\" +\n      \"precision highp float;\\n\" +\n      \"#endif\\n\" +\n\n      \"varying vec4 vFrontColor;\" +\n      \"uniform bool uSmooth;\" +\n\n      \"void main(void){\" +\n      \"  if(uSmooth == true){\" +\n      \"    float dist = distance(gl_PointCoord, vec2(0.5));\" +\n      \"    if(dist > 0.5){\" +\n      \"      discard;\" +\n      \"    }\" +\n      \"  }\" +\n      \"  gl_FragColor = vFrontColor;\" +\n      \"}\";\n\n    // Shader for rect, text, box outlines, sphere outlines, point() and line().\n    var vertexShaderSrc2D =\n      \"varying vec4 vFrontColor;\" +\n\n      \"attribute vec3 aVertex;\" +\n      \"attribute vec2 aTextureCoord;\" +\n      \"uniform vec4 uColor;\" +\n\n      \"uniform mat4 uModel;\" +\n      \"uniform mat4 uView;\" +\n      \"uniform mat4 uProjection;\" +\n      \"uniform float uPointSize;\" +\n      \"varying vec2 vTextureCoord;\"+\n\n      \"void main(void) {\" +\n      \"  gl_PointSize = uPointSize;\" +\n      \"  vFrontColor = uColor;\" +\n      \"  gl_Position = uProjection * uView * uModel * vec4(aVertex, 1.0);\" +\n      \"  vTextureCoord = aTextureCoord;\" +\n      \"}\";\n\n    var fragmentShaderSrc2D =\n      \"#ifdef GL_ES\\n\" +\n      \"precision highp float;\\n\" +\n      \"#endif\\n\" +\n\n      \"varying vec4 vFrontColor;\" +\n      \"varying vec2 vTextureCoord;\"+\n\n      \"uniform sampler2D uSampler;\"+\n      \"uniform int uIsDrawingText;\"+\n      \"uniform bool uSmooth;\" +\n\n      \"void main(void){\" +\n      // WebGL does not support POINT_SMOOTH, so we do it ourselves\n      \"  if(uSmooth == true){\" +\n      \"    float dist = distance(gl_PointCoord, vec2(0.5));\" +\n      \"    if(dist > 0.5){\" +\n      \"      discard;\" +\n      \"    }\" +\n      \"  }\" +\n\n      \"  if(uIsDrawingText == 1){\" +\n      \"    float alpha = texture2D(uSampler, vTextureCoord).a;\"+\n      \"    gl_FragColor = vec4(vFrontColor.rgb * alpha, alpha);\"+\n      \"  }\" +\n      \"  else{\" +\n      \"    gl_FragColor = vFrontColor;\" +\n      \"  }\" +\n      \"}\";\n\n    var webglMaxTempsWorkaround = /Windows/.test(navigator.userAgent);\n\n    // Vertex shader for boxes and spheres.\n    var vertexShaderSrc3D =\n      \"varying vec4 vFrontColor;\" +\n\n      \"attribute vec3 aVertex;\" +\n      \"attribute vec3 aNormal;\" +\n      \"attribute vec4 aColor;\" +\n      \"attribute vec2 aTexture;\" +\n      \"varying   vec2 vTexture;\" +\n\n      \"uniform vec4 uColor;\" +\n\n      \"uniform bool uUsingMat;\" +\n      \"uniform vec3 uSpecular;\" +\n      \"uniform vec3 uMaterialEmissive;\" +\n      \"uniform vec3 uMaterialAmbient;\" +\n      \"uniform vec3 uMaterialSpecular;\" +\n      \"uniform float uShininess;\" +\n\n      \"uniform mat4 uModel;\" +\n      \"uniform mat4 uView;\" +\n      \"uniform mat4 uProjection;\" +\n      \"uniform mat4 uNormalTransform;\" +\n\n      \"uniform int uLightCount;\" +\n      \"uniform vec3 uFalloff;\" +\n\n      // Careful changing the order of these fields. Some cards\n      // have issues with memory alignment.\n      \"struct Light {\" +\n      \"  int type;\" +\n      \"  vec3 color;\" +\n      \"  vec3 position;\" +\n      \"  vec3 direction;\" +\n      \"  float angle;\" +\n      \"  vec3 halfVector;\" +\n      \"  float concentration;\" +\n      \"};\" +\n\n      // nVidia cards have issues with arrays of structures\n      // so instead we create 8 instances of Light.\n      \"uniform Light uLights0;\" +\n      \"uniform Light uLights1;\" +\n      \"uniform Light uLights2;\" +\n      \"uniform Light uLights3;\" +\n      \"uniform Light uLights4;\" +\n      \"uniform Light uLights5;\" +\n      \"uniform Light uLights6;\" +\n      \"uniform Light uLights7;\" +\n\n     // GLSL does not support switch.\n      \"Light getLight(int index){\" +\n      \"  if(index == 0) return uLights0;\" +\n      \"  if(index == 1) return uLights1;\" +\n      \"  if(index == 2) return uLights2;\" +\n      \"  if(index == 3) return uLights3;\" +\n      \"  if(index == 4) return uLights4;\" +\n      \"  if(index == 5) return uLights5;\" +\n      \"  if(index == 6) return uLights6;\" +\n      // Do not use a conditional for the last return statement\n      // because some video cards will fail and complain that\n      // \"not all paths return\".\n      \"  return uLights7;\" +\n      \"}\" +\n\n      \"void AmbientLight( inout vec3 totalAmbient, in vec3 ecPos, in Light light ) {\" +\n      // Get the vector from the light to the vertex and\n      // get the distance from the current vector to the light position.\n      \"  float d = length( light.position - ecPos );\" +\n      \"  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));\" +\n      \"  totalAmbient += light.color * attenuation;\" +\n      \"}\" +\n\n      /*\n        col - accumulated color\n        spec - accumulated specular highlight\n        vertNormal - Normal of the vertex\n        ecPos - eye coordinate position\n        light - light structure\n      */\n      \"void DirectionalLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {\" +\n      \"  float powerFactor = 0.0;\" +\n      \"  float nDotVP = max(0.0, dot( vertNormal, normalize(-light.position) ));\" +\n      \"  float nDotVH = max(0.0, dot( vertNormal, normalize(-light.position-normalize(ecPos) )));\" +\n\n      \"  if( nDotVP != 0.0 ){\" +\n      \"    powerFactor = pow( nDotVH, uShininess );\" +\n      \"  }\" +\n\n      \"  col += light.color * nDotVP;\" +\n      \"  spec += uSpecular * powerFactor;\" +\n      \"}\" +\n\n      /*\n        col - accumulated color\n        spec - accumulated specular highlight\n        vertNormal - Normal of the vertex\n        ecPos - eye coordinate position\n        light - light structure\n      */\n      \"void PointLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {\" +\n      \"  float powerFactor;\" +\n\n      // Get the vector from the light to the vertex.\n      \"   vec3 VP = light.position - ecPos;\" +\n\n      // Get the distance from the current vector to the light position.\n      \"  float d = length( VP ); \" +\n\n      // Normalize the light ray so it can be used in the dot product operation.\n      \"  VP = normalize( VP );\" +\n\n      \"  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));\" +\n\n      \"  float nDotVP = max( 0.0, dot( vertNormal, VP ));\" +\n      \"  vec3 halfVector = normalize( VP - normalize(ecPos) );\" +\n      \"  float nDotHV = max( 0.0, dot( vertNormal, halfVector ));\" +\n\n      \"  if( nDotVP == 0.0 ) {\" +\n      \"    powerFactor = 0.0;\" +\n      \"  }\" +\n      \"  else {\" +\n      \"    powerFactor = pow( nDotHV, uShininess );\" +\n      \"  }\" +\n\n      \"  spec += uSpecular * powerFactor * attenuation;\" +\n      \"  col += light.color * nDotVP * attenuation;\" +\n      \"}\" +\n\n      /*\n        col - accumulated color\n        spec - accumulated specular highlight\n        vertNormal - Normal of the vertex\n        ecPos - eye coordinate position\n        light - light structure\n      */\n      \"void SpotLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {\" +\n      \"  float spotAttenuation;\" +\n      \"  float powerFactor = 0.0;\" +\n\n      // Calculate the vector from the current vertex to the light.\n      \"  vec3 VP = light.position - ecPos;\" +\n      \"  vec3 ldir = normalize( -light.direction );\" +\n\n      // Get the distance from the spotlight and the vertex\n      \"  float d = length( VP );\" +\n      \"  VP = normalize( VP );\" +\n\n      \"  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ) );\" +\n\n      // Dot product of the vector from vertex to light and light direction.\n      \"  float spotDot = dot( VP, ldir );\" +\n\n      // If the vertex falls inside the cone\n      (webglMaxTempsWorkaround ? // Windows reports max temps error if light.angle is used\n      \"  spotAttenuation = 1.0; \" :\n      \"  if( spotDot > cos( light.angle ) ) {\" +\n      \"    spotAttenuation = pow( spotDot, light.concentration );\" +\n      \"  }\" +\n      \"  else{\" +\n      \"    spotAttenuation = 0.0;\" +\n      \"  }\" +\n      \"  attenuation *= spotAttenuation;\" +\n      \"\") +\n\n      \"  float nDotVP = max( 0.0, dot( vertNormal, VP ) );\" +\n      \"  vec3 halfVector = normalize( VP - normalize(ecPos) );\" +\n      \"  float nDotHV = max( 0.0, dot( vertNormal, halfVector ) );\" +\n\n      \"  if( nDotVP != 0.0 ) {\" +\n      \"    powerFactor = pow( nDotHV, uShininess );\" +\n      \"  }\" +\n\n      \"  spec += uSpecular * powerFactor * attenuation;\" +\n      \"  col += light.color * nDotVP * attenuation;\" +\n      \"}\" +\n\n      \"void main(void) {\" +\n      \"  vec3 finalAmbient = vec3( 0.0 );\" +\n      \"  vec3 finalDiffuse = vec3( 0.0 );\" +\n      \"  vec3 finalSpecular = vec3( 0.0 );\" +\n\n      \"  vec4 col = uColor;\" +\n\n      \"  if ( uColor[0] == -1.0 ){\" +\n      \"    col = aColor;\" +\n      \"  }\" +\n\n      // We use the sphere vertices as the normals when we create the sphere buffer.\n      // But this only works if the sphere vertices are unit length, so we\n      // have to normalize the normals here. Since this is only required for spheres\n      // we could consider placing this in a conditional later on.\n      \"  vec3 norm = normalize(vec3( uNormalTransform * vec4( aNormal, 0.0 ) ));\" +\n\n      \"  vec4 ecPos4 = uView * uModel * vec4(aVertex, 1.0);\" +\n      \"  vec3 ecPos = (vec3(ecPos4))/ecPos4.w;\" +\n\n      // If there were no lights this draw call, just use the\n      // assigned fill color of the shape and the specular value.\n      \"  if( uLightCount == 0 ) {\" +\n      \"    vFrontColor = col + vec4(uMaterialSpecular, 1.0);\" +\n      \"  }\" +\n      \"  else {\" +\n           // WebGL forces us to iterate over a constant value\n           // so we can't iterate using lightCount.\n      \"    for( int i = 0; i < 8; i++ ) {\" +\n      \"      Light l = getLight(i);\" +\n\n      // We can stop iterating if we know we have gone past\n      // the number of lights which are actually on. This gives us a\n      // significant performance increase with high vertex counts.\n      \"      if( i >= uLightCount ){\" +\n      \"        break;\" +\n      \"      }\" +\n\n      \"      if( l.type == 0 ) {\" +\n      \"        AmbientLight( finalAmbient, ecPos, l );\" +\n      \"      }\" +\n      \"      else if( l.type == 1 ) {\" +\n      \"        DirectionalLight( finalDiffuse, finalSpecular, norm, ecPos, l );\" +\n      \"      }\" +\n      \"      else if( l.type == 2 ) {\" +\n      \"        PointLight( finalDiffuse, finalSpecular, norm, ecPos, l );\" +\n      \"      }\" +\n      \"      else {\" +\n      \"        SpotLight( finalDiffuse, finalSpecular, norm, ecPos, l );\" +\n      \"      }\" +\n      \"    }\" +\n\n      \"   if( uUsingMat == false ) {\" +\n      \"     vFrontColor = vec4(\" +\n      \"       vec3( col ) * finalAmbient +\" +\n      \"       vec3( col ) * finalDiffuse +\" +\n      \"       vec3( col ) * finalSpecular,\" +\n      \"       col[3] );\" +\n      \"   }\" +\n      \"   else{\" +\n      \"     vFrontColor = vec4( \" +\n      \"       uMaterialEmissive + \" +\n      \"       (vec3(col) * uMaterialAmbient * finalAmbient ) + \" +\n      \"       (vec3(col) * finalDiffuse) + \" +\n      \"       (uMaterialSpecular * finalSpecular), \" +\n      \"       col[3] );\" +\n      \"    }\" +\n      \"  }\" +\n\n      \"  vTexture.xy = aTexture.xy;\" +\n      \"  gl_Position = uProjection * uView * uModel * vec4( aVertex, 1.0 );\" +\n      \"}\";\n\n    var fragmentShaderSrc3D =\n      \"#ifdef GL_ES\\n\" +\n      \"precision highp float;\\n\" +\n      \"#endif\\n\" +\n\n      \"varying vec4 vFrontColor;\" +\n\n      \"uniform sampler2D uSampler;\" +\n      \"uniform bool uUsingTexture;\" +\n      \"varying vec2 vTexture;\" +\n\n      // In Processing, when a texture is used, the fill color is ignored\n      // vec4(1.0,1.0,1.0,0.5)\n      \"void main(void){\" +\n      \"  if( uUsingTexture ){\" +\n      \"    gl_FragColor = vec4(texture2D(uSampler, vTexture.xy)) * vFrontColor;\" +\n      \"  }\"+\n      \"  else{\" +\n      \"    gl_FragColor = vFrontColor;\" +\n      \"  }\" +\n      \"}\";\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 3D Functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /*\n     * Sets a uniform variable in a program object to a particular\n     * value. Before calling this function, ensure the correct\n     * program object has been installed as part of the current\n     * rendering state by calling useProgram.\n     *\n     * On some systems, if the variable exists in the shader but isn't used,\n     * the compiler will optimize it out and this function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {float | Array} varValue either a scalar value or an Array\n     *\n     * @returns none\n     *\n     * @see uniformi\n     * @see uniformMatrix\n    */\n    function uniformf(cacheId, programObj, varName, varValue) {\n      var varLocation = curContextCache.locations[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getUniformLocation(programObj, varName);\n        curContextCache.locations[cacheId] = varLocation;\n      }\n      // the variable won't be found if it was optimized out.\n      if (varLocation !== null) {\n        if (varValue.length === 4) {\n          curContext.uniform4fv(varLocation, varValue);\n        } else if (varValue.length === 3) {\n          curContext.uniform3fv(varLocation, varValue);\n        } else if (varValue.length === 2) {\n          curContext.uniform2fv(varLocation, varValue);\n        } else {\n          curContext.uniform1f(varLocation, varValue);\n        }\n      }\n    }\n\n    /**\n     * Sets a uniform int or int array in a program object to a particular\n     * value. Before calling this function, ensure the correct\n     * program object has been installed as part of the current\n     * rendering state.\n     *\n     * On some systems, if the variable exists in the shader but isn't used,\n     * the compiler will optimize it out and this function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {int | Array} varValue either a scalar value or an Array\n     *\n     * @returns none\n     *\n     * @see uniformf\n     * @see uniformMatrix\n    */\n    function uniformi(cacheId, programObj, varName, varValue) {\n      var varLocation = curContextCache.locations[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getUniformLocation(programObj, varName);\n        curContextCache.locations[cacheId] = varLocation;\n      }\n      // the variable won't be found if it was optimized out.\n      if (varLocation !== null) {\n        if (varValue.length === 4) {\n          curContext.uniform4iv(varLocation, varValue);\n        } else if (varValue.length === 3) {\n          curContext.uniform3iv(varLocation, varValue);\n        } else if (varValue.length === 2) {\n          curContext.uniform2iv(varLocation, varValue);\n        } else {\n          curContext.uniform1i(varLocation, varValue);\n        }\n      }\n    }\n\n    /**\n     * Sets the value of a uniform matrix variable in a program\n     * object. Before calling this function, ensure the correct\n     * program object has been installed as part of the current\n     * rendering state.\n     *\n     * On some systems, if the variable exists in the shader but\n     * isn't used, the compiler will optimize it out and this\n     * function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {boolean} transpose must be false\n     * @param {Array} matrix an array of 4, 9 or 16 values\n     *\n     * @returns none\n     *\n     * @see uniformi\n     * @see uniformf\n    */\n    function uniformMatrix(cacheId, programObj, varName, transpose, matrix) {\n      var varLocation = curContextCache.locations[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getUniformLocation(programObj, varName);\n        curContextCache.locations[cacheId] = varLocation;\n      }\n      // The variable won't be found if it was optimized out.\n      if (varLocation !== -1) {\n        if (matrix.length === 16) {\n          curContext.uniformMatrix4fv(varLocation, transpose, matrix);\n        } else if (matrix.length === 9) {\n          curContext.uniformMatrix3fv(varLocation, transpose, matrix);\n        } else {\n          curContext.uniformMatrix2fv(varLocation, transpose, matrix);\n        }\n      }\n    }\n\n    /**\n     * Binds the VBO, sets the vertex attribute data for the program\n     * object and enables the attribute.\n     *\n     * On some systems, if the attribute exists in the shader but\n     * isn't used, the compiler will optimize it out and this\n     * function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {int} size the number of components per vertex attribute\n     * @param {WebGLBuffer} VBO Vertex Buffer Object\n     *\n     * @returns none\n     *\n     * @see disableVertexAttribPointer\n    */\n    function vertexAttribPointer(cacheId, programObj, varName, size, VBO) {\n      var varLocation = curContextCache.attributes[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getAttribLocation(programObj, varName);\n        curContextCache.attributes[cacheId] = varLocation;\n      }\n      if (varLocation !== -1) {\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, VBO);\n        curContext.vertexAttribPointer(varLocation, size, curContext.FLOAT, false, 0, 0);\n        curContext.enableVertexAttribArray(varLocation);\n      }\n    }\n\n    /**\n     * Disables a program object attribute from being sent to WebGL.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName name of the attribute\n     *\n     * @returns none\n     *\n     * @see vertexAttribPointer\n    */\n    function disableVertexAttribPointer(cacheId, programObj, varName){\n      var varLocation = curContextCache.attributes[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getAttribLocation(programObj, varName);\n        curContextCache.attributes[cacheId] = varLocation;\n      }\n      if (varLocation !== -1) {\n        curContext.disableVertexAttribArray(varLocation);\n      }\n    }\n\n    /**\n     * Creates a WebGL program object.\n     *\n     * @param {String} vetexShaderSource\n     * @param {String} fragmentShaderSource\n     *\n     * @returns {WebGLProgram} A program object\n    */\n    var createProgramObject = function(curContext, vetexShaderSource, fragmentShaderSource) {\n      var vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER);\n      curContext.shaderSource(vertexShaderObject, vetexShaderSource);\n      curContext.compileShader(vertexShaderObject);\n      if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {\n        throw curContext.getShaderInfoLog(vertexShaderObject);\n      }\n\n      var fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER);\n      curContext.shaderSource(fragmentShaderObject, fragmentShaderSource);\n      curContext.compileShader(fragmentShaderObject);\n      if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {\n        throw curContext.getShaderInfoLog(fragmentShaderObject);\n      }\n\n      var programObject = curContext.createProgram();\n      curContext.attachShader(programObject, vertexShaderObject);\n      curContext.attachShader(programObject, fragmentShaderObject);\n      curContext.linkProgram(programObject);\n      if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {\n        throw \"Error linking shaders.\";\n      }\n\n      return programObject;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 2D/3D drawing handling\n    ////////////////////////////////////////////////////////////////////////////\n    var imageModeCorner = function(x, y, w, h, whAreSizes) {\n      return {\n        x: x,\n        y: y,\n        w: w,\n        h: h\n      };\n    };\n    var imageModeConvert = imageModeCorner;\n\n    var imageModeCorners = function(x, y, w, h, whAreSizes) {\n      return {\n        x: x,\n        y: y,\n        w: whAreSizes ? w : w - x,\n        h: whAreSizes ? h : h - y\n      };\n    };\n\n    var imageModeCenter = function(x, y, w, h, whAreSizes) {\n      return {\n        x: x - w / 2,\n        y: y - h / 2,\n        w: w,\n        h: h\n      };\n    };\n\n    // Objects for shared, 2D and 3D contexts\n    var DrawingShared = function(){};\n    var Drawing2D = function(){};\n    var Drawing3D = function(){};\n    var DrawingPre = function(){};\n\n    // Setup the prototype chain\n    Drawing2D.prototype = new DrawingShared();\n    Drawing2D.prototype.constructor = Drawing2D;\n    Drawing3D.prototype = new DrawingShared();\n    Drawing3D.prototype.constructor = Drawing3D;\n    DrawingPre.prototype = new DrawingShared();\n    DrawingPre.prototype.constructor = DrawingPre;\n\n    // A no-op function for when the user calls 3D functions from a 2D sketch\n    // We can change this to a throw or console.error() later if we want\n    DrawingShared.prototype.a3DOnlyFunction = nop;\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Char handling\n    ////////////////////////////////////////////////////////////////////////////\n    var charMap = {};\n\n    var Char = p.Character = function(chr) {\n      if (typeof chr === 'string' && chr.length === 1) {\n        this.code = chr.charCodeAt(0);\n      } else if (typeof chr === 'number') {\n        this.code = chr;\n      } else if (chr instanceof Char) {\n        this.code = chr;\n      } else {\n        this.code = NaN;\n      }\n\n      return (charMap[this.code] === undef) ? charMap[this.code] = this : charMap[this.code];\n    };\n\n    Char.prototype.toString = function() {\n      return String.fromCharCode(this.code);\n    };\n\n    Char.prototype.valueOf = function() {\n      return this.code;\n    };\n\n    /**\n     * Datatype for storing shapes. Processing can currently load and display SVG (Scalable Vector Graphics) shapes.\n     * Before a shape is used, it must be loaded with the <b>loadShape()</b> function. The <b>shape()</b> function is used to draw the shape to the display window.\n     * The <b>PShape</b> object contain a group of methods, linked below, that can operate on the shape data.\n     * <br><br>The <b>loadShape()</b> method supports SVG files created with Inkscape and Adobe Illustrator.\n     * It is not a full SVG implementation, but offers some straightforward support for handling vector data.\n     *\n     * @param {int} family the shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY\n     *\n     * @see #shape()\n     * @see #loadShape()\n     * @see #shapeMode()\n     */\n    var PShape = p.PShape = function(family) {\n      this.family    = family || PConstants.GROUP;\n      this.visible   = true;\n      this.style     = true;\n      this.children  = [];\n      this.nameTable = [];\n      this.params    = [];\n      this.name      = \"\";\n      this.image     = null;  //type PImage\n      this.matrix    = null;\n      this.kind      = null;\n      this.close     = null;\n      this.width     = null;\n      this.height    = null;\n      this.parent    = null;\n    };\n    /**\n      * PShape methods\n      * missing: findChild(), apply(), contains(), findChild(), getPrimitive(), getParams(), getVertex() , getVertexCount(),\n      * getVertexCode() , getVertexCodes() , getVertexCodeCount(), getVertexX(), getVertexY(), getVertexZ()\n      */\n    PShape.prototype = {\n      /**\n       * @member PShape\n       * The isVisible() function returns a boolean value \"true\" if the image is set to be visible, \"false\" if not. This is modified with the <b>setVisible()</b> parameter.\n       * <br><br>The visibility of a shape is usually controlled by whatever program created the SVG file.\n       * For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.\n       *\n       * @return {boolean}  returns \"true\" if the image is set to be visible, \"false\" if not\n       */\n      isVisible: function(){\n        return this.visible;\n      },\n      /**\n       * @member PShape\n       * The setVisible() function sets the shape to be visible or invisible. This is determined by the value of the <b>visible</b> parameter.\n       * <br><br>The visibility of a shape is usually controlled by whatever program created the SVG file.\n       * For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.\n       *\n       * @param {boolean} visible \"false\" makes the shape invisible and \"true\" makes it visible\n       */\n      setVisible: function (visible){\n        this.visible = visible;\n      },\n      /**\n       * @member PShape\n       * The disableStyle() function disables the shape's style data and uses Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.\n       * Overrides this shape's style information and uses PGraphics styles and colors. Identical to ignoreStyles(true). Also disables styles for all child shapes.\n       */\n      disableStyle: function(){\n        this.style = false;\n        for(var i = 0, j=this.children.length; i<j; i++) {\n          this.children[i].disableStyle();\n        }\n      },\n      /**\n       * @member PShape\n       * The enableStyle() function enables the shape's style data and ignores Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.\n       */\n      enableStyle: function(){\n        this.style = true;\n        for(var i = 0, j=this.children.length; i<j; i++) {\n          this.children[i].enableStyle();\n        }\n      },\n      /**\n       * @member PShape\n       * The getFamily function returns the shape type\n       *\n       * @return {int} the shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY\n       */\n      getFamily: function(){\n        return this.family;\n      },\n      /**\n       * @member PShape\n       * The getWidth() function gets the width of the drawing area (not necessarily the shape boundary).\n       */\n      getWidth: function(){\n        return this.width;\n      },\n      /**\n       * @member PShape\n       * The getHeight() function gets the height of the drawing area (not necessarily the shape boundary).\n       */\n      getHeight: function(){\n        return this.height;\n      },\n      /**\n       * @member PShape\n       * The setName() function sets the name of the shape\n       *\n       * @param {String} name the name of the shape\n       */\n      setName: function(name){\n        this.name = name;\n      },\n      /**\n       * @member PShape\n       * The getName() function returns the name of the shape\n       *\n       * @return {String} the name of the shape\n       */\n      getName: function(){\n        return this.name;\n      },\n      /**\n       * @member PShape\n       * Called by the following (the shape() command adds the g)\n       * PShape s = loadShapes(\"blah.svg\");\n       * shape(s);\n       */\n      draw: function(renderContext) {\n        renderContext = renderContext || p;\n        if (this.visible) {\n          this.pre(renderContext);\n          this.drawImpl(renderContext);\n          this.post(renderContext);\n        }\n      },\n      /**\n       * @member PShape\n       * the drawImpl() function draws the SVG document.\n       */\n      drawImpl: function(renderContext) {\n        if (this.family === PConstants.GROUP) {\n          this.drawGroup(renderContext);\n        } else if (this.family === PConstants.PRIMITIVE) {\n          this.drawPrimitive(renderContext);\n        } else if (this.family === PConstants.GEOMETRY) {\n          this.drawGeometry(renderContext);\n        } else if (this.family === PConstants.PATH) {\n          this.drawPath(renderContext);\n        }\n      },\n      /**\n       * @member PShape\n       * The drawPath() function draws the <path> part of the SVG document.\n       */\n      drawPath: function(renderContext) {\n        var i, j;\n        if (this.vertices.length === 0) { return; }\n        renderContext.beginShape();\n        if (this.vertexCodes.length === 0) {  // each point is a simple vertex\n          if (this.vertices[0].length === 2) {  // drawing 2D vertices\n            for (i = 0, j = this.vertices.length; i < j; i++) {\n              renderContext.vertex(this.vertices[i][0], this.vertices[i][1]);\n            }\n          } else {  // drawing 3D vertices\n            for (i = 0, j = this.vertices.length; i < j; i++) {\n              renderContext.vertex(this.vertices[i][0],\n                                   this.vertices[i][1],\n                                   this.vertices[i][2]);\n            }\n          }\n        } else {  // coded set of vertices\n          var index = 0;\n          if (this.vertices[0].length === 2) {  // drawing a 2D path\n            for (i = 0, j = this.vertexCodes.length; i < j; i++) {\n              if (this.vertexCodes[i] === PConstants.VERTEX) {\n                renderContext.vertex(this.vertices[index][0], this.vertices[index][1], this.vertices[index][\"moveTo\"]);\n                renderContext.breakShape = false;\n                index++;\n              } else if (this.vertexCodes[i] === PConstants.BEZIER_VERTEX) {\n                renderContext.bezierVertex(this.vertices[index+0][0],\n                                           this.vertices[index+0][1],\n                                           this.vertices[index+1][0],\n                                           this.vertices[index+1][1],\n                                           this.vertices[index+2][0],\n                                           this.vertices[index+2][1]);\n                index += 3;\n              } else if (this.vertexCodes[i] === PConstants.CURVE_VERTEX) {\n                renderContext.curveVertex(this.vertices[index][0],\n                                          this.vertices[index][1]);\n                index++;\n              } else if (this.vertexCodes[i] ===  PConstants.BREAK) {\n                renderContext.breakShape = true;\n              }\n            }\n          } else {  // drawing a 3D path\n            for (i = 0, j = this.vertexCodes.length; i < j; i++) {\n              if (this.vertexCodes[i] === PConstants.VERTEX) {\n                renderContext.vertex(this.vertices[index][0],\n                                     this.vertices[index][1],\n                                     this.vertices[index][2]);\n                if (this.vertices[index][\"moveTo\"] === true) {\n                  vertArray[vertArray.length-1][\"moveTo\"] = true;\n                } else if (this.vertices[index][\"moveTo\"] === false) {\n                  vertArray[vertArray.length-1][\"moveTo\"] = false;\n                }\n                renderContext.breakShape = false;\n              } else if (this.vertexCodes[i] ===  PConstants.BEZIER_VERTEX) {\n                renderContext.bezierVertex(this.vertices[index+0][0],\n                                           this.vertices[index+0][1],\n                                           this.vertices[index+0][2],\n                                           this.vertices[index+1][0],\n                                           this.vertices[index+1][1],\n                                           this.vertices[index+1][2],\n                                           this.vertices[index+2][0],\n                                           this.vertices[index+2][1],\n                                           this.vertices[index+2][2]);\n                index += 3;\n              } else if (this.vertexCodes[i] === PConstants.CURVE_VERTEX) {\n                renderContext.curveVertex(this.vertices[index][0],\n                                          this.vertices[index][1],\n                                          this.vertices[index][2]);\n                index++;\n              } else if (this.vertexCodes[i] === PConstants.BREAK) {\n                renderContext.breakShape = true;\n              }\n            }\n          }\n        }\n        renderContext.endShape(this.close ? PConstants.CLOSE : PConstants.OPEN);\n      },\n      /**\n       * @member PShape\n       * The drawGeometry() function draws the geometry part of the SVG document.\n       */\n      drawGeometry: function(renderContext) {\n        var i, j;\n        renderContext.beginShape(this.kind);\n        if (this.style) {\n          for (i = 0, j = this.vertices.length; i < j; i++) {\n            renderContext.vertex(this.vertices[i]);\n          }\n        } else {\n          for (i = 0, j = this.vertices.length; i < j; i++) {\n            var vert = this.vertices[i];\n            if (vert[2] === 0) {\n              renderContext.vertex(vert[0], vert[1]);\n            } else {\n              renderContext.vertex(vert[0], vert[1], vert[2]);\n            }\n          }\n        }\n        renderContext.endShape();\n      },\n      /**\n       * @member PShape\n       * The drawGroup() function draws the <g> part of the SVG document.\n       */\n      drawGroup: function(renderContext) {\n        for (var i = 0, j = this.children.length; i < j; i++) {\n          this.children[i].draw(renderContext);\n        }\n      },\n      /**\n       * @member PShape\n       * The drawPrimitive() function draws SVG document shape elements. These can be point, line, triangle, quad, rect, ellipse, arc, box, or sphere.\n       */\n      drawPrimitive: function(renderContext) {\n        if (this.kind === PConstants.POINT) {\n          renderContext.point(this.params[0], this.params[1]);\n        } else if (this.kind === PConstants.LINE) {\n          if (this.params.length === 4) {  // 2D\n            renderContext.line(this.params[0], this.params[1],\n                              this.params[2], this.params[3]);\n          } else {  // 3D\n            renderContext.line(this.params[0], this.params[1], this.params[2],\n                               this.params[3], this.params[4], this.params[5]);\n          }\n        } else if (this.kind === PConstants.TRIANGLE) {\n          renderContext.triangle(this.params[0], this.params[1],\n                                 this.params[2], this.params[3],\n                                 this.params[4], this.params[5]);\n        } else if (this.kind === PConstants.QUAD) {\n          renderContext.quad(this.params[0], this.params[1],\n                             this.params[2], this.params[3],\n                             this.params[4], this.params[5],\n                             this.params[6], this.params[7]);\n        } else if (this.kind === PConstants.RECT) {\n          if (this.image !== null) {\n            var imMode = imageModeConvert;\n            renderContext.imageMode(PConstants.CORNER);\n            renderContext.image(this.image,\n                                this.params[0],\n                                this.params[1],\n                                this.params[2],\n                                this.params[3]);\n            imageModeConvert = imMode;\n          } else {\n            var rcMode = curRectMode;\n            renderContext.rectMode(PConstants.CORNER);\n            renderContext.rect(this.params[0],\n                               this.params[1],\n                               this.params[2],\n                               this.params[3]);\n            curRectMode = rcMode;\n          }\n        } else if (this.kind === PConstants.ELLIPSE) {\n          var elMode = curEllipseMode;\n          renderContext.ellipseMode(PConstants.CORNER);\n          renderContext.ellipse(this.params[0],\n                                this.params[1],\n                                this.params[2],\n                                this.params[3]);\n          curEllipseMode = elMode;\n        } else if (this.kind === PConstants.ARC) {\n          var eMode = curEllipseMode;\n          renderContext.ellipseMode(PConstants.CORNER);\n          renderContext.arc(this.params[0],\n                            this.params[1],\n                            this.params[2],\n                            this.params[3],\n                            this.params[4],\n                            this.params[5]);\n          curEllipseMode = eMode;\n        } else if (this.kind === PConstants.BOX) {\n          if (this.params.length === 1) {\n            renderContext.box(this.params[0]);\n          } else {\n            renderContext.box(this.params[0], this.params[1], this.params[2]);\n          }\n        } else if (this.kind === PConstants.SPHERE) {\n          renderContext.sphere(this.params[0]);\n        }\n      },\n      /**\n       * @member PShape\n       * The pre() function performs the preparations before the SVG is drawn. This includes doing transformations and storing previous styles.\n       */\n      pre: function(renderContext) {\n        if (this.matrix) {\n          renderContext.pushMatrix();\n          renderContext.transform(this.matrix);\n        }\n        if (this.style) {\n          renderContext.pushStyle();\n          this.styles(renderContext);\n        }\n      },\n      /**\n       * @member PShape\n       * The post() function performs the necessary actions after the SVG is drawn. This includes removing transformations and removing added styles.\n       */\n      post: function(renderContext) {\n        if (this.matrix) {\n          renderContext.popMatrix();\n        }\n        if (this.style) {\n          renderContext.popStyle();\n        }\n      },\n      /**\n       * @member PShape\n       * The styles() function changes the Processing's current styles\n       */\n      styles: function(renderContext) {\n        if (this.stroke) {\n          renderContext.stroke(this.strokeColor);\n          renderContext.strokeWeight(this.strokeWeight);\n          renderContext.strokeCap(this.strokeCap);\n          renderContext.strokeJoin(this.strokeJoin);\n        } else {\n          renderContext.noStroke();\n        }\n\n        if (this.fill) {\n          renderContext.fill(this.fillColor);\n\n        } else {\n          renderContext.noFill();\n        }\n      },\n      /**\n       * @member PShape\n       * The getChild() function extracts a child shape from a parent shape. Specify the name of the shape with the <b>target</b> parameter or the\n       * layer position of the shape to get with the <b>index</b> parameter.\n       * The shape is returned as a <b>PShape</b> object, or <b>null</b> is returned if there is an error.\n       *\n       * @param {String} target   the name of the shape to get\n       * @param {int} index   the layer position of the shape to get\n       *\n       * @return {PShape} returns a child element of a shape as a PShape object or null if there is an error\n       */\n      getChild: function(child) {\n        var i, j;\n        if (typeof child === 'number') {\n          return this.children[child];\n        }\n        var found;\n        if(child === \"\" || this.name === child){\n          return this;\n        }\n        if(this.nameTable.length > 0) {\n          for(i = 0, j = this.nameTable.length; i < j || found; i++) {\n            if(this.nameTable[i].getName === child) {\n              found = this.nameTable[i];\n              break;\n            }\n          }\n          if (found) { return found; }\n        }\n        for(i = 0, j = this.children.length; i < j; i++) {\n          found = this.children[i].getChild(child);\n          if(found) { return found; }\n        }\n        return null;\n      },\n      /**\n       * @member PShape\n       * The getChildCount() returns the number of children\n       *\n       * @return {int} returns a count of children\n       */\n      getChildCount: function () {\n        return this.children.length;\n      },\n      /**\n       * @member PShape\n       * The addChild() adds a child to the PShape.\n       *\n       * @param {PShape} child the child to add\n       */\n      addChild: function( child ) {\n        this.children.push(child);\n        child.parent = this;\n        if (child.getName() !== null) {\n          this.addName(child.getName(), child);\n        }\n      },\n      /**\n       * @member PShape\n       * The addName() functions adds a shape to the name lookup table.\n       *\n       * @param {String} name   the name to be added\n       * @param {PShape} shape  the shape\n       */\n      addName: function(name,  shape) {\n        if (this.parent !== null) {\n          this.parent.addName( name, shape );\n        } else {\n          this.nameTable.push( [name, shape] );\n        }\n      },\n      /**\n       * @member PShape\n       * The translate() function specifies an amount to displace the shape. The <b>x</b> parameter specifies left/right translation, the <b>y</b> parameter specifies up/down translation, and the <b>z</b> parameter specifies translations toward/away from the screen.\n       * Subsequent calls to the method accumulates the effect. For example, calling <b>translate(50, 0)</b> and then <b>translate(20, 0)</b> is the same as <b>translate(70, 0)</b>.\n       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n       * <br><br>Using this method with the <b>z</b> parameter requires using the P3D or OPENGL parameter in combination with size.\n       *\n       * @param {int|float} x left/right translation\n       * @param {int|float} y up/down translation\n       * @param {int|float} z forward/back translation\n       *\n       * @see PMatrix2D#translate\n       * @see PMatrix3D#translate\n       */\n      translate: function() {\n        if(arguments.length === 2)\n        {\n          this.checkMatrix(2);\n          this.matrix.translate(arguments[0], arguments[1]);\n        } else {\n          this.checkMatrix(3);\n          this.matrix.translate(arguments[0], arguments[1], 0);\n        }\n      },\n      /**\n       * @member PShape\n       * The checkMatrix() function makes sure that the shape's matrix is 1) not null, and 2) has a matrix\n       * that can handle <em>at least</em> the specified number of dimensions.\n       *\n       * @param {int} dimensions the specified number of dimensions\n       */\n      checkMatrix: function(dimensions) {\n        if(this.matrix === null) {\n          if(dimensions === 2) {\n            this.matrix = new p.PMatrix2D();\n          } else {\n            this.matrix = new p.PMatrix3D();\n          }\n        }else if(dimensions === 3 && this.matrix instanceof p.PMatrix2D) {\n          this.matrix = new p.PMatrix3D();\n        }\n      },\n      /**\n       * @member PShape\n       * The rotateX() function rotates a shape around the x-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n       * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n       * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateX(HALF_PI)</b> and then <b>rotateX(HALF_PI)</b> is the same as <b>rotateX(PI)</b>.\n       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n       * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.\n       *\n       * @param {float}angle angle of rotation specified in radians\n       *\n       * @see PMatrix3D#rotateX\n       */\n      rotateX: function(angle) {\n        this.rotate(angle, 1, 0, 0);\n      },\n      /**\n       * @member PShape\n       * The rotateY() function rotates a shape around the y-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n       * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n       * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateY(HALF_PI)</b> and then <b>rotateY(HALF_PI)</b> is the same as <b>rotateY(PI)</b>.\n       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n       * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.\n       *\n       * @param {float}angle angle of rotation specified in radians\n       *\n       * @see PMatrix3D#rotateY\n       */\n      rotateY: function(angle) {\n        this.rotate(angle, 0, 1, 0);\n      },\n      /**\n       * @member PShape\n       * The rotateZ() function rotates a shape around the z-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n       * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n       * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateZ(HALF_PI)</b> and then <b>rotateZ(HALF_PI)</b> is the same as <b>rotateZ(PI)</b>.\n       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n       * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.\n       *\n       * @param {float}angle angle of rotation specified in radians\n       *\n       * @see PMatrix3D#rotateZ\n       */\n      rotateZ: function(angle) {\n        this.rotate(angle, 0, 0, 1);\n      },\n      /**\n       * @member PShape\n       * The rotate() function rotates a shape the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n       * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n       * Transformations apply to everything that happens after and subsequent calls to the method accumulates the effect.\n       * For example, calling <b>rotate(HALF_PI)</b> and then <b>rotate(HALF_PI)</b> is the same as <b>rotate(PI)</b>.\n       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n       * If optional parameters x,y,z are supplied, the rotate is about the point (x, y, z).\n       *\n       * @param {float}angle  angle of rotation specified in radians\n       * @param {float}x      x-coordinate of the point\n       * @param {float}y      y-coordinate of the point\n       * @param {float}z      z-coordinate of the point\n       * @see PMatrix2D#rotate\n       * @see PMatrix3D#rotate\n       */\n      rotate: function() {\n        if(arguments.length === 1){\n          this.checkMatrix(2);\n          this.matrix.rotate(arguments[0]);\n        } else {\n          this.checkMatrix(3);\n          this.matrix.rotate(arguments[0],\n                             arguments[1],\n                             arguments[2],\n                             arguments[3]);\n        }\n      },\n      /**\n       * @member PShape\n       * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. Shapes always scale from the relative origin of their bounding box.\n       * Scale values are specified as decimal percentages. For example, the method call <b>scale(2.0)</b> increases the dimension of a shape by 200%.\n       * Subsequent calls to the method multiply the effect. For example, calling <b>scale(2.0)</b> and then <b>scale(1.5)</b> is the same as <b>scale(3.0)</b>.\n       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n       * <br><br>Using this fuction with the <b>z</b> parameter requires passing P3D or OPENGL into the size() parameter.\n       *\n       * @param {float}s      percentage to scale the object\n       * @param {float}x      percentage to scale the object in the x-axis\n       * @param {float}y      percentage to scale the object in the y-axis\n       * @param {float}z      percentage to scale the object in the z-axis\n       *\n       * @see PMatrix2D#scale\n       * @see PMatrix3D#scale\n       */\n      scale: function() {\n        if(arguments.length === 2) {\n          this.checkMatrix(2);\n          this.matrix.scale(arguments[0], arguments[1]);\n        } else if (arguments.length === 3) {\n          this.checkMatrix(2);\n          this.matrix.scale(arguments[0], arguments[1], arguments[2]);\n        } else {\n          this.checkMatrix(2);\n          this.matrix.scale(arguments[0]);\n        }\n      },\n      /**\n       * @member PShape\n       * The resetMatrix() function resets the matrix\n       *\n       * @see PMatrix2D#reset\n       * @see PMatrix3D#reset\n       */\n      resetMatrix: function() {\n        this.checkMatrix(2);\n        this.matrix.reset();\n      },\n      /**\n       * @member PShape\n       * The applyMatrix() function multiplies this matrix by another matrix of type PMatrix3D or PMatrix2D.\n       * Individual elements can also be provided\n       *\n       * @param {PMatrix3D|PMatrix2D} matrix   the matrix to multiply by\n       *\n       * @see PMatrix2D#apply\n       * @see PMatrix3D#apply\n       */\n      applyMatrix: function(matrix) {\n        if (arguments.length === 1) {\n          this.applyMatrix(matrix.elements[0],\n                           matrix.elements[1], 0,\n                           matrix.elements[2],\n                           matrix.elements[3],\n                           matrix.elements[4], 0,\n                           matrix.elements[5],\n                           0, 0, 1, 0,\n                           0, 0, 0, 1);\n        } else if (arguments.length === 6) {\n          this.checkMatrix(2);\n          this.matrix.apply(arguments[0], arguments[1], arguments[2], 0,\n                            arguments[3], arguments[4], arguments[5], 0,\n                            0,   0,   1,   0,\n                            0,   0,   0,   1);\n\n        } else if (arguments.length === 16) {\n          this.checkMatrix(3);\n          this.matrix.apply(arguments[0],\n                            arguments[1],\n                            arguments[2],\n                            arguments[3],\n                            arguments[4],\n                            arguments[5],\n                            arguments[6],\n                            arguments[7],\n                            arguments[8],\n                            arguments[9],\n                            arguments[10],\n                            arguments[11],\n                            arguments[12],\n                            arguments[13],\n                            arguments[14],\n                            arguments[15]);\n        }\n      }\n    };\n\n    /**\n     * SVG stands for Scalable Vector Graphics, a portable graphics format. It is\n     * a vector format so it allows for infinite resolution and relatively small\n     * file sizes. Most modern media software can view SVG files, including Adobe\n     * products, Firefox, etc. Illustrator and Inkscape can edit SVG files.\n     *\n     * @param {PApplet} parent     typically use \"this\"\n     * @param {String} filename    name of the SVG file to load\n     * @param {XMLElement} xml     an XMLElement element\n     * @param {PShapeSVG} parent   the parent PShapeSVG\n     *\n     * @see PShape\n     */\n    var PShapeSVG = p.PShapeSVG = function() {\n      p.PShape.call( this ); // PShape is the base class.\n      if (arguments.length === 1) { //xml element coming in\n        this.element  = arguments[0] ;//new p.XMLElement(null, arguments[0]);\n        // set values to their defaults according to the SVG spec\n        this.vertexCodes         = [];\n        this.vertices            = [];\n        this.opacity             = 1;\n\n        this.stroke              = false;\n        this.strokeColor         = PConstants.ALPHA_MASK;\n        this.strokeWeight        = 1;\n        this.strokeCap           = PConstants.SQUARE;  // BUTT in svg spec\n        this.strokeJoin          = PConstants.MITER;\n        this.strokeGradient      = null;\n        this.strokeGradientPaint = null;\n        this.strokeName          = null;\n        this.strokeOpacity       = 1;\n\n        this.fill                = true;\n        this.fillColor           = PConstants.ALPHA_MASK;\n        this.fillGradient        = null;\n        this.fillGradientPaint   = null;\n        this.fillName            = null;\n        this.fillOpacity         = 1;\n\n        if (this.element.getName() !== \"svg\") {\n          throw(\"root is not <svg>, it's <\" + this.element.getName() + \">\");\n        }\n      }\n      else if (arguments.length === 2) {\n        if (typeof arguments[1] === 'string') {\n          if (arguments[1].indexOf(\".svg\") > -1) { //its a filename\n            this.element = new p.XMLElement(p, arguments[1]);\n            // set values to their defaults according to the SVG spec\n            this.vertexCodes         = [];\n            this.vertices            = [];\n            this.opacity             = 1;\n\n            this.stroke              = false;\n            this.strokeColor         = PConstants.ALPHA_MASK;\n            this.strokeWeight        = 1;\n            this.strokeCap           = PConstants.SQUARE;  // BUTT in svg spec\n            this.strokeJoin          = PConstants.MITER;\n            this.strokeGradient      = \"\";\n            this.strokeGradientPaint = \"\";\n            this.strokeName          = \"\";\n            this.strokeOpacity       = 1;\n\n            this.fill                = true;\n            this.fillColor           = PConstants.ALPHA_MASK;\n            this.fillGradient        = null;\n            this.fillGradientPaint   = null;\n            this.fillOpacity         = 1;\n\n          }\n        } else { // XMLElement\n          if (arguments[0]) { // PShapeSVG\n            this.element             = arguments[1];\n            this.vertexCodes         = arguments[0].vertexCodes.slice();\n            this.vertices            = arguments[0].vertices.slice();\n\n            this.stroke              = arguments[0].stroke;\n            this.strokeColor         = arguments[0].strokeColor;\n            this.strokeWeight        = arguments[0].strokeWeight;\n            this.strokeCap           = arguments[0].strokeCap;\n            this.strokeJoin          = arguments[0].strokeJoin;\n            this.strokeGradient      = arguments[0].strokeGradient;\n            this.strokeGradientPaint = arguments[0].strokeGradientPaint;\n            this.strokeName          = arguments[0].strokeName;\n\n            this.fill                = arguments[0].fill;\n            this.fillColor           = arguments[0].fillColor;\n            this.fillGradient        = arguments[0].fillGradient;\n            this.fillGradientPaint   = arguments[0].fillGradientPaint;\n            this.fillName            = arguments[0].fillName;\n            this.strokeOpacity       = arguments[0].strokeOpacity;\n            this.fillOpacity         = arguments[0].fillOpacity;\n            this.opacity             = arguments[0].opacity;\n          }\n        }\n      }\n\n      this.name      = this.element.getStringAttribute(\"id\");\n      var displayStr = this.element.getStringAttribute(\"display\", \"inline\");\n      this.visible   = displayStr !== \"none\";\n      var str = this.element.getAttribute(\"transform\");\n      if (str) {\n        this.matrix = this.parseMatrix(str);\n      }\n      // not proper parsing of the viewBox, but will cover us for cases where\n      // the width and height of the object is not specified\n      var viewBoxStr = this.element.getStringAttribute(\"viewBox\");\n      if ( viewBoxStr !== null ) {\n        var viewBox = viewBoxStr.split(\" \");\n        this.width  = viewBox[2];\n        this.height = viewBox[3];\n      }\n\n      // TODO if viewbox is not same as width/height, then use it to scale\n      // the original objects. for now, viewbox only used when width/height\n      // are empty values (which by the spec means w/h of \"100%\"\n      var unitWidth  = this.element.getStringAttribute(\"width\");\n      var unitHeight = this.element.getStringAttribute(\"height\");\n      if (unitWidth !== null) {\n        this.width  = this.parseUnitSize(unitWidth);\n        this.height = this.parseUnitSize(unitHeight);\n      } else {\n        if ((this.width === 0) || (this.height === 0)) {\n          // For the spec, the default is 100% and 100%. For purposes\n          // here, insert a dummy value because this is prolly just a\n          // font or something for which the w/h doesn't matter.\n          this.width  = 1;\n          this.height = 1;\n\n          //show warning\n          throw(\"The width and/or height is not \" +\n                \"readable in the <svg> tag of this file.\");\n        }\n      }\n      this.parseColors(this.element);\n      this.parseChildren(this.element);\n\n    };\n    /**\n     * PShapeSVG methods\n     * missing: getChild(), print(), parseStyleAttributes(), styles() - deals with strokeGradient and fillGradient\n     */\n    PShapeSVG.prototype = new PShape();\n    /**\n     * @member PShapeSVG\n     * The parseMatrix() function parses the specified SVG matrix into a PMatrix2D. Note that PMatrix2D\n     * is rotated relative to the SVG definition, so parameters are rearranged\n     * here. More about the transformation matrices in\n     * <a href=\"http://www.w3.org/TR/SVG/coords.html#TransformAttribute\">this section</a>\n     * of the SVG documentation.\n     *\n     * @param {String} str text of the matrix param.\n     *\n     * @return {PMatrix2D} a PMatrix2D\n     */\n    PShapeSVG.prototype.parseMatrix = (function() {\n      function getCoords(s) {\n        var m = [];\n        s.replace(/\\((.*?)\\)/, (function() {\n          return function(all, params) {\n            // get the coordinates that can be separated by spaces or a comma\n            m = params.replace(/,+/g, \" \").split(/\\s+/);\n          };\n        }()));\n        return m;\n      }\n\n      return function(str) {\n        this.checkMatrix(2);\n        var pieces = [];\n        str.replace(/\\s*(\\w+)\\((.*?)\\)/g, function(all) {\n          // get a list of transform definitions\n          pieces.push(p.trim(all));\n        });\n        if (pieces.length === 0) {\n          return null;\n        }\n\n        for (var i = 0, j = pieces.length; i < j; i++) {\n          var m = getCoords(pieces[i]);\n\n          if (pieces[i].indexOf(\"matrix\") !== -1) {\n            this.matrix.set(m[0], m[2], m[4], m[1], m[3], m[5]);\n          } else if (pieces[i].indexOf(\"translate\") !== -1) {\n            var tx = m[0];\n            var ty = (m.length === 2) ? m[1] : 0;\n            this.matrix.translate(tx,ty);\n          } else if (pieces[i].indexOf(\"scale\") !== -1) {\n            var sx = m[0];\n            var sy = (m.length === 2) ? m[1] : m[0];\n            this.matrix.scale(sx,sy);\n          } else if (pieces[i].indexOf(\"rotate\") !== -1) {\n            var angle = m[0];\n            if (m.length === 1) {\n              this.matrix.rotate(p.radians(angle));\n            } else if (m.length === 3) {\n              this.matrix.translate(m[1], m[2]);\n              this.matrix.rotate(p.radians(m[0]));\n              this.matrix.translate(-m[1], -m[2]);\n            }\n          } else if (pieces[i].indexOf(\"skewX\") !== -1) {\n            this.matrix.skewX(parseFloat(m[0]));\n          } else if (pieces[i].indexOf(\"skewY\") !== -1) {\n            this.matrix.skewY(m[0]);\n          } else if (pieces[i].indexOf(\"shearX\") !== -1) {\n            this.matrix.shearX(m[0]);\n          } else if (pieces[i].indexOf(\"shearY\") !== -1) {\n            this.matrix.shearY(m[0]);\n          }\n        }\n        return this.matrix;\n      };\n    }());\n\n    /**\n     * @member PShapeSVG\n     * The parseChildren() function parses the specified XMLElement\n     *\n     * @param {XMLElement}element the XMLElement to parse\n     */\n    PShapeSVG.prototype.parseChildren = function(element) {\n      var newelement = element.getChildren();\n      var children   = new p.PShape();\n      for (var i = 0, j = newelement.length; i < j; i++) {\n        var kid = this.parseChild(newelement[i]);\n        if (kid) {\n          children.addChild(kid);\n        }\n      }\n      this.children.push(children);\n    };\n    /**\n     * @member PShapeSVG\n     * The getName() function returns the name\n     *\n     * @return {String} the name\n     */\n    PShapeSVG.prototype.getName = function() {\n      return this.name;\n    };\n    /**\n     * @member PShapeSVG\n     * The parseChild() function parses a child XML element.\n     *\n     * @param {XMLElement} elem the element to parse\n     *\n     * @return {PShape} the newly created PShape\n     */\n    PShapeSVG.prototype.parseChild = function( elem ) {\n      var name = elem.getName();\n      var shape;\n      if (name === \"g\") {\n        shape = new PShapeSVG(this, elem);\n      } else if (name === \"defs\") {\n        // generally this will contain gradient info, so may\n        // as well just throw it into a group element for parsing\n        shape = new PShapeSVG(this, elem);\n      } else if (name === \"line\") {\n        shape = new PShapeSVG(this, elem);\n        shape.parseLine();\n      } else if (name === \"circle\") {\n        shape = new PShapeSVG(this, elem);\n        shape.parseEllipse(true);\n      } else if (name === \"ellipse\") {\n        shape = new PShapeSVG(this, elem);\n        shape.parseEllipse(false);\n      } else if (name === \"rect\") {\n        shape = new PShapeSVG(this, elem);\n        shape.parseRect();\n      } else if (name === \"polygon\") {\n        shape = new PShapeSVG(this, elem);\n        shape.parsePoly(true);\n      } else if (name === \"polyline\") {\n        shape = new PShapeSVG(this, elem);\n        shape.parsePoly(false);\n      } else if (name === \"path\") {\n        shape = new PShapeSVG(this, elem);\n        shape.parsePath();\n      } else if (name === \"radialGradient\") {\n        //return new RadialGradient(this, elem);\n        unimplemented('PShapeSVG.prototype.parseChild, name = radialGradient');\n      } else if (name === \"linearGradient\") {\n        //return new LinearGradient(this, elem);\n        unimplemented('PShapeSVG.prototype.parseChild, name = linearGradient');\n      } else if (name === \"text\") {\n        unimplemented('PShapeSVG.prototype.parseChild, name = text');\n      } else if (name === \"filter\") {\n        unimplemented('PShapeSVG.prototype.parseChild, name = filter');\n      } else if (name === \"mask\") {\n        unimplemented('PShapeSVG.prototype.parseChild, name = mask');\n      } else {\n        // ignoring\n        nop();\n      }\n      return shape;\n    };\n    /**\n     * @member PShapeSVG\n     * The parsePath() function parses the <path> element of the svg file\n     * A path is defined by including a path element which contains a d=\"(path data)\" attribute, where the d attribute contains\n     * the moveto, line, curve (both cubic and quadratic Beziers), arc and closepath instructions.\n     **/\n    PShapeSVG.prototype.parsePath = function() {\n      this.family = PConstants.PATH;\n      this.kind = 0;\n      var pathDataChars = [];\n      var c;\n      //change multiple spaces and commas to single space\n      var pathData = p.trim(this.element.getStringAttribute(\"d\")\n                            .replace(/[\\s,]+/g,' '));\n      if (pathData === null) {\n        return;\n      }\n      pathData = p.__toCharArray(pathData);\n      var cx     = 0,\n          cy     = 0,\n          ctrlX  = 0,\n          ctrlY  = 0,\n          ctrlX1 = 0,\n          ctrlX2 = 0,\n          ctrlY1 = 0,\n          ctrlY2 = 0,\n          endX   = 0,\n          endY   = 0,\n          ppx    = 0,\n          ppy    = 0,\n          px     = 0,\n          py     = 0,\n          i      = 0,\n          valOf  = 0;\n      var str = \"\";\n      var tmpArray =[];\n      var flag = false;\n      var lastInstruction;\n      var command;\n      var j, k;\n      while (i< pathData.length) {\n        valOf = pathData[i].valueOf();\n        if ((valOf >= 65 && valOf <= 90) || (valOf >= 97 && valOf <= 122)) {\n          // if it's a letter\n          // populate the tmpArray with coordinates\n          j = i;\n          i++;\n          if (i < pathData.length) { // don't go over boundary of array\n            tmpArray = [];\n            valOf = pathData[i].valueOf();\n            while (!((valOf >= 65 && valOf <= 90) ||\n                     (valOf >= 97 && valOf <= 100) ||\n                     (valOf >= 102 && valOf <= 122))\n                     && flag === false) { // if its NOT a letter\n              if (valOf === 32) { //if its a space and the str isn't empty\n                // sometimes you get a space after the letter\n                if (str !== \"\") {\n                  tmpArray.push(parseFloat(str));\n                  str = \"\";\n                }\n                i++;\n              } else if (valOf === 45) { //if it's a -\n                // allow for 'e' notation in numbers, e.g. 2.10e-9\n                if (pathData[i-1].valueOf() === 101) {\n                  str += pathData[i].toString();\n                  i++;\n                } else {\n                  // sometimes no space separator after (ex: 104.535-16.322)\n                  if (str !== \"\") {\n                    tmpArray.push(parseFloat(str));\n                  }\n                  str = pathData[i].toString();\n                  i++;\n                }\n              } else {\n                str += pathData[i].toString();\n                i++;\n              }\n              if (i === pathData.length) { // don't go over boundary of array\n                flag = true;\n              } else {\n                valOf = pathData[i].valueOf();\n              }\n            }\n          }\n          if (str !== \"\") {\n            tmpArray.push(parseFloat(str));\n            str = \"\";\n          }\n          command = pathData[j];\n          valOf = command.valueOf();\n          if (valOf === 77) {  // M - move to (absolute)\n            if (tmpArray.length >= 2 && tmpArray.length % 2 ===0) {\n              // need one+ pairs of co-ordinates\n              cx = tmpArray[0];\n              cy = tmpArray[1];\n              this.parsePathMoveto(cx, cy);\n              if (tmpArray.length > 2) {\n                for (j = 2, k = tmpArray.length; j < k; j+=2) {\n                  // absolute line to\n                  cx = tmpArray[j];\n                  cy = tmpArray[j+1];\n                  this.parsePathLineto(cx,cy);\n                }\n              }\n            }\n          } else if (valOf === 109) {  // m - move to (relative)\n            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n              // need one+ pairs of co-ordinates\n              cx += tmpArray[0];\n              cy += tmpArray[1];\n              this.parsePathMoveto(cx,cy);\n              if (tmpArray.length > 2) {\n                for (j = 2, k = tmpArray.length; j < k; j+=2) {\n                  // relative line to\n                  cx += tmpArray[j];\n                  cy += tmpArray[j + 1];\n                  this.parsePathLineto(cx,cy);\n                }\n              }\n            }\n          } else if (valOf === 76) { // L - lineto (absolute)\n            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n              // need one+ pairs of co-ordinates\n              for (j = 0, k = tmpArray.length; j < k; j+=2) {\n                cx = tmpArray[j];\n                cy = tmpArray[j + 1];\n                this.parsePathLineto(cx,cy);\n              }\n            }\n          } else if (valOf === 108) { // l - lineto (relative)\n            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n              // need one+ pairs of co-ordinates\n              for (j = 0, k = tmpArray.length; j < k; j+=2) {\n                cx += tmpArray[j];\n                cy += tmpArray[j+1];\n                this.parsePathLineto(cx,cy);\n              }\n            }\n          } else if (valOf === 72) { // H - horizontal lineto (absolute)\n            for (j = 0, k = tmpArray.length; j < k; j++) {\n              // multiple x co-ordinates can be provided\n              cx = tmpArray[j];\n              this.parsePathLineto(cx, cy);\n            }\n          } else if (valOf === 104) { // h - horizontal lineto (relative)\n            for (j = 0, k = tmpArray.length; j < k; j++) {\n              // multiple x co-ordinates can be provided\n              cx += tmpArray[j];\n              this.parsePathLineto(cx, cy);\n            }\n          } else if (valOf === 86) { // V - vertical lineto (absolute)\n            for (j = 0, k = tmpArray.length; j < k; j++) {\n              // multiple y co-ordinates can be provided\n              cy = tmpArray[j];\n              this.parsePathLineto(cx, cy);\n            }\n          } else if (valOf === 118) { // v - vertical lineto (relative)\n            for (j = 0, k = tmpArray.length; j < k; j++) {\n              // multiple y co-ordinates can be provided\n              cy += tmpArray[j];\n              this.parsePathLineto(cx, cy);\n            }\n          } else if (valOf === 67) { // C - curve to (absolute)\n            if (tmpArray.length >= 6 && tmpArray.length % 6 === 0) {\n              // need one+ multiples of 6 co-ordinates\n              for (j = 0, k = tmpArray.length; j < k; j+=6) {\n                ctrlX1 = tmpArray[j];\n                ctrlY1 = tmpArray[j + 1];\n                ctrlX2 = tmpArray[j + 2];\n                ctrlY2 = tmpArray[j + 3];\n                endX   = tmpArray[j + 4];\n                endY   = tmpArray[j + 5];\n                this.parsePathCurveto(ctrlX1,\n                                      ctrlY1,\n                                      ctrlX2,\n                                      ctrlY2,\n                                      endX,\n                                      endY);\n                cx = endX;\n                cy = endY;\n              }\n            }\n          } else if (valOf === 99) { // c - curve to (relative)\n            if (tmpArray.length >= 6 && tmpArray.length % 6 === 0) {\n              // need one+ multiples of 6 co-ordinates\n              for (j = 0, k = tmpArray.length; j < k; j+=6) {\n                ctrlX1 = cx + tmpArray[j];\n                ctrlY1 = cy + tmpArray[j + 1];\n                ctrlX2 = cx + tmpArray[j + 2];\n                ctrlY2 = cy + tmpArray[j + 3];\n                endX   = cx + tmpArray[j + 4];\n                endY   = cy + tmpArray[j + 5];\n                this.parsePathCurveto(ctrlX1,\n                                      ctrlY1,\n                                      ctrlX2,\n                                      ctrlY2,\n                                      endX,\n                                      endY);\n                cx = endX;\n                cy = endY;\n              }\n            }\n          } else if (valOf === 83) { // S - curve to shorthand (absolute)\n            if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {\n              // need one+ multiples of 4 co-ordinates\n              for (j = 0, k = tmpArray.length; j < k; j+=4) {\n                if (lastInstruction.toLowerCase() ===  \"c\" ||\n                    lastInstruction.toLowerCase() ===  \"s\") {\n                  ppx    = this.vertices[ this.vertices.length-2 ][0];\n                  ppy    = this.vertices[ this.vertices.length-2 ][1];\n                  px     = this.vertices[ this.vertices.length-1 ][0];\n                  py     = this.vertices[ this.vertices.length-1 ][1];\n                  ctrlX1 = px + (px - ppx);\n                  ctrlY1 = py + (py - ppy);\n                } else {\n                  //If there is no previous curve,\n                  //the current point will be used as the first control point.\n                  ctrlX1 = this.vertices[this.vertices.length-1][0];\n                  ctrlY1 = this.vertices[this.vertices.length-1][1];\n                }\n                ctrlX2 = tmpArray[j];\n                ctrlY2 = tmpArray[j + 1];\n                endX   = tmpArray[j + 2];\n                endY   = tmpArray[j + 3];\n                this.parsePathCurveto(ctrlX1,\n                                      ctrlY1,\n                                      ctrlX2,\n                                      ctrlY2,\n                                      endX,\n                                      endY);\n                cx = endX;\n                cy = endY;\n              }\n            }\n          } else if (valOf === 115) { // s - curve to shorthand (relative)\n            if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {\n              // need one+ multiples of 4 co-ordinates\n              for (j = 0, k = tmpArray.length; j < k; j+=4) {\n                if (lastInstruction.toLowerCase() ===  \"c\" ||\n                    lastInstruction.toLowerCase() ===  \"s\") {\n                  ppx    = this.vertices[this.vertices.length-2][0];\n                  ppy    = this.vertices[this.vertices.length-2][1];\n                  px     = this.vertices[this.vertices.length-1][0];\n                  py     = this.vertices[this.vertices.length-1][1];\n                  ctrlX1 = px + (px - ppx);\n                  ctrlY1 = py + (py - ppy);\n                } else {\n                  //If there is no previous curve,\n                  //the current point will be used as the first control point.\n                  ctrlX1 = this.vertices[this.vertices.length-1][0];\n                  ctrlY1 = this.vertices[this.vertices.length-1][1];\n                }\n                ctrlX2 = cx + tmpArray[j];\n                ctrlY2 = cy + tmpArray[j + 1];\n                endX   = cx + tmpArray[j + 2];\n                endY   = cy + tmpArray[j + 3];\n                this.parsePathCurveto(ctrlX1,\n                                      ctrlY1,\n                                      ctrlX2,\n                                      ctrlY2,\n                                      endX,\n                                      endY);\n                cx = endX;\n                cy = endY;\n              }\n            }\n          } else if (valOf === 81) { // Q - quadratic curve to (absolute)\n            if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {\n              // need one+ multiples of 4 co-ordinates\n              for (j = 0, k = tmpArray.length; j < k; j+=4) {\n                ctrlX = tmpArray[j];\n                ctrlY = tmpArray[j + 1];\n                endX  = tmpArray[j + 2];\n                endY  = tmpArray[j + 3];\n                this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n                cx = endX;\n                cy = endY;\n              }\n            }\n          } else if (valOf === 113) { // q - quadratic curve to (relative)\n            if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {\n              // need one+ multiples of 4 co-ordinates\n              for (j = 0, k = tmpArray.length; j < k; j+=4) {\n                ctrlX = cx + tmpArray[j];\n                ctrlY = cy + tmpArray[j + 1];\n                endX  = cx + tmpArray[j + 2];\n                endY  = cy + tmpArray[j + 3];\n                this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n                cx = endX;\n                cy = endY;\n              }\n            }\n          } else if (valOf === 84) {\n            // T - quadratic curve to shorthand (absolute)\n            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n              // need one+ pairs of co-ordinates\n              for (j = 0, k = tmpArray.length; j < k; j+=2) {\n                if (lastInstruction.toLowerCase() ===  \"q\" ||\n                    lastInstruction.toLowerCase() ===  \"t\") {\n                  ppx   = this.vertices[this.vertices.length-2][0];\n                  ppy   = this.vertices[this.vertices.length-2][1];\n                  px    = this.vertices[this.vertices.length-1][0];\n                  py    = this.vertices[this.vertices.length-1][1];\n                  ctrlX = px + (px - ppx);\n                  ctrlY = py + (py - ppy);\n                } else {\n                  // If there is no previous command or if the previous command\n                  // was not a Q, q, T or t, assume the control point is\n                  // coincident with the current point.\n                  ctrlX = cx;\n                  ctrlY = cy;\n                }\n                endX  = tmpArray[j];\n                endY  = tmpArray[j + 1];\n                this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n                cx = endX;\n                cy = endY;\n              }\n            }\n          } else if (valOf === 116) {\n            // t - quadratic curve to shorthand (relative)\n            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n              // need one+ pairs of co-ordinates\n              for (j = 0, k = tmpArray.length; j < k; j+=2) {\n                if (lastInstruction.toLowerCase() ===  \"q\" ||\n                    lastInstruction.toLowerCase() ===  \"t\") {\n                  ppx   = this.vertices[this.vertices.length-2][0];\n                  ppy   = this.vertices[this.vertices.length-2][1];\n                  px    = this.vertices[this.vertices.length-1][0];\n                  py    = this.vertices[this.vertices.length-1][1];\n                  ctrlX = px + (px - ppx);\n                  ctrlY = py + (py - ppy);\n                } else {\n                  // If there is no previous command or if the previous command\n                  // was not a Q, q, T or t, assume the control point is\n                  // coincident with the current point.\n                  ctrlX = cx;\n                  ctrlY = cy;\n                }\n                endX  = cx + tmpArray[j];\n                endY  = cy + tmpArray[j + 1];\n                this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n                cx = endX;\n                cy = endY;\n              }\n            }\n          } else if (valOf === 90 || valOf === 122) { // Z or z (these do the same thing)\n            this.close = true;\n          }\n          lastInstruction = command.toString();\n        } else { i++;}\n      }\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parsePath() helper function\n     *\n     * @see PShapeSVG#parsePath\n     */\n    PShapeSVG.prototype.parsePathQuadto = function(x1, y1, cx, cy, x2, y2) {\n      if (this.vertices.length > 0) {\n        this.parsePathCode(PConstants.BEZIER_VERTEX);\n        // x1/y1 already covered by last moveto, lineto, or curveto\n        this.parsePathVertex(x1 + ((cx-x1)*2/3), y1 + ((cy-y1)*2/3));\n        this.parsePathVertex(x2 + ((cx-x2)*2/3), y2 + ((cy-y2)*2/3));\n        this.parsePathVertex(x2, y2);\n      } else {\n        throw (\"Path must start with M/m\");\n      }\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parsePath() helper function\n     *\n     * @see PShapeSVG#parsePath\n     */\n    PShapeSVG.prototype.parsePathCurveto = function(x1,  y1, x2, y2, x3, y3) {\n      if (this.vertices.length > 0) {\n        this.parsePathCode(PConstants.BEZIER_VERTEX );\n        this.parsePathVertex(x1, y1);\n        this.parsePathVertex(x2, y2);\n        this.parsePathVertex(x3, y3);\n      } else {\n        throw (\"Path must start with M/m\");\n      }\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parsePath() helper function\n     *\n     * @see PShapeSVG#parsePath\n     */\n    PShapeSVG.prototype.parsePathLineto = function(px, py) {\n      if (this.vertices.length > 0) {\n        this.parsePathCode(PConstants.VERTEX);\n        this.parsePathVertex(px, py);\n        // add property to distinguish between curContext.moveTo\n        // or curContext.lineTo\n        this.vertices[this.vertices.length-1][\"moveTo\"] = false;\n      } else {\n        throw (\"Path must start with M/m\");\n      }\n    };\n\n    PShapeSVG.prototype.parsePathMoveto = function(px, py) {\n      if (this.vertices.length > 0) {\n        this.parsePathCode(PConstants.BREAK);\n      }\n      this.parsePathCode(PConstants.VERTEX);\n      this.parsePathVertex(px, py);\n      // add property to distinguish between curContext.moveTo\n      // or curContext.lineTo\n      this.vertices[this.vertices.length-1][\"moveTo\"] = true;\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parsePath() helper function\n     *\n     * @see PShapeSVG#parsePath\n     */\n    PShapeSVG.prototype.parsePathVertex = function(x,  y) {\n      var verts = [];\n      verts[0]  = x;\n      verts[1]  = y;\n      this.vertices.push(verts);\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parsePath() helper function\n     *\n     * @see PShapeSVG#parsePath\n     */\n    PShapeSVG.prototype.parsePathCode = function(what) {\n      this.vertexCodes.push(what);\n    };\n    /**\n     * @member PShapeSVG\n     * The parsePoly() function parses a polyline or polygon from an SVG file.\n     *\n     * @param {boolean}val true if shape is closed (polygon), false if not (polyline)\n     */\n    PShapeSVG.prototype.parsePoly = function(val) {\n      this.family    = PConstants.PATH;\n      this.close     = val;\n      var pointsAttr = p.trim(this.element.getStringAttribute(\"points\")\n                              .replace(/[,\\s]+/g,' '));\n      if (pointsAttr !== null) {\n        //split into array\n        var pointsBuffer = pointsAttr.split(\" \");\n        if (pointsBuffer.length % 2 === 0) {\n          for (var i = 0, j = pointsBuffer.length; i < j; i++) {\n            var verts = [];\n            verts[0]  = pointsBuffer[i];\n            verts[1]  = pointsBuffer[++i];\n            this.vertices.push(verts);\n          }\n        } else {\n          throw(\"Error parsing polygon points: odd number of coordinates provided\");\n        }\n      }\n    };\n    /**\n     * @member PShapeSVG\n     * The parseRect() function parses a rect from an SVG file.\n     */\n    PShapeSVG.prototype.parseRect = function() {\n      this.kind      = PConstants.RECT;\n      this.family    = PConstants.PRIMITIVE;\n      this.params    = [];\n      this.params[0] = this.element.getFloatAttribute(\"x\");\n      this.params[1] = this.element.getFloatAttribute(\"y\");\n      this.params[2] = this.element.getFloatAttribute(\"width\");\n      this.params[3] = this.element.getFloatAttribute(\"height\");\n      if (this.params[2] < 0 || this.params[3] < 0) {\n        throw(\"svg error: negative width or height found while parsing <rect>\");\n      }\n    };\n    /**\n     * @member PShapeSVG\n     * The parseEllipse() function handles parsing ellipse and circle tags.\n     *\n     * @param {boolean}val true if this is a circle and not an ellipse\n     */\n    PShapeSVG.prototype.parseEllipse = function(val) {\n      this.kind   = PConstants.ELLIPSE;\n      this.family = PConstants.PRIMITIVE;\n      this.params = [];\n\n      this.params[0] = this.element.getFloatAttribute(\"cx\") | 0 ;\n      this.params[1] = this.element.getFloatAttribute(\"cy\") | 0;\n\n      var rx, ry;\n      if (val) {\n        rx = ry = this.element.getFloatAttribute(\"r\");\n        if (rx < 0) {\n          throw(\"svg error: negative radius found while parsing <circle>\");\n        }\n      } else {\n        rx = this.element.getFloatAttribute(\"rx\");\n        ry = this.element.getFloatAttribute(\"ry\");\n        if (rx < 0 || ry < 0) {\n          throw(\"svg error: negative x-axis radius or y-axis radius found while parsing <ellipse>\");\n        }\n      }\n      this.params[0] -= rx;\n      this.params[1] -= ry;\n\n      this.params[2] = rx*2;\n      this.params[3] = ry*2;\n    };\n    /**\n     * @member PShapeSVG\n     * The parseLine() function handles parsing line tags.\n     *\n     * @param {boolean}val true if this is a circle and not an ellipse\n     */\n    PShapeSVG.prototype.parseLine = function() {\n      this.kind = PConstants.LINE;\n      this.family = PConstants.PRIMITIVE;\n      this.params = [];\n      this.params[0] = this.element.getFloatAttribute(\"x1\");\n      this.params[1] = this.element.getFloatAttribute(\"y1\");\n      this.params[2] = this.element.getFloatAttribute(\"x2\");\n      this.params[3] = this.element.getFloatAttribute(\"y2\");\n    };\n    /**\n     * @member PShapeSVG\n     * The parseColors() function handles parsing the opacity, strijem stroke-width, stroke-linejoin,stroke-linecap, fill, and style attributes\n     *\n     * @param {XMLElement}element the element of which attributes to parse\n     */\n    PShapeSVG.prototype.parseColors = function(element) {\n      if (element.hasAttribute(\"opacity\")) {\n        this.setOpacity(element.getAttribute(\"opacity\"));\n      }\n      if (element.hasAttribute(\"stroke\")) {\n        this.setStroke(element.getAttribute(\"stroke\"));\n      }\n      if (element.hasAttribute(\"stroke-width\")) {\n        // if NaN (i.e. if it's 'inherit') then default\n        // back to the inherit setting\n        this.setStrokeWeight(element.getAttribute(\"stroke-width\"));\n      }\n      if (element.hasAttribute(\"stroke-linejoin\") ) {\n        this.setStrokeJoin(element.getAttribute(\"stroke-linejoin\"));\n      }\n      if (element.hasAttribute(\"stroke-linecap\")) {\n        this.setStrokeCap(element.getStringAttribute(\"stroke-linecap\"));\n      }\n      // fill defaults to black (though stroke defaults to \"none\")\n      // http://www.w3.org/TR/SVG/painting.html#FillProperties\n      if (element.hasAttribute(\"fill\")) {\n        this.setFill(element.getStringAttribute(\"fill\"));\n      }\n      if (element.hasAttribute(\"style\")) {\n        var styleText   = element.getStringAttribute(\"style\");\n        var styleTokens = styleText.toString().split( \";\" );\n\n        for (var i = 0, j = styleTokens.length; i < j; i++) {\n          var tokens = p.trim(styleTokens[i].split( \":\" ));\n          if (tokens[0] === \"fill\") {\n              this.setFill(tokens[1]);\n          } else if (tokens[0] === \"fill-opacity\") {\n              this.setFillOpacity(tokens[1]);\n          } else if (tokens[0] === \"stroke\") {\n              this.setStroke(tokens[1]);\n          } else if (tokens[0] === \"stroke-width\") {\n              this.setStrokeWeight(tokens[1]);\n          } else if (tokens[0] === \"stroke-linecap\") {\n              this.setStrokeCap(tokens[1]);\n          } else if (tokens[0] === \"stroke-linejoin\") {\n              this.setStrokeJoin(tokens[1]);\n          } else if (tokens[0] === \"stroke-opacity\") {\n              this.setStrokeOpacity(tokens[1]);\n          } else if (tokens[0] === \"opacity\") {\n              this.setOpacity(tokens[1]);\n          } // Other attributes are not yet implemented\n        }\n      }\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parseColors() helper function\n     *\n     * @param {String} opacityText the value of fillOpacity\n     *\n     * @see PShapeSVG#parseColors\n     */\n    PShapeSVG.prototype.setFillOpacity = function(opacityText) {\n      this.fillOpacity = parseFloat(opacityText);\n      this.fillColor   = this.fillOpacity * 255  << 24 |\n                         this.fillColor & 0xFFFFFF;\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parseColors() helper function\n     *\n     * @param {String} fillText the value of fill\n     *\n     * @see PShapeSVG#parseColors\n     */\n    PShapeSVG.prototype.setFill = function (fillText) {\n      var opacityMask = this.fillColor & 0xFF000000;\n      if (fillText === \"none\") {\n        this.fill = false;\n      } else if (fillText.indexOf(\"#\") === 0) {\n        this.fill      = true;\n        if (fillText.length === 4) {\n          // convert #00F to #0000FF\n          fillText = fillText.replace(/#(.)(.)(.)/,\"#$1$1$2$2$3$3\");\n        }\n        this.fillColor = opacityMask |\n                         (parseInt(fillText.substring(1), 16 )) &\n                         0xFFFFFF;\n      } else if (fillText.indexOf(\"rgb\") === 0) {\n        this.fill      = true;\n        this.fillColor = opacityMask | this.parseRGB(fillText);\n      } else if (fillText.indexOf(\"url(#\") === 0) {\n        this.fillName = fillText.substring(5, fillText.length - 1 );\n      } else if (colors[fillText]) {\n        this.fill      = true;\n        this.fillColor = opacityMask |\n                         (parseInt(colors[fillText].substring(1), 16)) &\n                         0xFFFFFF;\n      }\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parseColors() helper function\n     *\n     * @param {String} opacity the value of opacity\n     *\n     * @see PShapeSVG#parseColors\n     */\n    PShapeSVG.prototype.setOpacity = function(opacity) {\n      this.strokeColor = parseFloat(opacity) * 255 << 24 |\n                         this.strokeColor & 0xFFFFFF;\n      this.fillColor   = parseFloat(opacity) * 255 << 24 |\n                         this.fillColor & 0xFFFFFF;\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parseColors() helper function\n     *\n     * @param {String} strokeText the value to set stroke to\n     *\n     * @see PShapeSVG#parseColors\n     */\n    PShapeSVG.prototype.setStroke = function(strokeText) {\n      var opacityMask = this.strokeColor & 0xFF000000;\n      if (strokeText === \"none\") {\n        this.stroke = false;\n      } else if (strokeText.charAt( 0 ) === \"#\") {\n        this.stroke      = true;\n        if (strokeText.length === 4) {\n          // convert #00F to #0000FF\n          strokeText = strokeText.replace(/#(.)(.)(.)/,\"#$1$1$2$2$3$3\");\n        }\n        this.strokeColor = opacityMask |\n                           (parseInt( strokeText.substring( 1 ), 16 )) &\n                           0xFFFFFF;\n      } else if (strokeText.indexOf( \"rgb\" ) === 0 ) {\n        this.stroke = true;\n        this.strokeColor = opacityMask | this.parseRGB(strokeText);\n      } else if (strokeText.indexOf( \"url(#\" ) === 0) {\n        this.strokeName = strokeText.substring(5, strokeText.length - 1);\n      } else if (colors[strokeText]) {\n        this.stroke      = true;\n        this.strokeColor = opacityMask |\n                           (parseInt(colors[strokeText].substring(1), 16)) &\n                           0xFFFFFF;\n      }\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parseColors() helper function\n     *\n     * @param {String} weight the value to set strokeWeight to\n     *\n     * @see PShapeSVG#parseColors\n     */\n    PShapeSVG.prototype.setStrokeWeight = function(weight) {\n      this.strokeWeight = this.parseUnitSize(weight);\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parseColors() helper function\n     *\n     * @param {String} linejoin the value to set strokeJoin to\n     *\n     * @see PShapeSVG#parseColors\n     */\n    PShapeSVG.prototype.setStrokeJoin = function(linejoin) {\n      if (linejoin === \"miter\") {\n        this.strokeJoin = PConstants.MITER;\n\n      } else if (linejoin === \"round\") {\n        this.strokeJoin = PConstants.ROUND;\n\n      } else if (linejoin === \"bevel\") {\n        this.strokeJoin = PConstants.BEVEL;\n      }\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parseColors() helper function\n     *\n     * @param {String} linecap the value to set strokeCap to\n     *\n     * @see PShapeSVG#parseColors\n     */\n    PShapeSVG.prototype.setStrokeCap = function (linecap) {\n      if (linecap === \"butt\") {\n        this.strokeCap = PConstants.SQUARE;\n\n      } else if (linecap === \"round\") {\n        this.strokeCap = PConstants.ROUND;\n\n      } else if (linecap === \"square\") {\n        this.strokeCap = PConstants.PROJECT;\n      }\n    };\n    /**\n     * @member PShapeSVG\n     * PShapeSVG.parseColors() helper function\n     *\n     * @param {String} opacityText the value to set stroke opacity to\n     *\n     * @see PShapeSVG#parseColors\n     */\n    PShapeSVG.prototype.setStrokeOpacity =  function (opacityText) {\n      this.strokeOpacity = parseFloat(opacityText);\n      this.strokeColor   = this.strokeOpacity * 255 << 24 |\n                           this.strokeColor &\n                           0xFFFFFF;\n    };\n    /**\n     * @member PShapeSVG\n     * The parseRGB() function parses an rbg() color string and returns a color int\n     *\n     * @param {String} color the color to parse in rbg() format\n     *\n     * @return {int} the equivalent color int\n     */\n    PShapeSVG.prototype.parseRGB = function(color) {\n      var sub    = color.substring(color.indexOf('(') + 1, color.indexOf(')'));\n      var values = sub.split(\", \");\n      return (values[0] << 16) | (values[1] << 8) | (values[2]);\n    };\n    /**\n     * @member PShapeSVG\n     * The parseUnitSize() function parse a size that may have a suffix for its units.\n     * Ignoring cases where this could also be a percentage.\n     * The <A HREF=\"http://www.w3.org/TR/SVG/coords.html#Units\">units</A> spec:\n     * <UL>\n     * <LI>\"1pt\" equals \"1.25px\" (and therefore 1.25 user units)\n     * <LI>\"1pc\" equals \"15px\" (and therefore 15 user units)\n     * <LI>\"1mm\" would be \"3.543307px\" (3.543307 user units)\n     * <LI>\"1cm\" equals \"35.43307px\" (and therefore 35.43307 user units)\n     * <LI>\"1in\" equals \"90px\" (and therefore 90 user units)\n     * </UL>\n     */\n    PShapeSVG.prototype.parseUnitSize = function (text) {\n      var len = text.length - 2;\n      if (len < 0) { return text; }\n      if (text.indexOf(\"pt\") === len) {\n        return parseFloat(text.substring(0, len)) * 1.25;\n      }\n      if (text.indexOf(\"pc\") === len) {\n        return parseFloat( text.substring( 0, len)) * 15;\n      }\n      if (text.indexOf(\"mm\") === len) {\n        return parseFloat( text.substring(0, len)) * 3.543307;\n      }\n      if (text.indexOf(\"cm\") === len) {\n        return parseFloat(text.substring(0, len)) * 35.43307;\n      }\n      if (text.indexOf(\"in\") === len) {\n        return parseFloat(text.substring(0, len)) * 90;\n      }\n      if (text.indexOf(\"px\") === len) {\n        return parseFloat(text.substring(0, len));\n      }\n      return parseFloat(text);\n    };\n    /**\n     * The shape() function displays shapes to the screen.\n     * Processing currently works with SVG shapes only.\n     * The <b>shape</b> parameter specifies the shape to display and the <b>x</b>\n     * and <b>y</b> parameters define the location of the shape from its\n     * upper-left corner.\n     * The shape is displayed at its original size unless the <b>width</b>\n     * and <b>height</b> parameters specify a different size.\n     * The <b>shapeMode()</b> function changes the way the parameters work.\n     * A call to <b>shapeMode(CORNERS)</b>, for example, will change the width\n     * and height parameters to define the x and y values of the opposite corner\n     * of the shape.\n     * <br><br>\n     * Note complex shapes may draw awkwardly with P2D, P3D, and OPENGL. Those\n     * renderers do not yet support shapes that have holes or complicated breaks.\n     *\n     * @param {PShape} shape       the shape to display\n     * @param {int|float} x        x-coordinate of the shape\n     * @param {int|float} y        y-coordinate of the shape\n     * @param {int|float} width    width to display the shape\n     * @param {int|float} height   height to display the shape\n     *\n     * @see PShape\n     * @see loadShape()\n     * @see shapeMode()\n     */\n    p.shape = function(shape, x, y, width, height) {\n      if (arguments.length >= 1 && arguments[0] !== null) {\n        if (shape.isVisible()) {\n          p.pushMatrix();\n          if (curShapeMode === PConstants.CENTER) {\n            if (arguments.length === 5) {\n              p.translate(x - width/2, y - height/2);\n              p.scale(width / shape.getWidth(), height / shape.getHeight());\n            } else if (arguments.length === 3) {\n              p.translate(x - shape.getWidth()/2, - shape.getHeight()/2);\n            } else {\n              p.translate(-shape.getWidth()/2, -shape.getHeight()/2);\n            }\n          } else if (curShapeMode === PConstants.CORNER) {\n            if (arguments.length === 5) {\n              p.translate(x, y);\n              p.scale(width / shape.getWidth(), height / shape.getHeight());\n            } else if (arguments.length === 3) {\n              p.translate(x, y);\n            }\n          } else if (curShapeMode === PConstants.CORNERS) {\n            if (arguments.length === 5) {\n              width  -= x;\n              height -= y;\n              p.translate(x, y);\n              p.scale(width / shape.getWidth(), height / shape.getHeight());\n            } else if (arguments.length === 3) {\n              p.translate(x, y);\n            }\n          }\n          shape.draw(p);\n          if ((arguments.length === 1 && curShapeMode === PConstants.CENTER ) || arguments.length > 1) {\n            p.popMatrix();\n          }\n        }\n      }\n    };\n\n    /**\n     * The shapeMode() function modifies the location from which shapes draw.\n     * The default mode is <b>shapeMode(CORNER)</b>, which specifies the\n     * location to be the upper left corner of the shape and uses the third\n     * and fourth parameters of <b>shape()</b> to specify the width and height.\n     * The syntax <b>shapeMode(CORNERS)</b> uses the first and second parameters\n     * of <b>shape()</b> to set the location of one corner and uses the third\n     * and fourth parameters to set the opposite corner.\n     * The syntax <b>shapeMode(CENTER)</b> draws the shape from its center point\n     * and uses the third and forth parameters of <b>shape()</b> to specify the\n     * width and height.\n     * The parameter must be written in \"ALL CAPS\" because Processing syntax\n     * is case sensitive.\n     *\n     * @param {int} mode One of CORNER, CORNERS, CENTER\n     *\n     * @see shape()\n     * @see rectMode()\n     */\n    p.shapeMode = function (mode) {\n      curShapeMode = mode;\n    };\n\n    /**\n     * The loadShape() function loads vector shapes into a variable of type PShape. Currently, only SVG files may be loaded.\n     * In most cases, <b>loadShape()</b> should be used inside <b>setup()</b> because loading shapes inside <b>draw()</b> will reduce the speed of a sketch.\n     *\n     * @param {String} filename     an SVG file\n     *\n     * @return {PShape} a object of type PShape or null\n     * @see PShape\n     * @see PApplet#shape()\n     * @see PApplet#shapeMode()\n     */\n    p.loadShape = function (filename) {\n      if (arguments.length === 1) {\n        if (filename.indexOf(\".svg\") > -1) {\n          return new PShapeSVG(null, filename);\n        }\n      }\n      return null;\n    };\n\n    /**\n     * XMLAttribute is an attribute of a XML element. This is an internal class\n     *\n     * @param {String} fname     the full name of the attribute\n     * @param {String} n         the short name of the attribute\n     * @param {String} namespace the namespace URI of the attribute\n     * @param {String} v         the value of the attribute\n     * @param {String }t         the type of the attribute\n     *\n     * @see XMLElement\n     */\n    var XMLAttribute = function(fname, n, nameSpace, v, t){\n      this.fullName = fname || \"\";\n      this.name = n || \"\";\n      this.namespace = nameSpace || \"\";\n      this.value = v;\n      this.type = t;\n    };\n    /**\n     * XMLAttribute methods\n     */\n    XMLAttribute.prototype = {\n      /**\n       * @member XMLAttribute\n       * The getName() function returns the short name of the attribute\n       *\n       * @return {String} the short name of the attribute\n       */\n      getName: function() {\n        return this.name;\n      },\n      /**\n       * @member XMLAttribute\n       * The getFullName() function returns the full name of the attribute\n       *\n       * @return {String} the full name of the attribute\n       */\n      getFullName: function() {\n        return this.fullName;\n      },\n      /**\n       * @member XMLAttribute\n       * The getNamespace() function returns the namespace of the attribute\n       *\n       * @return {String} the namespace of the attribute\n       */\n      getNamespace: function() {\n        return this.namespace;\n      },\n      /**\n       * @member XMLAttribute\n       * The getValue() function returns the value of the attribute\n       *\n       * @return {String} the value of the attribute\n       */\n      getValue: function() {\n        return this.value;\n      },\n      /**\n       * @member XMLAttribute\n       * The getValue() function returns the type of the attribute\n       *\n       * @return {String} the type of the attribute\n       */\n      getType: function() {\n        return this.type;\n      },\n      /**\n       * @member XMLAttribute\n       * The setValue() function sets the value of the attribute\n       *\n       * @param {String} newval the new value\n       */\n      setValue: function(newval) {\n        this.value = newval;\n      }\n    };\n\n    /**\n     * XMLElement is a representation of an XML object. The object is able to parse XML code\n     *\n     * @param {PApplet} parent   typically use \"this\"\n     * @param {String} filename  name of the XML/SVG file to load\n     * @param {String} xml       the xml/svg string\n     * @param {String} fullname  the full name of the element\n     * @param {String} namespace the namespace  of the URI\n     * @param {String} systemID  the system ID of the XML data where the element starts\n     * @param {Integer }lineNr   the line in the XML data where the element starts\n     */\n    var XMLElement = p.XMLElement = function(selector, uri, sysid, line) {\n      this.attributes = [];\n      this.children   = [];\n      this.fullName   = null;\n      this.name       = null;\n      this.namespace  = \"\";\n      this.content = null;\n      this.parent    = null;\n      this.lineNr     = \"\";\n      this.systemID   = \"\";\n      this.type = \"ELEMENT\";\n\n      if (selector) {\n        if (typeof selector === \"string\") {\n          if (uri === undef && selector.indexOf(\"<\") > -1) {\n            // load XML from text string\n            this.parse(selector);\n          } else {\n            // XMLElement(fullname, namespace, sysid, line) format\n            this.fullName = selector;\n            this.namespace = uri;\n            this.systemId = sysid;\n            this.lineNr = line;\n          }\n        } else {\n          // XMLElement(this,file) format\n          this.parse(uri);\n        }\n      }\n    };\n    /**\n     * XMLElement methods\n     * missing: enumerateAttributeNames(), enumerateChildren(),\n     * NOTE: parse does not work when a url is passed in\n     */\n    XMLElement.prototype = {\n      /**\n       * @member XMLElement\n       * The parse() function retrieves the file via ajax() and uses DOMParser()\n       * parseFromString method to make an XML document\n       * @addon\n       *\n       * @param {String} filename name of the XML/SVG file to load\n       *\n       * @throws ExceptionType Error loading document\n       *\n       * @see XMLElement#parseChildrenRecursive\n       */\n      parse: function(textstring) {\n        var xmlDoc;\n        try {\n          var extension = textstring.substring(textstring.length-4);\n          if (extension === \".xml\" || extension === \".svg\") {\n            textstring = ajax(textstring);\n          }\n          xmlDoc = new DOMParser().parseFromString(textstring, \"text/xml\");\n          var elements = xmlDoc.documentElement;\n          if (elements) {\n            this.parseChildrenRecursive(null, elements);\n          } else {\n            throw (\"Error loading document\");\n          }\n          return this;\n        } catch(e) {\n          throw(e);\n        }\n      },\n      /**\n       * @member XMLElement\n       * Internal helper function for parse().\n       * Loops through the\n       * @addon\n       *\n       * @param {XMLElement} parent                      the parent node\n       * @param {XML document childNodes} elementpath    the remaining nodes that need parsing\n       *\n       * @return {XMLElement} the new element and its children elements\n       */\n      parseChildrenRecursive: function (parent, elementpath){\n        var xmlelement,\n          xmlattribute,\n          tmpattrib,\n          l, m,\n          child;\n        if (!parent) { // this element is the root element\n          this.fullName = elementpath.localName;\n          this.name     = elementpath.nodeName;\n          xmlelement    = this;\n        } else { // this element has a parent\n          xmlelement         = new XMLElement(elementpath.nodeName);\n          xmlelement.parent  = parent;\n        }\n\n        // if this is a text node, return a PCData element (parsed character data)\n        if (elementpath.nodeType === 3 && elementpath.textContent !== \"\") {\n          return this.createPCDataElement(elementpath.textContent);\n        }\n\n        // if this is a CDATA node, return a CData element (unparsed character data)\n        if (elementpath.nodeType === 4) {\n         return this.createCDataElement(elementpath.textContent);\n        }\n\n        // bind all attributes, if there are any\n        if (elementpath.attributes) {\n          for (l = 0, m = elementpath.attributes.length; l < m; l++) {\n            tmpattrib    = elementpath.attributes[l];\n            xmlattribute = new XMLAttribute(tmpattrib.getname,\n                                            tmpattrib.nodeName,\n                                            tmpattrib.namespaceURI,\n                                            tmpattrib.nodeValue,\n                                            tmpattrib.nodeType);\n            xmlelement.attributes.push(xmlattribute);\n          }\n        }\n\n        // bind all children, if there are any\n        if (elementpath.childNodes) {\n          for (l = 0, m = elementpath.childNodes.length; l < m; l++) {\n            var node = elementpath.childNodes[l];\n            child = xmlelement.parseChildrenRecursive(xmlelement, node);\n            if (child !== null) {\n              xmlelement.children.push(child);\n            }\n          }\n        }\n\n        return xmlelement;\n      },\n      /**\n       * @member XMLElement\n       * The createElement() function Creates an empty element\n       *\n       * @param {String} fullName   the full name of the element\n       * @param {String} namespace  the namespace URI\n       * @param {String} systemID   the system ID of the XML data where the element starts\n       * @param {int} lineNr    the line in the XML data where the element starts\n       */\n      createElement: function (fullname, namespaceuri, sysid, line) {\n        if (sysid === undef) {\n          return new XMLElement(fullname, namespaceuri);\n        }\n        return new XMLElement(fullname, namespaceuri, sysid, line);\n      },\n      /**\n       * @member XMLElement\n       * The createPCDataElement() function creates an element to be used for #PCDATA content.\n       * Because Processing discards whitespace TEXT nodes, this method will not build an element\n       * if the passed content is empty after trimming for whitespace.\n       *\n       * @return {XMLElement} new \"pcdata\" XMLElement, or null if content consists only of whitespace\n       */\n      createPCDataElement: function (content, isCDATA) {\n        if (content.replace(/^\\s+$/g,\"\") === \"\") {\n          return null;\n        }\n        var pcdata = new XMLElement();\n        pcdata.type = \"TEXT\";\n        pcdata.content = content;\n        return pcdata;\n      },\n      /**\n       * @member XMLElement\n       * The createCDataElement() function creates an element to be used for CDATA content.\n       *\n       * @return {XMLElement} new \"cdata\" XMLElement, or null if content consists only of whitespace\n       */\n      createCDataElement: function (content) {\n        var cdata = this.createPCDataElement(content);\n        if (cdata === null) {\n          return null;\n        }\n\n        cdata.type = \"CDATA\";\n        var htmlentities = {\"<\": \"&lt;\", \">\": \"&gt;\", \"'\": \"&apos;\", '\"': \"&quot;\"},\n            entity;\n        for (entity in htmlentities) {\n          if (!Object.hasOwnProperty(htmlentities,entity)) {\n            content = content.replace(new RegExp(entity, \"g\"), htmlentities[entity]);\n          }\n        }\n        cdata.cdata = content;\n        return cdata;\n      },\n      /**\n       * @member XMLElement\n       * The hasAttribute() function returns whether an attribute exists\n       *\n       * @param {String} name      name of the attribute\n       * @param {String} namespace the namespace URI of the attribute\n       *\n       * @return {boolean} true if the attribute exists\n       */\n      hasAttribute: function () {\n        if (arguments.length === 1) {\n          return this.getAttribute(arguments[0]) !== null;\n        }\n        if (arguments.length === 2) {\n          return this.getAttribute(arguments[0],arguments[1]) !== null;\n        }\n      },\n      /**\n       * @member XMLElement\n       * The equals() function checks to see if the XMLElement being passed in equals another XMLElement\n       *\n       * @param {XMLElement} rawElement the element to compare to\n       *\n       * @return {boolean} true if the element equals another element\n       */\n      equals: function(other) {\n        if (!(other instanceof XMLElement)) {\n          return false;\n        }\n        var i, j;\n        if (this.fullName !== other.fullName) { return false; }\n        if (this.attributes.length !== other.getAttributeCount()) { return false; }\n        // attributes may be ordered differently\n        if (this.attributes.length !== other.attributes.length) { return false; }\n        var attr_name, attr_ns, attr_value, attr_type, attr_other;\n        for (i = 0, j = this.attributes.length; i < j; i++) {\n          attr_name = this.attributes[i].getName();\n          attr_ns = this.attributes[i].getNamespace();\n          attr_other = other.findAttribute(attr_name, attr_ns);\n          if (attr_other === null) { return false; }\n          if (this.attributes[i].getValue() !== attr_other.getValue()) { return false; }\n          if (this.attributes[i].getType() !== attr_other.getType()) { return false; }\n        }\n        // children must be ordered identically\n        if (this.children.length !== other.getChildCount()) { return false; }\n        if (this.children.length>0) {\n          var child1, child2;\n          for (i = 0, j = this.children.length; i < j; i++) {\n            child1 = this.getChild(i);\n            child2 = other.getChild(i);\n            if (!child1.equals(child2)) { return false; }\n          }\n          return true;\n        }\n        return (this.content === other.content);\n      },\n      /**\n       * @member XMLElement\n       * The getContent() function returns the content of an element. If there is no such content, null is returned\n       *\n       * @return {String} the (possibly null) content\n       */\n      getContent: function(){\n        if (this.type === \"TEXT\" || this.type === \"CDATA\") {\n          return this.content;\n        }\n        var children = this.children;\n        if (children.length === 1 && (children[0].type === \"TEXT\" || children[0].type === \"CDATA\")) {\n          return children[0].content;\n        }\n        return null;\n      },\n      /**\n       * @member XMLElement\n       * The getAttribute() function returns the value of an attribute\n       *\n       * @param {String} name         the non-null full name of the attribute\n       * @param {String} namespace    the namespace URI, which may be null\n       * @param {String} defaultValue the default value of the attribute\n       *\n       * @return {String} the value, or defaultValue if the attribute does not exist\n       */\n      getAttribute: function (){\n        var attribute;\n        if (arguments.length === 2) {\n          attribute = this.findAttribute(arguments[0]);\n          if (attribute) {\n            return attribute.getValue();\n          }\n          return arguments[1];\n        } else if (arguments.length === 1) {\n          attribute = this.findAttribute(arguments[0]);\n          if (attribute) {\n            return attribute.getValue();\n          }\n          return null;\n        } else if (arguments.length === 3) {\n          attribute = this.findAttribute(arguments[0],arguments[1]);\n          if (attribute) {\n            return attribute.getValue();\n          }\n          return arguments[2];\n        }\n      },\n      /**\n       * @member XMLElement\n       * The getStringAttribute() function returns the string attribute of the element\n       * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.\n       * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.\n       *\n       * @param name         the name of the attribute\n       * @param defaultValue value returned if the attribute is not found\n       *\n       * @return {String} the value, or defaultValue if the attribute does not exist\n       */\n      getStringAttribute: function() {\n        if (arguments.length === 1) {\n          return this.getAttribute(arguments[0]);\n        }\n        if (arguments.length === 2) {\n          return this.getAttribute(arguments[0], arguments[1]);\n        }\n        return this.getAttribute(arguments[0], arguments[1],arguments[2]);\n      },\n      /**\n       * Processing 1.5 XML API wrapper for the generic String\n       * attribute getter. This may only take one argument.\n       */\n      getString: function(attributeName) {\n        return this.getStringAttribute(attributeName);\n      },\n      /**\n       * @member XMLElement\n       * The getFloatAttribute() function returns the float attribute of the element.\n       * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.\n       * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.\n       *\n       * @param name         the name of the attribute\n       * @param defaultValue value returned if the attribute is not found\n       *\n       * @return {float} the value, or defaultValue if the attribute does not exist\n       */\n      getFloatAttribute: function() {\n        if (arguments.length === 1 ) {\n          return parseFloat(this.getAttribute(arguments[0], 0));\n        }\n        if (arguments.length === 2 ) {\n          return this.getAttribute(arguments[0], arguments[1]);\n        }\n        return this.getAttribute(arguments[0], arguments[1],arguments[2]);\n      },\n      /**\n       * Processing 1.5 XML API wrapper for the generic float\n       * attribute getter. This may only take one argument.\n       */\n      getFloat: function(attributeName) {\n        return this.getFloatAttribute(attributeName);\n      },\n      /**\n       * @member XMLElement\n       * The getIntAttribute() function returns the integer attribute of the element.\n       * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.\n       * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.\n       *\n       * @param name         the name of the attribute\n       * @param defaultValue value returned if the attribute is not found\n       *\n       * @return {int} the value, or defaultValue if the attribute does not exist\n       */\n      getIntAttribute: function () {\n        if (arguments.length === 1) {\n          return this.getAttribute( arguments[0], 0 );\n        }\n        if (arguments.length === 2) {\n          return this.getAttribute(arguments[0], arguments[1]);\n        }\n        return this.getAttribute(arguments[0], arguments[1],arguments[2]);\n      },\n      /**\n       * Processing 1.5 XML API wrapper for the generic int\n       * attribute getter. This may only take one argument.\n       */\n      getInt: function(attributeName) {\n        return this.getIntAttribute(attributeName);\n      },\n      /**\n       * @member XMLElement\n       * The hasChildren() function returns whether the element has children.\n       *\n       * @return {boolean} true if the element has children.\n       */\n      hasChildren: function () {\n        return this.children.length > 0 ;\n      },\n      /**\n       * @member XMLElement\n       * The addChild() function adds a child element\n       *\n       * @param {XMLElement} child the non-null child to add.\n       */\n      addChild: function (child) {\n        if (child !== null) {\n          child.parent = this;\n          this.children.push(child);\n        }\n      },\n      /**\n       * @member XMLElement\n       * The insertChild() function inserts a child element at the index provided\n       *\n       * @param {XMLElement} child  the non-null child to add.\n       * @param {int} index     where to put the child.\n       */\n      insertChild: function (child, index) {\n        if (child) {\n          if ((child.getLocalName() === null) && (! this.hasChildren())) {\n            var lastChild = this.children[this.children.length -1];\n            if (lastChild.getLocalName() === null) {\n                lastChild.setContent(lastChild.getContent() + child.getContent());\n                return;\n            }\n          }\n          child.parent = this;\n          this.children.splice(index,0,child);\n        }\n      },\n      /**\n       * @member XMLElement\n       * The getChild() returns the child XMLElement as specified by the <b>index</b> parameter.\n       * The value of the <b>index</b> parameter must be less than the total number of children to avoid going out of the array storing the child elements.\n       * When the <b>path</b> parameter is specified, then it will return all children that match that path. The path is a series of elements and sub-elements, separated by slashes.\n       *\n       * @param {int} index     where to put the child.\n       * @param {String} path       path to a particular element\n       *\n       * @return {XMLElement} the element\n       */\n      getChild: function (selector) {\n        if (typeof selector === \"number\") {\n          return this.children[selector];\n        }\n        if (selector.indexOf('/') !== -1) {\n          // path traversal is required\n          return this.getChildRecursive(selector.split(\"/\"), 0);\n        }\n        var kid, kidName;\n        for (var i = 0, j = this.getChildCount(); i < j; i++) {\n          kid = this.getChild(i);\n          kidName = kid.getName();\n          if (kidName !== null && kidName === selector) {\n              return kid;\n          }\n        }\n        return null;\n      },\n      /**\n       * @member XMLElement\n       * The getChildren() returns all of the children as an XMLElement array.\n       * When the <b>path</b> parameter is specified, then it will return all children that match that path.\n       * The path is a series of elements and sub-elements, separated by slashes.\n       *\n       * @param {String} path       element name or path/to/element\n       *\n       * @return {XMLElement} array of child elements that match\n       *\n       * @see XMLElement#getChildCount()\n       * @see XMLElement#getChild()\n       */\n      getChildren: function(){\n        if (arguments.length === 1) {\n          if (typeof arguments[0] === \"number\") {\n            return this.getChild( arguments[0]);\n          }\n          if (arguments[0].indexOf('/') !== -1) { // path was given\n            return this.getChildrenRecursive( arguments[0].split(\"/\"), 0);\n          }\n          var matches = [];\n          var kid, kidName;\n          for (var i = 0, j = this.getChildCount(); i < j; i++) {\n            kid = this.getChild(i);\n            kidName = kid.getName();\n            if (kidName !== null && kidName === arguments[0]) {\n              matches.push(kid);\n            }\n          }\n          return matches;\n        }\n        return this.children;\n      },\n      /**\n       * @member XMLElement\n       * The getChildCount() returns the number of children for the element.\n       *\n       * @return {int} the count\n       *\n       * @see XMLElement#getChild()\n       * @see XMLElement#getChildren()\n       */\n      getChildCount: function() {\n        return this.children.length;\n      },\n      /**\n       * @member XMLElement\n       * Internal helper function for getChild().\n       *\n       * @param {String[]} items   result of splitting the query on slashes\n       * @param {int} offset   where in the items[] array we're currently looking\n       *\n       * @return {XMLElement} matching element or null if no match\n       */\n      getChildRecursive: function (items, offset) {\n        // terminating clause: we are the requested candidate\n        if (offset === items.length) {\n          return this;\n        }\n        // continuation clause\n        var kid, kidName, matchName = items[offset];\n        for(var i = 0, j = this.getChildCount(); i < j; i++) {\n            kid = this.getChild(i);\n            kidName = kid.getName();\n            if (kidName !== null && kidName === matchName) {\n              return kid.getChildRecursive(items, offset+1);\n            }\n        }\n        return null;\n      },\n      /**\n       * @member XMLElement\n       * Internal helper function for getChildren().\n       *\n       * @param {String[]} items   result of splitting the query on slashes\n       * @param {int} offset   where in the items[] array we're currently looking\n       *\n       * @return {XMLElement[]} matching elements or empty array if no match\n       */\n      getChildrenRecursive: function (items, offset) {\n        if (offset === items.length-1) {\n          return this.getChildren(items[offset]);\n        }\n        var matches = this.getChildren(items[offset]);\n        var kidMatches = [];\n        for (var i = 0; i < matches.length; i++) {\n          kidMatches = kidMatches.concat(matches[i].getChildrenRecursive(items, offset+1));\n        }\n        return kidMatches;\n      },\n      /**\n       * @member XMLElement\n       * The isLeaf() function returns whether the element is a leaf element.\n       *\n       * @return {boolean} true if the element has no children.\n       */\n      isLeaf: function() {\n        return !this.hasChildren();\n      },\n      /**\n       * @member XMLElement\n       * The listChildren() function put the names of all children into an array. Same as looping through\n       * each child and calling getName() on each XMLElement.\n       *\n       * @return {String[]} a list of element names.\n       */\n      listChildren: function() {\n        var arr = [];\n        for (var i = 0, j = this.children.length; i < j; i++) {\n          arr.push( this.getChild(i).getName());\n        }\n        return arr;\n      },\n      /**\n       * @member XMLElement\n       * The removeAttribute() function removes an attribute\n       *\n       * @param {String} name        the non-null name of the attribute.\n       * @param {String} namespace   the namespace URI of the attribute, which may be null.\n       */\n      removeAttribute: function (name , namespace) {\n        this.namespace = namespace || \"\";\n        for (var i = 0, j = this.attributes.length; i < j; i++) {\n          if (this.attributes[i].getName() === name && this.attributes[i].getNamespace() === this.namespace) {\n            this.attributes.splice(i, 1);\n            break;\n          }\n        }\n      },\n      /**\n       * @member XMLElement\n       * The removeChild() removes a child element.\n       *\n       * @param {XMLElement} child      the the non-null child to be renoved\n       */\n      removeChild: function(child) {\n        if (child) {\n          for (var i = 0, j = this.children.length; i < j; i++) {\n            if (this.children[i].equals(child)) {\n              this.children.splice(i, 1);\n              break;\n            }\n          }\n        }\n      },\n      /**\n       * @member XMLElement\n       * The removeChildAtIndex() removes the child located at a certain index\n       *\n       * @param {int} index      the index of the child, where the first child has index 0\n       */\n      removeChildAtIndex: function(index) {\n        if (this.children.length > index) { //make sure its not outofbounds\n          this.children.splice(index, 1);\n        }\n      },\n      /**\n       * @member XMLElement\n       * The findAttribute() function searches an attribute\n       *\n       * @param {String} name        fullName the non-null full name of the attribute\n       * @param {String} namespace   the name space, which may be null\n       *\n       * @return {XMLAttribute} the attribute, or null if the attribute does not exist.\n       */\n      findAttribute: function (name, namespace) {\n        this.namespace = namespace || \"\";\n        for (var i = 0, j = this.attributes.length; i < j; i++) {\n          if (this.attributes[i].getName() === name && this.attributes[i].getNamespace() === this.namespace) {\n             return this.attributes[i];\n          }\n        }\n        return null;\n      },\n      /**\n       * @member XMLElement\n       * The setAttribute() function sets an attribute.\n       *\n       * @param {String} name        the non-null full name of the attribute\n       * @param {String} namespace   the non-null value of the attribute\n       */\n      setAttribute: function() {\n        var attr;\n        if (arguments.length === 3) {\n          var index = arguments[0].indexOf(':');\n          var name  = arguments[0].substring(index + 1);\n          attr      = this.findAttribute(name, arguments[1]);\n          if (attr) {\n            attr.setValue(arguments[2]);\n          } else {\n            attr = new XMLAttribute(arguments[0], name, arguments[1], arguments[2], \"CDATA\");\n            this.attributes.push(attr);\n          }\n        } else {\n          attr = this.findAttribute(arguments[0]);\n          if (attr) {\n            attr.setValue(arguments[1]);\n          } else {\n            attr = new XMLAttribute(arguments[0], arguments[0], null, arguments[1], \"CDATA\");\n            this.attributes.push(attr);\n          }\n        }\n      },\n      /**\n       * Processing 1.5 XML API wrapper for the generic String\n       * attribute setter. This must take two arguments.\n       */\n      setString: function(attribute, value) {\n        this.setAttribute(attribute, value);\n      },\n      /**\n       * Processing 1.5 XML API wrapper for the generic int\n       * attribute setter. This must take two arguments.\n       */\n      setInt: function(attribute, value) {\n        this.setAttribute(attribute, value);\n      },\n      /**\n       * Processing 1.5 XML API wrapper for the generic float\n       * attribute setter. This must take two arguments.\n       */\n      setFloat: function(attribute, value) {\n        this.setAttribute(attribute, value);\n      },\n      /**\n       * @member XMLElement\n       * The setContent() function sets the #PCDATA content. It is an error to call this method with a\n       * non-null value if there are child objects.\n       *\n       * @param {String} content     the (possibly null) content\n       */\n      setContent: function(content) {\n        if (this.children.length > 0) {\n          Processing.debug(\"Tried to set content for XMLElement with children\"); }\n        this.content = content;\n      },\n      /**\n       * @member XMLElement\n       * The setName() function sets the full name. This method also sets the short name and clears the\n       * namespace URI.\n       *\n       * @param {String} name        the non-null name\n       * @param {String} namespace   the namespace URI, which may be null.\n       */\n      setName: function() {\n        if (arguments.length === 1) {\n          this.name      = arguments[0];\n          this.fullName  = arguments[0];\n          this.namespace = null;\n        } else {\n          var index = arguments[0].indexOf(':');\n          if ((arguments[1] === null) || (index < 0)) {\n              this.name = arguments[0];\n          } else {\n              this.name = arguments[0].substring(index + 1);\n          }\n          this.fullName  = arguments[0];\n          this.namespace = arguments[1];\n        }\n      },\n      /**\n       * @member XMLElement\n       * The getName() function returns the full name (i.e. the name including an eventual namespace\n       * prefix) of the element.\n       *\n       * @return {String} the name, or null if the element only contains #PCDATA.\n       */\n      getName: function() {\n        return this.fullName;\n      },\n      /**\n       * @member XMLElement\n       * The getLocalName() function returns the local name (i.e. the name excluding an eventual namespace\n       * prefix) of the element.\n       *\n       * @return {String} the name, or null if the element only contains #PCDATA.\n       */\n      getLocalName: function() {\n        return this.name;\n      },\n      /**\n       * @member XMLElement\n       * The getAttributeCount() function returns the number of attributes for the node\n       * that this XMLElement represents.\n       *\n       * @return {int} the number of attributes in this XMLElement\n       */\n      getAttributeCount: function() {\n        return this.attributes.length;\n      },\n      /**\n       * @member XMLElement\n       * The toString() function returns the XML definition of an XMLElement.\n       *\n       * @return {String} the XML definition of this XMLElement\n       */\n      toString: function() {\n        // shortcut for text and cdata nodes\n        if (this.type === \"TEXT\") {\n          return this.content;\n        }\n\n        if (this.type === \"CDATA\") {\n          return this.cdata;\n        }\n\n        // real XMLElements\n        var tagstring = this.fullName;\n        var xmlstring =  \"<\" + tagstring;\n        var a,c;\n\n        // serialize the attributes to XML string\n        for (a = 0; a<this.attributes.length; a++) {\n          var attr = this.attributes[a];\n          xmlstring += \" \"  + attr.getName() + \"=\" + '\"' + attr.getValue() + '\"';\n        }\n\n        // serialize all children to XML string\n        if (this.children.length === 0) {\n          if (this.content===\"\") {\n            xmlstring += \"/>\";\n          } else {\n            xmlstring += \">\" + this.content + \"</\"+tagstring+\">\";\n          }\n        } else {\n          xmlstring += \">\";\n          for (c = 0; c<this.children.length; c++) {\n            xmlstring += this.children[c].toString();\n          }\n          xmlstring += \"</\" + tagstring + \">\";\n        }\n        return xmlstring;\n       }\n    };\n\n    /**\n     * static Processing 1.5 XML API wrapper for the\n     * parse method. This may only take one argument.\n     */\n    XMLElement.parse = function(xmlstring) {\n      var element = new XMLElement();\n      element.parse(xmlstring);\n      return element;\n    };\n\n    // Processing 2.0 compatibility\n    var XML = p.XML = p.XMLElement;\n\n    /**\n     * Processing 2.0 function for loading XML files.\n     *\n     * @param {String} uri The uri for the xml file to load.\n     *\n     * @return {XML} An XML object representing the xml data.\n     */\n    p.loadXML = function(uri) {\n      return new XML(p, uri);\n    };\n\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 2D Matrix\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Helper function for printMatrix(). Finds the largest scalar\n     * in the matrix, then number of digits left of the decimal.\n     * Call from PMatrix2D and PMatrix3D's print() function.\n     */\n    var printMatrixHelper = function(elements) {\n      var big = 0;\n      for (var i = 0; i < elements.length; i++) {\n        if (i !== 0) {\n          big = Math.max(big, Math.abs(elements[i]));\n        } else {\n          big = Math.abs(elements[i]);\n        }\n      }\n\n      var digits = (big + \"\").indexOf(\".\");\n      if (digits === 0) {\n        digits = 1;\n      } else if (digits === -1) {\n        digits = (big + \"\").length;\n      }\n\n      return digits;\n    };\n    /**\n     * PMatrix2D is a 3x2 affine matrix implementation. The constructor accepts another PMatrix2D or a list of six float elements.\n     * If no parameters are provided the matrix is set to the identity matrix.\n     *\n     * @param {PMatrix2D} matrix  the initial matrix to set to\n     * @param {float} m00         the first element of the matrix\n     * @param {float} m01         the second element of the matrix\n     * @param {float} m02         the third element of the matrix\n     * @param {float} m10         the fourth element of the matrix\n     * @param {float} m11         the fifth element of the matrix\n     * @param {float} m12         the sixth element of the matrix\n     */\n    var PMatrix2D = p.PMatrix2D = function() {\n      if (arguments.length === 0) {\n        this.reset();\n      } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n        this.set(arguments[0].array());\n      } else if (arguments.length === 6) {\n        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n      }\n    };\n    /**\n     * PMatrix2D methods\n     */\n    PMatrix2D.prototype = {\n      /**\n       * @member PMatrix2D\n       * The set() function sets the matrix elements. The function accepts either another PMatrix2D, an array of elements, or a list of six floats.\n       *\n       * @param {PMatrix2D} matrix    the matrix to set this matrix to\n       * @param {float[]} elements    an array of elements to set this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the third element of the matrix\n       * @param {float} m10           the fourth element of the matrix\n       * @param {float} m11           the fith element of the matrix\n       * @param {float} m12           the sixth element of the matrix\n       */\n      set: function() {\n        if (arguments.length === 6) {\n          var a = arguments;\n          this.set([a[0], a[1], a[2],\n                    a[3], a[4], a[5]]);\n        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n          this.elements = arguments[0].array();\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          this.elements = arguments[0].slice();\n        }\n      },\n      /**\n       * @member PMatrix2D\n       * The get() function returns a copy of this PMatrix2D.\n       *\n       * @return {PMatrix2D} a copy of this PMatrix2D\n       */\n      get: function() {\n        var outgoing = new PMatrix2D();\n        outgoing.set(this.elements);\n        return outgoing;\n      },\n      /**\n       * @member PMatrix2D\n       * The reset() function sets this PMatrix2D to the identity matrix.\n       */\n      reset: function() {\n        this.set([1, 0, 0, 0, 1, 0]);\n      },\n      /**\n       * @member PMatrix2D\n       * The array() function returns a copy of the element values.\n       * @addon\n       *\n       * @return {float[]} returns a copy of the element values\n       */\n      array: function array() {\n        return this.elements.slice();\n      },\n      /**\n       * @member PMatrix2D\n       * The translate() function translates this matrix by moving the current coordinates to the location specified by tx and ty.\n       *\n       * @param {float} tx  the x-axis coordinate to move to\n       * @param {float} ty  the y-axis coordinate to move to\n       */\n      translate: function(tx, ty) {\n        this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];\n        this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5];\n      },\n      /**\n       * @member PMatrix2D\n       * The invTranslate() function translates this matrix by moving the current coordinates to the negative location specified by tx and ty.\n       *\n       * @param {float} tx  the x-axis coordinate to move to\n       * @param {float} ty  the y-axis coordinate to move to\n       */\n      invTranslate: function(tx, ty) {\n        this.translate(-tx, -ty);\n      },\n       /**\n       * @member PMatrix2D\n       * The transpose() function is not used in processingjs.\n       */\n      transpose: function() {\n        // Does nothing in Processing.\n      },\n      /**\n       * @member PMatrix2D\n       * The mult() function multiplied this matrix.\n       * If two array elements are passed in the function will multiply a two element vector against this matrix.\n       * If target is null or not length four, a new float array will be returned.\n       * The values for vec and target can be the same (though that's less efficient).\n       * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n       *\n       * @param {PVector} source, target  the PVectors used to multiply this matrix\n       * @param {float[]} source, target  the arrays used to multiply this matrix\n       *\n       * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n       */\n      mult: function(source, target) {\n        var x, y;\n        if (source instanceof PVector) {\n          x = source.x;\n          y = source.y;\n          if (!target) {\n            target = new PVector();\n          }\n        } else if (source instanceof Array) {\n          x = source[0];\n          y = source[1];\n          if (!target) {\n            target = [];\n          }\n        }\n        if (target instanceof Array) {\n          target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n          target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n        } else if (target instanceof PVector) {\n          target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n          target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n          target.z = 0;\n        }\n        return target;\n      },\n      /**\n       * @member PMatrix2D\n       * The multX() function calculates the x component of a vector from a transformation.\n       *\n       * @param {float} x the x component of the vector being transformed\n       * @param {float} y the y component of the vector being transformed\n       *\n       * @return {float} returnes the result of the calculation\n       */\n      multX: function(x, y) {\n        return (x * this.elements[0] + y * this.elements[1] + this.elements[2]);\n      },\n      /**\n       * @member PMatrix2D\n       * The multY() function calculates the y component of a vector from a transformation.\n       *\n       * @param {float} x the x component of the vector being transformed\n       * @param {float} y the y component of the vector being transformed\n       *\n       * @return {float} returnes the result of the calculation\n       */\n      multY: function(x, y) {\n        return (x * this.elements[3] + y * this.elements[4] + this.elements[5]);\n      },\n      /**\n       * @member PMatrix2D\n       * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      skewX: function(angle) {\n        this.apply(1, 0, 1, angle, 0, 0);\n      },\n      /**\n       * @member PMatrix2D\n       * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      skewY: function(angle) {\n        this.apply(1, 0, 1,  0, angle, 0);\n      },\n      /**\n       * @member PMatrix2D\n       * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      shearX: function(angle) {\n        this.apply(1, 0, 1, Math.tan(angle) , 0, 0);\n      },\n      /**\n       * @member PMatrix2D\n       * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      shearY: function(angle) {\n        this.apply(1, 0, 1,  0, Math.tan(angle), 0);\n      },\n      /**\n       * @member PMatrix2D\n       * The determinant() function calvculates the determinant of this matrix.\n       *\n       * @return {float} the determinant of the matrix\n       */\n      determinant: function() {\n        return (this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3]);\n      },\n      /**\n       * @member PMatrix2D\n       * The invert() function inverts this matrix\n       *\n       * @return {boolean} true if successful\n       */\n      invert: function() {\n        var d = this.determinant();\n        if (Math.abs( d ) > PConstants.MIN_INT) {\n          var old00 = this.elements[0];\n          var old01 = this.elements[1];\n          var old02 = this.elements[2];\n          var old10 = this.elements[3];\n          var old11 = this.elements[4];\n          var old12 = this.elements[5];\n          this.elements[0] =  old11 / d;\n          this.elements[3] = -old10 / d;\n          this.elements[1] = -old01 / d;\n          this.elements[4] =  old00 / d;\n          this.elements[2] = (old01 * old12 - old11 * old02) / d;\n          this.elements[5] = (old10 * old02 - old00 * old12) / d;\n          return true;\n        }\n        return false;\n      },\n      /**\n       * @member PMatrix2D\n       * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n       * This is equivalent to a two parameter call.\n       *\n       * @param {float} sx  the amount to scale on the x-axis\n       * @param {float} sy  the amount to scale on the y-axis\n       */\n      scale: function(sx, sy) {\n        if (sx && !sy) {\n          sy = sx;\n        }\n        if (sx && sy) {\n          this.elements[0] *= sx;\n          this.elements[1] *= sy;\n          this.elements[3] *= sx;\n          this.elements[4] *= sy;\n        }\n      },\n       /**\n        * @member PMatrix2D\n        * The invScale() function decreases or increases the size of a shape by contracting and expanding vertices. When only one parameter is specified scale will occur in all dimensions.\n        * This is equivalent to a two parameter call.\n        *\n        * @param {float} sx  the amount to scale on the x-axis\n        * @param {float} sy  the amount to scale on the y-axis\n        */\n      invScale: function(sx, sy) {\n        if (sx && !sy) {\n          sy = sx;\n        }\n        this.scale(1 / sx, 1 / sy);\n      },\n      /**\n       * @member PMatrix2D\n       * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix2D or a list of floats can be passed in.\n       *\n       * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the third element of the matrix\n       * @param {float} m10           the fourth element of the matrix\n       * @param {float} m11           the fith element of the matrix\n       * @param {float} m12           the sixth element of the matrix\n       */\n      apply: function() {\n        var source;\n        if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n          source = arguments[0].array();\n        } else if (arguments.length === 6) {\n          source = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          source = arguments[0];\n        }\n\n        var result = [0, 0, this.elements[2],\n                      0, 0, this.elements[5]];\n        var e = 0;\n        for (var row = 0; row < 2; row++) {\n          for (var col = 0; col < 3; col++, e++) {\n            result[e] += this.elements[row * 3 + 0] * source[col + 0] +\n                         this.elements[row * 3 + 1] * source[col + 3];\n          }\n        }\n        this.elements = result.slice();\n      },\n      /**\n       * @member PMatrix2D\n       * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix2D or elements of a matrix can be passed in.\n       *\n       * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the third element of the matrix\n       * @param {float} m10           the fourth element of the matrix\n       * @param {float} m11           the fith element of the matrix\n       * @param {float} m12           the sixth element of the matrix\n       */\n      preApply: function() {\n        var source;\n        if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n          source = arguments[0].array();\n        } else if (arguments.length === 6) {\n          source = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          source = arguments[0];\n        }\n        var result = [0, 0, source[2],\n                      0, 0, source[5]];\n        result[2] = source[2] + this.elements[2] * source[0] + this.elements[5] * source[1];\n        result[5] = source[5] + this.elements[2] * source[3] + this.elements[5] * source[4];\n        result[0] = this.elements[0] * source[0] + this.elements[3] * source[1];\n        result[3] = this.elements[0] * source[3] + this.elements[3] * source[4];\n        result[1] = this.elements[1] * source[0] + this.elements[4] * source[1];\n        result[4] = this.elements[1] * source[3] + this.elements[4] * source[4];\n        this.elements = result.slice();\n      },\n      /**\n       * @member PMatrix2D\n       * The rotate() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotate: function(angle) {\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        var temp1 = this.elements[0];\n        var temp2 = this.elements[1];\n        this.elements[0] =  c * temp1 + s * temp2;\n        this.elements[1] = -s * temp1 + c * temp2;\n        temp1 = this.elements[3];\n        temp2 = this.elements[4];\n        this.elements[3] =  c * temp1 + s * temp2;\n        this.elements[4] = -s * temp1 + c * temp2;\n      },\n      /**\n       * @member PMatrix2D\n       * The rotateZ() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotateZ: function(angle) {\n        this.rotate(angle);\n      },\n      /**\n       * @member PMatrix2D\n       * The invRotateZ() function rotates the matrix in opposite direction.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      invRotateZ: function(angle) {\n        this.rotateZ(angle - Math.PI);\n      },\n      /**\n       * @member PMatrix2D\n       * The print() function prints out the elements of this matrix\n       */\n      print: function() {\n        var digits = printMatrixHelper(this.elements);\n        var output = \"\" + p.nfs(this.elements[0], digits, 4) + \" \" +\n                     p.nfs(this.elements[1], digits, 4) + \" \" +\n                     p.nfs(this.elements[2], digits, 4) + \"\\n\" +\n                     p.nfs(this.elements[3], digits, 4) + \" \" +\n                     p.nfs(this.elements[4], digits, 4) + \" \" +\n                     p.nfs(this.elements[5], digits, 4) + \"\\n\\n\";\n        p.println(output);\n      }\n    };\n\n    /**\n     * PMatrix3D is a 4x4  matrix implementation. The constructor accepts another PMatrix3D or a list of six or sixteen float elements.\n     * If no parameters are provided the matrix is set to the identity matrix.\n     */\n    var PMatrix3D = p.PMatrix3D = function() {\n      // When a matrix is created, it is set to an identity matrix\n      this.reset();\n    };\n    /**\n     * PMatrix3D methods\n     */\n    PMatrix3D.prototype = {\n      /**\n       * @member PMatrix2D\n       * The set() function sets the matrix elements. The function accepts either another PMatrix3D, an array of elements, or a list of six or sixteen floats.\n       *\n       * @param {PMatrix3D} matrix    the initial matrix to set to\n       * @param {float[]} elements    an array of elements to set this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       */\n      set: function() {\n        if (arguments.length === 16) {\n          this.elements = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n          this.elements = arguments[0].array();\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          this.elements = arguments[0].slice();\n        }\n      },\n      /**\n       * @member PMatrix3D\n       * The get() function returns a copy of this PMatrix3D.\n       *\n       * @return {PMatrix3D} a copy of this PMatrix3D\n       */\n      get: function() {\n        var outgoing = new PMatrix3D();\n        outgoing.set(this.elements);\n        return outgoing;\n      },\n      /**\n       * @member PMatrix3D\n       * The reset() function sets this PMatrix3D to the identity matrix.\n       */\n      reset: function() {\n        this.elements = [1,0,0,0,\n                         0,1,0,0,\n                         0,0,1,0,\n                         0,0,0,1];\n      },\n      /**\n       * @member PMatrix3D\n       * The array() function returns a copy of the element values.\n       * @addon\n       *\n       * @return {float[]} returns a copy of the element values\n       */\n      array: function array() {\n        return this.elements.slice();\n      },\n      /**\n       * @member PMatrix3D\n       * The translate() function translates this matrix by moving the current coordinates to the location specified by tx, ty, and tz.\n       *\n       * @param {float} tx  the x-axis coordinate to move to\n       * @param {float} ty  the y-axis coordinate to move to\n       * @param {float} tz  the z-axis coordinate to move to\n       */\n      translate: function(tx, ty, tz) {\n        if (tz === undef) {\n          tz = 0;\n        }\n\n        this.elements[3]  += tx * this.elements[0]  + ty * this.elements[1]  + tz * this.elements[2];\n        this.elements[7]  += tx * this.elements[4]  + ty * this.elements[5]  + tz * this.elements[6];\n        this.elements[11] += tx * this.elements[8]  + ty * this.elements[9]  + tz * this.elements[10];\n        this.elements[15] += tx * this.elements[12] + ty * this.elements[13] + tz * this.elements[14];\n      },\n      /**\n       * @member PMatrix3D\n       * The transpose() function transpose this matrix.\n       */\n      transpose: function() {\n        var temp = this.elements[4];\n        this.elements[4] = this.elements[1];\n        this.elements[1] = temp;\n\n        temp = this.elements[8];\n        this.elements[8] = this.elements[2];\n        this.elements[2] = temp;\n\n        temp = this.elements[6];\n        this.elements[6] = this.elements[9];\n        this.elements[9] = temp;\n\n        temp = this.elements[3];\n        this.elements[3] = this.elements[12];\n        this.elements[12] = temp;\n\n        temp = this.elements[7];\n        this.elements[7] = this.elements[13];\n        this.elements[13] = temp;\n\n        temp = this.elements[11];\n        this.elements[11] = this.elements[14];\n        this.elements[14] = temp;\n      },\n      /**\n       * @member PMatrix3D\n       * The mult() function multiplied this matrix.\n       * If two array elements are passed in the function will multiply a two element vector against this matrix.\n       * If target is null or not length four, a new float array will be returned.\n       * The values for vec and target can be the same (though that's less efficient).\n       * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n       *\n       * @param {PVector} source, target  the PVectors used to multiply this matrix\n       * @param {float[]} source, target  the arrays used to multiply this matrix\n       *\n       * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n       */\n      mult: function(source, target) {\n        var x, y, z, w;\n        if (source instanceof PVector) {\n          x = source.x;\n          y = source.y;\n          z = source.z;\n          w = 1;\n          if (!target) {\n            target = new PVector();\n          }\n        } else if (source instanceof Array) {\n          x = source[0];\n          y = source[1];\n          z = source[2];\n          w = source[3] || 1;\n\n          if ( !target || (target.length !== 3 && target.length !== 4) ) {\n            target = [0, 0, 0];\n          }\n        }\n\n        if (target instanceof Array) {\n          if (target.length === 3) {\n            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n            target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n            target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n          } else if (target.length === 4) {\n            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n            target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n            target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n            target[3] = this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n          }\n        }\n        if (target instanceof PVector) {\n          target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n          target.y = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n          target.z = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n        }\n        return target;\n      },\n      /**\n       * @member PMatrix3D\n       * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix3D or elements of a matrix can be passed in.\n       *\n       * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       */\n      preApply: function() {\n        var source;\n        if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n          source = arguments[0].array();\n        } else if (arguments.length === 16) {\n          source = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          source = arguments[0];\n        }\n\n        var result = [0, 0, 0, 0,\n                      0, 0, 0, 0,\n                      0, 0, 0, 0,\n                      0, 0, 0, 0];\n        var e = 0;\n        for (var row = 0; row < 4; row++) {\n          for (var col = 0; col < 4; col++, e++) {\n            result[e] += this.elements[col + 0] * source[row * 4 + 0] + this.elements[col + 4] *\n                         source[row * 4 + 1] + this.elements[col + 8] * source[row * 4 + 2] +\n                         this.elements[col + 12] * source[row * 4 + 3];\n          }\n        }\n        this.elements = result.slice();\n      },\n      /**\n       * @member PMatrix3D\n       * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix3D or a list of floats can be passed in.\n       *\n       * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       */\n      apply: function() {\n        var source;\n        if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n          source = arguments[0].array();\n        } else if (arguments.length === 16) {\n          source = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          source = arguments[0];\n        }\n\n        var result = [0, 0, 0, 0,\n                      0, 0, 0, 0,\n                      0, 0, 0, 0,\n                      0, 0, 0, 0];\n        var e = 0;\n        for (var row = 0; row < 4; row++) {\n          for (var col = 0; col < 4; col++, e++) {\n            result[e] += this.elements[row * 4 + 0] * source[col + 0] + this.elements[row * 4 + 1] *\n                         source[col + 4] + this.elements[row * 4 + 2] * source[col + 8] +\n                         this.elements[row * 4 + 3] * source[col + 12];\n          }\n        }\n        this.elements = result.slice();\n      },\n      /**\n       * @member PMatrix3D\n       * The rotate() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotate: function(angle, v0, v1, v2) {\n        if (!v1) {\n          this.rotateZ(angle);\n        } else {\n          // TODO should make sure this vector is normalized\n          var c = p.cos(angle);\n          var s = p.sin(angle);\n          var t = 1.0 - c;\n\n          this.apply((t * v0 * v0) + c,\n                     (t * v0 * v1) - (s * v2),\n                     (t * v0 * v2) + (s * v1),\n                     0,\n                     (t * v0 * v1) + (s * v2),\n                     (t * v1 * v1) + c,\n                     (t * v1 * v2) - (s * v0),\n                     0,\n                     (t * v0 * v2) - (s * v1),\n                     (t * v1 * v2) + (s * v0),\n                     (t * v2 * v2) + c,\n                     0,\n                     0, 0, 0, 1);\n        }\n      },\n      /**\n       * @member PMatrix3D\n       * The invApply() function applies the inverted matrix to this matrix.\n       *\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       *\n       * @return {boolean} returns true if the operation was successful.\n       */\n      invApply: function() {\n        if (inverseCopy === undef) {\n          inverseCopy = new PMatrix3D();\n        }\n        var a = arguments;\n        inverseCopy.set(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8],\n                        a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n\n        if (!inverseCopy.invert()) {\n          return false;\n        }\n        this.preApply(inverseCopy);\n        return true;\n      },\n      /**\n       * @member PMatrix3D\n       * The rotateZ() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotateX: function(angle) {\n        var c = p.cos(angle);\n        var s = p.sin(angle);\n        this.apply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);\n      },\n      /**\n       * @member PMatrix3D\n       * The rotateY() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotateY: function(angle) {\n        var c = p.cos(angle);\n        var s = p.sin(angle);\n        this.apply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\n      },\n      /**\n       * @member PMatrix3D\n       * The rotateZ() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotateZ: function(angle) {\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        this.apply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n      },\n      /**\n       * @member PMatrix3D\n       * The scale() function increases or decreases the size of a matrix by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n       * This is equivalent to a three parameter call.\n       *\n       * @param {float} sx  the amount to scale on the x-axis\n       * @param {float} sy  the amount to scale on the y-axis\n       * @param {float} sz  the amount to scale on the z-axis\n       */\n      scale: function(sx, sy, sz) {\n        if (sx && !sy && !sz) {\n          sy = sz = sx;\n        } else if (sx && sy && !sz) {\n          sz = 1;\n        }\n\n        if (sx && sy && sz) {\n          this.elements[0]  *= sx;\n          this.elements[1]  *= sy;\n          this.elements[2]  *= sz;\n          this.elements[4]  *= sx;\n          this.elements[5]  *= sy;\n          this.elements[6]  *= sz;\n          this.elements[8]  *= sx;\n          this.elements[9]  *= sy;\n          this.elements[10] *= sz;\n          this.elements[12] *= sx;\n          this.elements[13] *= sy;\n          this.elements[14] *= sz;\n        }\n      },\n      /**\n       * @member PMatrix3D\n       * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      skewX: function(angle) {\n        var t = Math.tan(angle);\n        this.apply(1, t, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      },\n      /**\n       * @member PMatrix3D\n       * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      skewY: function(angle) {\n        var t = Math.tan(angle);\n        this.apply(1, 0, 0, 0, t, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      },\n      /**\n       * @member PMatrix3D\n       * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of shear specified in radians\n       */\n      shearX: function(angle) {\n        var t = Math.tan(angle);\n        this.apply(1, t, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      },\n      /**\n       * @member PMatrix3D\n       * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of shear specified in radians\n       */\n      shearY: function(angle) {\n        var t = Math.tan(angle);\n        this.apply(1, 0, 0, 0, t, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      },\n      multX: function(x, y, z, w) {\n        if (!z) {\n          return this.elements[0] * x + this.elements[1] * y + this.elements[3];\n        }\n        if (!w) {\n          return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n        }\n        return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n      },\n      multY: function(x, y, z, w) {\n        if (!z) {\n          return this.elements[4] * x + this.elements[5] * y + this.elements[7];\n        }\n        if (!w) {\n          return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n        }\n        return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n      },\n      multZ: function(x, y, z, w) {\n        if (!w) {\n          return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n        }\n        return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n      },\n      multW: function(x, y, z, w) {\n        if (!w) {\n          return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15];\n        }\n        return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n      },\n      /**\n       * @member PMatrix3D\n       * The invert() function inverts this matrix\n       *\n       * @return {boolean} true if successful\n       */\n      invert: function() {\n        var fA0 = this.elements[0] * this.elements[5] - this.elements[1] * this.elements[4];\n        var fA1 = this.elements[0] * this.elements[6] - this.elements[2] * this.elements[4];\n        var fA2 = this.elements[0] * this.elements[7] - this.elements[3] * this.elements[4];\n        var fA3 = this.elements[1] * this.elements[6] - this.elements[2] * this.elements[5];\n        var fA4 = this.elements[1] * this.elements[7] - this.elements[3] * this.elements[5];\n        var fA5 = this.elements[2] * this.elements[7] - this.elements[3] * this.elements[6];\n        var fB0 = this.elements[8] * this.elements[13] - this.elements[9] * this.elements[12];\n        var fB1 = this.elements[8] * this.elements[14] - this.elements[10] * this.elements[12];\n        var fB2 = this.elements[8] * this.elements[15] - this.elements[11] * this.elements[12];\n        var fB3 = this.elements[9] * this.elements[14] - this.elements[10] * this.elements[13];\n        var fB4 = this.elements[9] * this.elements[15] - this.elements[11] * this.elements[13];\n        var fB5 = this.elements[10] * this.elements[15] - this.elements[11] * this.elements[14];\n\n        // Determinant\n        var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;\n\n        // Account for a very small value\n        // return false if not successful.\n        if (Math.abs(fDet) <= 1e-9) {\n          return false;\n        }\n\n        var kInv = [];\n        kInv[0]  = +this.elements[5] * fB5 - this.elements[6] * fB4 + this.elements[7] * fB3;\n        kInv[4]  = -this.elements[4] * fB5 + this.elements[6] * fB2 - this.elements[7] * fB1;\n        kInv[8]  = +this.elements[4] * fB4 - this.elements[5] * fB2 + this.elements[7] * fB0;\n        kInv[12] = -this.elements[4] * fB3 + this.elements[5] * fB1 - this.elements[6] * fB0;\n        kInv[1]  = -this.elements[1] * fB5 + this.elements[2] * fB4 - this.elements[3] * fB3;\n        kInv[5]  = +this.elements[0] * fB5 - this.elements[2] * fB2 + this.elements[3] * fB1;\n        kInv[9]  = -this.elements[0] * fB4 + this.elements[1] * fB2 - this.elements[3] * fB0;\n        kInv[13] = +this.elements[0] * fB3 - this.elements[1] * fB1 + this.elements[2] * fB0;\n        kInv[2]  = +this.elements[13] * fA5 - this.elements[14] * fA4 + this.elements[15] * fA3;\n        kInv[6]  = -this.elements[12] * fA5 + this.elements[14] * fA2 - this.elements[15] * fA1;\n        kInv[10] = +this.elements[12] * fA4 - this.elements[13] * fA2 + this.elements[15] * fA0;\n        kInv[14] = -this.elements[12] * fA3 + this.elements[13] * fA1 - this.elements[14] * fA0;\n        kInv[3]  = -this.elements[9] * fA5 + this.elements[10] * fA4 - this.elements[11] * fA3;\n        kInv[7]  = +this.elements[8] * fA5 - this.elements[10] * fA2 + this.elements[11] * fA1;\n        kInv[11] = -this.elements[8] * fA4 + this.elements[9] * fA2 - this.elements[11] * fA0;\n        kInv[15] = +this.elements[8] * fA3 - this.elements[9] * fA1 + this.elements[10] * fA0;\n\n        // Inverse using Determinant\n        var fInvDet = 1.0 / fDet;\n        kInv[0]  *= fInvDet;\n        kInv[1]  *= fInvDet;\n        kInv[2]  *= fInvDet;\n        kInv[3]  *= fInvDet;\n        kInv[4]  *= fInvDet;\n        kInv[5]  *= fInvDet;\n        kInv[6]  *= fInvDet;\n        kInv[7]  *= fInvDet;\n        kInv[8]  *= fInvDet;\n        kInv[9]  *= fInvDet;\n        kInv[10] *= fInvDet;\n        kInv[11] *= fInvDet;\n        kInv[12] *= fInvDet;\n        kInv[13] *= fInvDet;\n        kInv[14] *= fInvDet;\n        kInv[15] *= fInvDet;\n\n        this.elements = kInv.slice();\n        return true;\n      },\n      toString: function() {\n        var str = \"\";\n        for (var i = 0; i < 15; i++) {\n          str += this.elements[i] + \", \";\n        }\n        str += this.elements[15];\n        return str;\n      },\n      /**\n       * @member PMatrix3D\n       * The print() function prints out the elements of this matrix\n       */\n      print: function() {\n        var digits = printMatrixHelper(this.elements);\n\n        var output = \"\" + p.nfs(this.elements[0], digits, 4) + \" \" + p.nfs(this.elements[1], digits, 4) +\n                     \" \" + p.nfs(this.elements[2], digits, 4) + \" \" + p.nfs(this.elements[3], digits, 4) +\n                     \"\\n\" + p.nfs(this.elements[4], digits, 4) + \" \" + p.nfs(this.elements[5], digits, 4) +\n                     \" \" + p.nfs(this.elements[6], digits, 4) + \" \" + p.nfs(this.elements[7], digits, 4) +\n                     \"\\n\" + p.nfs(this.elements[8], digits, 4) + \" \" + p.nfs(this.elements[9], digits, 4) +\n                     \" \" + p.nfs(this.elements[10], digits, 4) + \" \" + p.nfs(this.elements[11], digits, 4) +\n                     \"\\n\" + p.nfs(this.elements[12], digits, 4) + \" \" + p.nfs(this.elements[13], digits, 4) +\n                     \" \" + p.nfs(this.elements[14], digits, 4) + \" \" + p.nfs(this.elements[15], digits, 4) + \"\\n\\n\";\n        p.println(output);\n      },\n      invTranslate: function(tx, ty, tz) {\n        this.preApply(1, 0, 0, -tx, 0, 1, 0, -ty, 0, 0, 1, -tz, 0, 0, 0, 1);\n      },\n      invRotateX: function(angle) {\n        var c = Math.cos(-angle);\n        var s = Math.sin(-angle);\n        this.preApply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);\n      },\n      invRotateY: function(angle) {\n        var c = Math.cos(-angle);\n        var s = Math.sin(-angle);\n        this.preApply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\n      },\n      invRotateZ: function(angle) {\n        var c = Math.cos(-angle);\n        var s = Math.sin(-angle);\n        this.preApply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n      },\n      invScale: function(x, y, z) {\n        this.preApply([1 / x, 0, 0, 0, 0, 1 / y, 0, 0, 0, 0, 1 / z, 0, 0, 0, 0, 1]);\n      }\n    };\n\n    /**\n     * @private\n     * The matrix stack stores the transformations and translations that occur within the space.\n     */\n    var PMatrixStack = p.PMatrixStack = function() {\n      this.matrixStack = [];\n    };\n\n    /**\n     * @member PMatrixStack\n     * load pushes the matrix given in the function into the stack\n     *\n     * @param {Object | Array} matrix the matrix to be pushed into the stack\n     */\n    PMatrixStack.prototype.load = function() {\n      var tmpMatrix = drawing.$newPMatrix();\n\n      if (arguments.length === 1) {\n        tmpMatrix.set(arguments[0]);\n      } else {\n        tmpMatrix.set(arguments);\n      }\n      this.matrixStack.push(tmpMatrix);\n    };\n\n    Drawing2D.prototype.$newPMatrix = function() {\n      return new PMatrix2D();\n    };\n\n    Drawing3D.prototype.$newPMatrix = function() {\n      return new PMatrix3D();\n    };\n\n    /**\n     * @member PMatrixStack\n     * push adds a duplicate of the top of the stack onto the stack - uses the peek function\n     */\n    PMatrixStack.prototype.push = function() {\n      this.matrixStack.push(this.peek());\n    };\n\n    /**\n     * @member PMatrixStack\n     * pop removes returns the matrix at the top of the stack\n     *\n     * @returns {Object} the matrix at the top of the stack\n     */\n    PMatrixStack.prototype.pop = function() {\n      return this.matrixStack.pop();\n    };\n\n    /**\n     * @member PMatrixStack\n     * peek returns but doesn't remove the matrix at the top of the stack\n     *\n     * @returns {Object} the matrix at the top of the stack\n     */\n    PMatrixStack.prototype.peek = function() {\n      var tmpMatrix = drawing.$newPMatrix();\n\n      tmpMatrix.set(this.matrixStack[this.matrixStack.length - 1]);\n      return tmpMatrix;\n    };\n\n    /**\n     * @member PMatrixStack\n     * this function multiplies the matrix at the top of the stack with the matrix given as a parameter\n     *\n     * @param {Object | Array} matrix the matrix to be multiplied into the stack\n     */\n    PMatrixStack.prototype.mult = function(matrix) {\n      this.matrixStack[this.matrixStack.length - 1].apply(matrix);\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Array handling\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * The split() function breaks a string into pieces using a character or string\n    * as the divider. The delim  parameter specifies the character or characters that\n    * mark the boundaries between each piece. A String[] array is returned that contains\n    * each of the pieces.\n    * If the result is a set of numbers, you can convert the String[] array to to a float[]\n    * or int[] array using the datatype conversion functions int() and float() (see example above).\n    * The splitTokens() function works in a similar fashion, except that it splits using a range\n    * of characters instead of a specific character or sequence.\n    *\n    * @param {String} str       the String to be split\n    * @param {String} delim     the character or String used to separate the data\n    *\n    * @returns {string[]} The new string array\n    *\n    * @see splitTokens\n    * @see join\n    * @see trim\n    */\n    p.split = function(str, delim) {\n      return str.split(delim);\n    };\n\n    /**\n    * The splitTokens() function splits a String at one or many character \"tokens.\" The tokens\n    * parameter specifies the character or characters to be used as a boundary.\n    * If no tokens character is specified, any whitespace character is used to split.\n    * Whitespace characters include tab (\\t), line feed (\\n), carriage return (\\r), form\n    * feed (\\f), and space. To convert a String to an array of integers or floats, use the\n    * datatype conversion functions int() and float() to convert the array of Strings.\n    *\n    * @param {String} str       the String to be split\n    * @param {Char[]} tokens    list of individual characters that will be used as separators\n    *\n    * @returns {string[]} The new string array\n    *\n    * @see split\n    * @see join\n    * @see trim\n    */\n    p.splitTokens = function(str, tokens) {\n      if (tokens === undef) {\n        return str.split(/\\s+/g);\n      }\n\n      var chars = tokens.split(/()/g),\n          buffer = \"\",\n          len = str.length,\n          i, c,\n          tokenized = [];\n\n      for (i = 0; i < len; i++) {\n        c = str[i];\n        if (chars.indexOf(c) > -1) {\n          if (buffer !== \"\") {\n            tokenized.push(buffer);\n          }\n          buffer = \"\";\n        } else {\n          buffer += c;\n        }\n      }\n\n      if (buffer !== \"\") {\n        tokenized.push(buffer);\n      }\n\n      return tokenized;\n    };\n\n    /**\n    * Expands an array by one element and adds data to the new position. The datatype of\n    * the element parameter must be the same as the datatype of the array.\n    * When using an array of objects, the data returned from the function must be cast to\n    * the object array's data type. For example: SomeClass[] items = (SomeClass[])\n    * append(originalArray, element).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array boolean[],\n    * byte[], char[], int[], float[], or String[], or an array of objects\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} element new data for the array\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see shorten\n    * @see expand\n    */\n    p.append = function(array, element) {\n      array[array.length] = element;\n      return array;\n    };\n\n    /**\n    * Concatenates two arrays. For example, concatenating the array { 1, 2, 3 } and the\n    * array { 4, 5, 6 } yields { 1, 2, 3, 4, 5, 6 }. Both parameters must be arrays of the\n    * same datatype.\n    * When using an array of objects, the data returned from the function must be cast to the\n    * object array's data type. For example: SomeClass[] items = (SomeClass[]) concat(array1, array2).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array1 boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array2 boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see splice\n    */\n    p.concat = function(array1, array2) {\n      return array1.concat(array2);\n    };\n\n    /**\n     * Sorts an array of numbers from smallest to largest and puts an array of\n     * words in alphabetical order. The original array is not modified, a\n     * re-ordered array is returned. The count parameter states the number of\n     * elements to sort. For example if there are 12 elements in an array and\n     * if count is the value 5, only the first five elements on the array will\n     * be sorted. Alphabetical ordering is case insensitive.\n     *\n     * @param {String[] | int[] | float[]}  array Array of elements to sort\n     * @param {int}                         numElem Number of elements to sort\n     *\n     * @returns {String[] | int[] | float[]} Array (same datatype as the input)\n     *\n     * @see reverse\n    */\n    p.sort = function(array, numElem) {\n      var ret = [];\n\n      // depending on the type used (int, float) or string\n      // we'll need to use a different compare function\n      if (array.length > 0) {\n        // copy since we need to return another array\n        var elemsToCopy = numElem > 0 ? numElem : array.length;\n        for (var i = 0; i < elemsToCopy; i++) {\n          ret.push(array[i]);\n        }\n        if (typeof array[0] === \"string\") {\n          ret.sort();\n        }\n        // int or float\n        else {\n          ret.sort(function(a, b) {\n            return a - b;\n          });\n        }\n\n        // copy on the rest of the elements that were not sorted in case the user\n        // only wanted a subset of an array to be sorted.\n        if (numElem > 0) {\n          for (var j = ret.length; j < array.length; j++) {\n            ret.push(array[j]);\n          }\n        }\n      }\n      return ret;\n    };\n\n    /**\n    * Inserts a value or array of values into an existing array. The first two parameters must\n    * be of the same datatype. The array parameter defines the array which will be modified\n    * and the second parameter defines the data which will be inserted. When using an array\n    * of objects, the data returned from the function must be cast to the object array's data\n    * type. For example: SomeClass[] items = (SomeClass[]) splice(array1, array2, index).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    * @param {boolean|byte|char|int|float|String|boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects}\n    * value boolean, byte, char, int, float, String, boolean[], byte[], char[], int[],\n    * float[], String[], or other Object: value or an array of objects to be spliced in\n    * @param {int} index                position in the array from which to insert data\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see contract\n    * @see subset\n    */\n    p.splice = function(array, value, index) {\n\n      // Trying to splice an empty array into \"array\" in P5 won't do\n      // anything, just return the original.\n      if(value.length === 0)\n      {\n        return array;\n      }\n\n      // If the second argument was an array, we'll need to iterate over all\n      // the \"value\" elements and add one by one because\n      // array.splice(index, 0, value);\n      // would create a multi-dimensional array which isn't what we want.\n      if(value instanceof Array) {\n        for(var i = 0, j = index; i < value.length; j++,i++) {\n          array.splice(j, 0, value[i]);\n        }\n      } else {\n        array.splice(index, 0, value);\n      }\n\n      return array;\n    };\n\n    /**\n    * Extracts an array of elements from an existing array. The array parameter defines the\n    * array from which the elements will be copied and the offset and length parameters determine\n    * which elements to extract. If no length is given, elements will be extracted from the offset\n    * to the end of the array. When specifying the offset remember the first array element is 0.\n    * This function does not change the source array.\n    * When using an array of objects, the data returned from the function must be cast to the\n    * object array's data type.\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    * @param {int} offset         position to begin\n    * @param {int} length         number of values to extract\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see splice\n    */\n    p.subset = function(array, offset, length) {\n      var end = (length !== undef) ? offset + length : array.length;\n      return array.slice(offset, end);\n    };\n\n    /**\n    * Combines an array of Strings into one String, each separated by the character(s) used for\n    * the separator parameter. To join arrays of ints or floats, it's necessary to first convert\n    * them to strings using nf() or nfs().\n    *\n    * @param {Array} array              array of Strings\n    * @param {char|String} separator    char or String to be placed between each item\n    *\n    * @returns {String} The combined string\n    *\n    * @see split\n    * @see trim\n    * @see nf\n    * @see nfs\n    */\n    p.join = function(array, seperator) {\n      return array.join(seperator);\n    };\n\n    /**\n    * Decreases an array by one element and returns the shortened array. When using an\n    * array of objects, the data returned from the function must be cast to the object array's\n    * data type. For example: SomeClass[] items = (SomeClass[]) shorten(originalArray).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array\n    * boolean[], byte[], char[], int[], float[], or String[], or an array of objects\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see append\n    * @see expand\n    */\n    p.shorten = function(ary) {\n      var newary = [];\n\n      // copy array into new array\n      var len = ary.length;\n      for (var i = 0; i < len; i++) {\n        newary[i] = ary[i];\n      }\n      newary.pop();\n\n      return newary;\n    };\n\n    /**\n    * Increases the size of an array. By default, this function doubles the size of the array,\n    * but the optional newSize parameter provides precise control over the increase in size.\n    * When using an array of objects, the data returned from the function must be cast to the\n    * object array's data type. For example: SomeClass[] items = (SomeClass[]) expand(originalArray).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} ary\n    * boolean[], byte[], char[], int[], float[], String[], or an array of objects\n    * @param {int} newSize              positive int: new size for the array\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see contract\n    */\n    p.expand = function(ary, targetSize) {\n      var temp = ary.slice(0),\n          newSize = targetSize || ary.length * 2;\n      temp.length = newSize;\n      return temp;\n    };\n\n    /**\n    * Copies an array (or part of an array) to another array. The src array is copied to the\n    * dst array, beginning at the position specified by srcPos and into the position specified\n    * by dstPos. The number of elements to copy is determined by length. The simplified version\n    * with two arguments copies an entire array to another of the same size. It is equivalent\n    * to \"arrayCopy(src, 0, dst, 0, src.length)\". This function is far more efficient for copying\n    * array data than iterating through a for and copying each element.\n    *\n    * @param {Array} src an array of any data type: the source array\n    * @param {Array} dest an array of any data type (as long as it's the same as src): the destination array\n    * @param {int} srcPos     starting position in the source array\n    * @param {int} destPos    starting position in the destination array\n    * @param {int} length     number of array elements to be copied\n    *\n    * @returns none\n    */\n    p.arrayCopy = function() { // src, srcPos, dest, destPos, length) {\n      var src, srcPos = 0, dest, destPos = 0, length;\n\n      if (arguments.length === 2) {\n        // recall itself and copy src to dest from start index 0 to 0 of src.length\n        src = arguments[0];\n        dest = arguments[1];\n        length = src.length;\n      } else if (arguments.length === 3) {\n        // recall itself and copy src to dest from start index 0 to 0 of length\n        src = arguments[0];\n        dest = arguments[1];\n        length = arguments[2];\n      } else if (arguments.length === 5) {\n        src = arguments[0];\n        srcPos = arguments[1];\n        dest = arguments[2];\n        destPos = arguments[3];\n        length = arguments[4];\n      }\n\n      // copy src to dest from index srcPos to index destPos of length recursivly on objects\n      for (var i = srcPos, j = destPos; i < length + srcPos; i++, j++) {\n        if (dest[j] !== undef) {\n          dest[j] = src[i];\n        } else {\n          throw \"array index out of bounds exception\";\n        }\n      }\n    };\n\n    /**\n    * Reverses the order of an array.\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]} array\n    * boolean[], byte[], char[], int[], float[], or String[]\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see sort\n    */\n    p.reverse = function(array) {\n      return array.reverse();\n    };\n\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Color functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    // helper functions for internal blending modes\n    p.mix = function(a, b, f) {\n      return a + (((b - a) * f) >> 8);\n    };\n\n    p.peg = function(n) {\n      return (n < 0) ? 0 : ((n > 255) ? 255 : n);\n    };\n\n    // blending modes\n    /**\n    * These are internal blending modes used for BlendColor()\n    *\n    * @param {Color} c1       First Color to blend\n    * @param {Color} c2       Second Color to blend\n    *\n    * @returns {Color}        The blended Color\n    *\n    * @see BlendColor\n    * @see Blend\n    */\n    p.modes = (function() {\n      var ALPHA_MASK = PConstants.ALPHA_MASK,\n        RED_MASK = PConstants.RED_MASK,\n        GREEN_MASK = PConstants.GREEN_MASK,\n        BLUE_MASK = PConstants.BLUE_MASK,\n        min = Math.min,\n        max = Math.max;\n\n      function applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb) {\n        var a = min(((c1 & 0xff000000) >>> 24) + f, 0xff) << 24;\n\n        var r = (ar + (((cr - ar) * f) >> 8));\n        r = ((r < 0) ? 0 : ((r > 255) ? 255 : r)) << 16;\n\n        var g = (ag + (((cg - ag) * f) >> 8));\n        g = ((g < 0) ? 0 : ((g > 255) ? 255 : g)) << 8;\n\n        var b = ab + (((cb - ab) * f) >> 8);\n        b = (b < 0) ? 0 : ((b > 255) ? 255 : b);\n\n        return (a | r | g | b);\n      }\n\n      return {\n        replace: function(c1, c2) {\n          return c2;\n        },\n        blend: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK),\n            ag = (c1 & GREEN_MASK),\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK),\n            bg = (c2 & GREEN_MASK),\n            bb = (c2 & BLUE_MASK);\n\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  (ar + (((br - ar) * f) >> 8)) & RED_MASK |\n                  (ag + (((bg - ag) * f) >> 8)) & GREEN_MASK |\n                  (ab + (((bb - ab) * f) >> 8)) & BLUE_MASK);\n        },\n        add: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24;\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  min(((c1 & RED_MASK) + ((c2 & RED_MASK) >> 8) * f), RED_MASK) & RED_MASK |\n                  min(((c1 & GREEN_MASK) + ((c2 & GREEN_MASK) >> 8) * f), GREEN_MASK) & GREEN_MASK |\n                  min((c1 & BLUE_MASK) + (((c2 & BLUE_MASK) * f) >> 8), BLUE_MASK));\n        },\n        subtract: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24;\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  max(((c1 & RED_MASK) - ((c2 & RED_MASK) >> 8) * f), GREEN_MASK) & RED_MASK |\n                  max(((c1 & GREEN_MASK) - ((c2 & GREEN_MASK) >> 8) * f), BLUE_MASK) & GREEN_MASK |\n                  max((c1 & BLUE_MASK) - (((c2 & BLUE_MASK) * f) >> 8), 0));\n        },\n        lightest: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24;\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  max(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f) & RED_MASK |\n                  max(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f) & GREEN_MASK |\n                  max(c1 & BLUE_MASK, ((c2 & BLUE_MASK) * f) >> 8));\n        },\n        darkest: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK),\n            ag = (c1 & GREEN_MASK),\n            ab = (c1 & BLUE_MASK),\n            br = min(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f),\n            bg = min(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f),\n            bb = min(c1 & BLUE_MASK, ((c2 & BLUE_MASK) * f) >> 8);\n\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  (ar + (((br - ar) * f) >> 8)) & RED_MASK |\n                  (ag + (((bg - ag) * f) >> 8)) & GREEN_MASK |\n                  (ab + (((bb - ab) * f) >> 8)) & BLUE_MASK);\n        },\n        difference: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = (ar > br) ? (ar - br) : (br - ar),\n            cg = (ag > bg) ? (ag - bg) : (bg - ag),\n            cb = (ab > bb) ? (ab - bb) : (bb - ab);\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        exclusion: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = ar + br - ((ar * br) >> 7),\n            cg = ag + bg - ((ag * bg) >> 7),\n            cb = ab + bb - ((ab * bb) >> 7);\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        multiply: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = (ar * br) >> 8,\n            cg = (ag * bg) >> 8,\n            cb = (ab * bb) >> 8;\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        screen: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = 255 - (((255 - ar) * (255 - br)) >> 8),\n            cg = 255 - (((255 - ag) * (255 - bg)) >> 8),\n            cb = 255 - (((255 - ab) * (255 - bb)) >> 8);\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        hard_light: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = (br < 128) ? ((ar * br) >> 7) : (255 - (((255 - ar) * (255 - br)) >> 7)),\n            cg = (bg < 128) ? ((ag * bg) >> 7) : (255 - (((255 - ag) * (255 - bg)) >> 7)),\n            cb = (bb < 128) ? ((ab * bb) >> 7) : (255 - (((255 - ab) * (255 - bb)) >> 7));\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        soft_light: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = ((ar * br) >> 7) + ((ar * ar) >> 8) - ((ar * ar * br) >> 15),\n            cg = ((ag * bg) >> 7) + ((ag * ag) >> 8) - ((ag * ag * bg) >> 15),\n            cb = ((ab * bb) >> 7) + ((ab * ab) >> 8) - ((ab * ab * bb) >> 15);\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        overlay: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = (ar < 128) ? ((ar * br) >> 7) : (255 - (((255 - ar) * (255 - br)) >> 7)),\n            cg = (ag < 128) ? ((ag * bg) >> 7) : (255 - (((255 - ag) * (255 - bg)) >> 7)),\n            cb = (ab < 128) ? ((ab * bb) >> 7) : (255 - (((255 - ab) * (255 - bb)) >> 7));\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        dodge: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK);\n\n          var cr = 255;\n          if (br !== 255) {\n            cr = (ar << 8) / (255 - br);\n            cr = (cr < 0) ? 0 : ((cr > 255) ? 255 : cr);\n          }\n\n          var cg = 255;\n          if (bg !== 255) {\n            cg = (ag << 8) / (255 - bg);\n            cg = (cg < 0) ? 0 : ((cg > 255) ? 255 : cg);\n          }\n\n          var cb = 255;\n          if (bb !== 255) {\n            cb = (ab << 8) / (255 - bb);\n            cb = (cb < 0) ? 0 : ((cb > 255) ? 255 : cb);\n          }\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        burn: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK);\n\n          var cr = 0;\n          if (br !== 0) {\n            cr = ((255 - ar) << 8) / br;\n            cr = 255 - ((cr < 0) ? 0 : ((cr > 255) ? 255 : cr));\n          }\n\n          var cg = 0;\n          if (bg !== 0) {\n            cg = ((255 - ag) << 8) / bg;\n            cg = 255 - ((cg < 0) ? 0 : ((cg > 255) ? 255 : cg));\n          }\n\n          var cb = 0;\n          if (bb !== 0) {\n            cb = ((255 - ab) << 8) / bb;\n            cb = 255 - ((cb < 0) ? 0 : ((cb > 255) ? 255 : cb));\n          }\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        }\n      };\n    }());\n\n    function color$4(aValue1, aValue2, aValue3, aValue4) {\n      var r, g, b, a;\n\n      if (curColorMode === PConstants.HSB) {\n        var rgb = p.color.toRGB(aValue1, aValue2, aValue3);\n        r = rgb[0];\n        g = rgb[1];\n        b = rgb[2];\n      } else {\n        r = Math.round(255 * (aValue1 / colorModeX));\n        g = Math.round(255 * (aValue2 / colorModeY));\n        b = Math.round(255 * (aValue3 / colorModeZ));\n      }\n\n      a = Math.round(255 * (aValue4 / colorModeA));\n\n      // Limit values less than 0 and greater than 255\n      r = (r < 0) ? 0 : r;\n      g = (g < 0) ? 0 : g;\n      b = (b < 0) ? 0 : b;\n      a = (a < 0) ? 0 : a;\n      r = (r > 255) ? 255 : r;\n      g = (g > 255) ? 255 : g;\n      b = (b > 255) ? 255 : b;\n      a = (a > 255) ? 255 : a;\n\n      // Create color int\n      return (a << 24) & PConstants.ALPHA_MASK | (r << 16) & PConstants.RED_MASK | (g << 8) & PConstants.GREEN_MASK | b & PConstants.BLUE_MASK;\n    }\n\n    function color$2(aValue1, aValue2) {\n      var a;\n\n      // Color int and alpha\n      if (aValue1 & PConstants.ALPHA_MASK) {\n        a = Math.round(255 * (aValue2 / colorModeA));\n        // Limit values less than 0 and greater than 255\n        a = (a > 255) ? 255 : a;\n        a = (a < 0) ? 0 : a;\n\n        return aValue1 - (aValue1 & PConstants.ALPHA_MASK) + ((a << 24) & PConstants.ALPHA_MASK);\n      }\n      // Grayscale and alpha\n      if (curColorMode === PConstants.RGB) {\n        return color$4(aValue1, aValue1, aValue1, aValue2);\n      }\n      if (curColorMode === PConstants.HSB) {\n        return color$4(0, 0, (aValue1 / colorModeX) * colorModeZ, aValue2);\n      }\n    }\n\n    function color$1(aValue1) {\n      // Grayscale\n      if (aValue1 <= colorModeX && aValue1 >= 0) {\n          if (curColorMode === PConstants.RGB) {\n            return color$4(aValue1, aValue1, aValue1, colorModeA);\n          }\n          if (curColorMode === PConstants.HSB) {\n            return color$4(0, 0, (aValue1 / colorModeX) * colorModeZ, colorModeA);\n          }\n      }\n      // Color int\n      if (aValue1) {\n        if (aValue1 > 2147483647) {\n          // Java Overflow\n          aValue1 -= 4294967296;\n        }\n        return aValue1;\n      }\n    }\n\n    /**\n    * Creates colors for storing in variables of the color datatype. The parameters are\n    * interpreted as RGB or HSB values depending on the current colorMode(). The default\n    * mode is RGB values from 0 to 255 and therefore, the function call color(255, 204, 0)\n    * will return a bright yellow color. More about how colors are stored can be found in\n    * the reference for the color datatype.\n    *\n    * @param {int|float} aValue1        red or hue or grey values relative to the current color range.\n    * Also can be color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n    * @param {int|float} aValue2        green or saturation values relative to the current color range\n    * @param {int|float} aValue3        blue or brightness values relative to the current color range\n    * @param {int|float} aValue4        relative to current color range. Represents alpha\n    *\n    * @returns {color} the color\n    *\n    * @see colorMode\n    */\n    p.color = function(aValue1, aValue2, aValue3, aValue4) {\n\n      // 4 arguments: (R, G, B, A) or (H, S, B, A)\n      if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef && aValue4 !== undef) {\n        return color$4(aValue1, aValue2, aValue3, aValue4);\n      }\n\n      // 3 arguments: (R, G, B) or (H, S, B)\n      if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef) {\n        return color$4(aValue1, aValue2, aValue3, colorModeA);\n      }\n\n      // 2 arguments: (Color, A) or (Grayscale, A)\n      if (aValue1 !== undef && aValue2 !== undef) {\n        return color$2(aValue1, aValue2);\n      }\n\n      // 1 argument: (Grayscale) or (Color)\n      if (typeof aValue1 === \"number\") {\n        return color$1(aValue1);\n      }\n\n      // Default\n      return color$4(colorModeX, colorModeY, colorModeZ, colorModeA);\n    };\n\n    // Ease of use function to extract the colour bits into a string\n    p.color.toString = function(colorInt) {\n      return \"rgba(\" + ((colorInt & PConstants.RED_MASK) >>> 16) + \",\" + ((colorInt & PConstants.GREEN_MASK) >>> 8) +\n             \",\" + ((colorInt & PConstants.BLUE_MASK)) + \",\" + ((colorInt & PConstants.ALPHA_MASK) >>> 24) / 255 + \")\";\n    };\n\n    // Easy of use function to pack rgba values into a single bit-shifted color int.\n    p.color.toInt = function(r, g, b, a) {\n      return (a << 24) & PConstants.ALPHA_MASK | (r << 16) & PConstants.RED_MASK | (g << 8) & PConstants.GREEN_MASK | b & PConstants.BLUE_MASK;\n    };\n\n    // Creates a simple array in [R, G, B, A] format, [255, 255, 255, 255]\n    p.color.toArray = function(colorInt) {\n      return [(colorInt & PConstants.RED_MASK) >>> 16, (colorInt & PConstants.GREEN_MASK) >>> 8,\n              colorInt & PConstants.BLUE_MASK, (colorInt & PConstants.ALPHA_MASK) >>> 24];\n    };\n\n    // Creates a WebGL color array in [R, G, B, A] format. WebGL wants the color ranges between 0 and 1, [1, 1, 1, 1]\n    p.color.toGLArray = function(colorInt) {\n      return [((colorInt & PConstants.RED_MASK) >>> 16) / 255, ((colorInt & PConstants.GREEN_MASK) >>> 8) / 255,\n              (colorInt & PConstants.BLUE_MASK) / 255, ((colorInt & PConstants.ALPHA_MASK) >>> 24) / 255];\n    };\n\n    // HSB conversion function from Mootools, MIT Licensed\n    p.color.toRGB = function(h, s, b) {\n      // Limit values greater than range\n      h = (h > colorModeX) ? colorModeX : h;\n      s = (s > colorModeY) ? colorModeY : s;\n      b = (b > colorModeZ) ? colorModeZ : b;\n\n      h = (h / colorModeX) * 360;\n      s = (s / colorModeY) * 100;\n      b = (b / colorModeZ) * 100;\n\n      var br = Math.round(b / 100 * 255);\n\n      if (s === 0) { // Grayscale\n        return [br, br, br];\n      }\n      var hue = h % 360;\n      var f = hue % 60;\n      var p = Math.round((b * (100 - s)) / 10000 * 255);\n      var q = Math.round((b * (6000 - s * f)) / 600000 * 255);\n      var t = Math.round((b * (6000 - s * (60 - f))) / 600000 * 255);\n      switch (Math.floor(hue / 60)) {\n      case 0:\n        return [br, t, p];\n      case 1:\n        return [q, br, p];\n      case 2:\n        return [p, br, t];\n      case 3:\n        return [p, q, br];\n      case 4:\n        return [t, p, br];\n      case 5:\n        return [br, p, q];\n      }\n    };\n\n    function colorToHSB(colorInt) {\n      var red, green, blue;\n\n      red   = ((colorInt & PConstants.RED_MASK) >>> 16) / 255;\n      green = ((colorInt & PConstants.GREEN_MASK) >>> 8) / 255;\n      blue  = (colorInt & PConstants.BLUE_MASK) / 255;\n\n      var max = p.max(p.max(red,green), blue),\n          min = p.min(p.min(red,green), blue),\n          hue, saturation;\n\n      if (min === max) {\n        return [0, 0, max*colorModeZ];\n      }\n      saturation = (max - min) / max;\n\n      if (red === max) {\n        hue = (green - blue) / (max - min);\n      } else if (green === max) {\n        hue = 2 + ((blue - red) / (max - min));\n      } else {\n        hue = 4 + ((red - green) / (max - min));\n      }\n\n      hue /= 6;\n\n      if (hue < 0) {\n        hue += 1;\n      } else if (hue > 1) {\n        hue -= 1;\n      }\n      return [hue*colorModeX, saturation*colorModeY, max*colorModeZ];\n    }\n\n    /**\n    * Extracts the brightness value from a color.\n    *\n    * @param {color} colInt any value of the color datatype\n    *\n    * @returns {float} The brightness color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see hue\n    * @see saturation\n    */\n    p.brightness = function(colInt){\n      return colorToHSB(colInt)[2];\n    };\n\n    /**\n    * Extracts the saturation value from a color.\n    *\n    * @param {color} colInt any value of the color datatype\n    *\n    * @returns {float} The saturation color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see hue\n    * @see brightness\n    */\n    p.saturation = function(colInt){\n      return colorToHSB(colInt)[1];\n    };\n\n    /**\n    * Extracts the hue value from a color.\n    *\n    * @param {color} colInt any value of the color datatype\n    *\n    * @returns {float} The hue color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see saturation\n    * @see brightness\n    */\n    p.hue = function(colInt){\n      return colorToHSB(colInt)[0];\n    };\n\n    /**\n    * Extracts the red value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The red color value.\n    *\n    * @see green\n    * @see blue\n    * @see alpha\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */\n    p.red = function(aColor) {\n      return ((aColor & PConstants.RED_MASK) >>> 16) / 255 * colorModeX;\n    };\n\n    /**\n    * Extracts the green value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The green color value.\n    *\n    * @see red\n    * @see blue\n    * @see alpha\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */\n    p.green = function(aColor) {\n      return ((aColor & PConstants.GREEN_MASK) >>> 8) / 255 * colorModeY;\n    };\n\n    /**\n    * Extracts the blue value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The blue color value.\n    *\n    * @see red\n    * @see green\n    * @see alpha\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */\n    p.blue = function(aColor) {\n      return (aColor & PConstants.BLUE_MASK) / 255 * colorModeZ;\n    };\n\n    /**\n    * Extracts the alpha value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The alpha color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */\n    p.alpha = function(aColor) {\n      return ((aColor & PConstants.ALPHA_MASK) >>> 24) / 255 * colorModeA;\n    };\n\n    /**\n    * Calculates a color or colors between two colors at a specific increment.\n    * The amt parameter is the amount to interpolate between the two values where 0.0\n    * equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc.\n    *\n    * @param {color} c1     interpolate from this color\n    * @param {color} c2     interpolate to this color\n    * @param {float} amt    between 0.0 and 1.0\n    *\n    * @returns {float} The blended color.\n    *\n    * @see blendColor\n    * @see color\n    */\n    p.lerpColor = function(c1, c2, amt) {\n      var r, g, b, a, r1, g1, b1, a1, r2, g2, b2, a2;\n      var hsb1, hsb2, rgb, h, s;\n      var colorBits1 = p.color(c1);\n      var colorBits2 = p.color(c2);\n\n      if (curColorMode === PConstants.HSB) {\n        // Special processing for HSB mode.\n        // Get HSB and Alpha values for Color 1 and 2\n        hsb1 = colorToHSB(colorBits1);\n        a1 = ((colorBits1 & PConstants.ALPHA_MASK) >>> 24) / colorModeA;\n        hsb2 = colorToHSB(colorBits2);\n        a2 = ((colorBits2 & PConstants.ALPHA_MASK) >>> 24) / colorModeA;\n\n        // Return lerp value for each channel, for HSB components\n        h = p.lerp(hsb1[0], hsb2[0], amt);\n        s = p.lerp(hsb1[1], hsb2[1], amt);\n        b = p.lerp(hsb1[2], hsb2[2], amt);\n        rgb = p.color.toRGB(h, s, b);\n        // ... and for Alpha-range\n        a = p.lerp(a1, a2, amt) * colorModeA;\n\n        return (a << 24) & PConstants.ALPHA_MASK |\n               (rgb[0] << 16) & PConstants.RED_MASK |\n               (rgb[1] << 8) & PConstants.GREEN_MASK |\n               rgb[2] & PConstants.BLUE_MASK;\n      }\n\n      // Get RGBA values for Color 1 to floats\n      r1 = (colorBits1 & PConstants.RED_MASK) >>> 16;\n      g1 = (colorBits1 & PConstants.GREEN_MASK) >>> 8;\n      b1 = (colorBits1 & PConstants.BLUE_MASK);\n      a1 = ((colorBits1 & PConstants.ALPHA_MASK) >>> 24) / colorModeA;\n\n      // Get RGBA values for Color 2 to floats\n      r2 = (colorBits2 & PConstants.RED_MASK) >>> 16;\n      g2 = (colorBits2 & PConstants.GREEN_MASK) >>> 8;\n      b2 = (colorBits2 & PConstants.BLUE_MASK);\n      a2 = ((colorBits2 & PConstants.ALPHA_MASK) >>> 24) / colorModeA;\n\n      // Return lerp value for each channel, INT for color, Float for Alpha-range\n      r = p.lerp(r1, r2, amt) | 0;\n      g = p.lerp(g1, g2, amt) | 0;\n      b = p.lerp(b1, b2, amt) | 0;\n      a = p.lerp(a1, a2, amt) * colorModeA;\n\n      return (a << 24) & PConstants.ALPHA_MASK |\n             (r << 16) & PConstants.RED_MASK |\n             (g << 8) & PConstants.GREEN_MASK |\n             b & PConstants.BLUE_MASK;\n    };\n\n    /**\n    * Changes the way Processing interprets color data. By default, fill(), stroke(), and background()\n    * colors are set by values between 0 and 255 using the RGB color model. It is possible to change the\n    * numerical range used for specifying colors and to switch color systems. For example, calling colorMode(RGB, 1.0)\n    * will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the\n    * parameters range1, range2, range3, and range 4.\n    *\n    * @param {MODE} mode Either RGB or HSB, corresponding to Red/Green/Blue and Hue/Saturation/Brightness\n    * @param {int|float} range              range for all color elements\n    * @param {int|float} range1             range for the red or hue depending on the current color mode\n    * @param {int|float} range2             range for the green or saturation depending on the current color mode\n    * @param {int|float} range3             range for the blue or brightness depending on the current color mode\n    * @param {int|float} range4             range for the alpha\n    *\n    * @returns none\n    *\n    * @see background\n    * @see fill\n    * @see stroke\n    */\n    p.colorMode = function() { // mode, range1, range2, range3, range4\n      curColorMode = arguments[0];\n      if (arguments.length > 1) {\n        colorModeX   = arguments[1];\n        colorModeY   = arguments[2] || arguments[1];\n        colorModeZ   = arguments[3] || arguments[1];\n        colorModeA   = arguments[4] || arguments[1];\n      }\n    };\n\n    /**\n    * Blends two color values together based on the blending mode given as the MODE parameter.\n    * The possible modes are described in the reference for the blend() function.\n    *\n    * @param {color} c1 color: the first color to blend\n    * @param {color} c2 color: the second color to blend\n    * @param {MODE} MODE Either BLEND, ADD, SUBTRACT, DARKEST, LIGHTEST, DIFFERENCE, EXCLUSION, MULTIPLY,\n    * SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, or BURN\n    *\n    * @returns {float} The blended color.\n    *\n    * @see blend\n    * @see color\n    */\n    p.blendColor = function(c1, c2, mode) {\n      if (mode === PConstants.REPLACE) {\n        return p.modes.replace(c1, c2);\n      } else if (mode === PConstants.BLEND) {\n        return p.modes.blend(c1, c2);\n      } else if (mode === PConstants.ADD) {\n        return p.modes.add(c1, c2);\n      } else if (mode === PConstants.SUBTRACT) {\n        return p.modes.subtract(c1, c2);\n      } else if (mode === PConstants.LIGHTEST) {\n        return p.modes.lightest(c1, c2);\n      } else if (mode === PConstants.DARKEST) {\n        return p.modes.darkest(c1, c2);\n      } else if (mode === PConstants.DIFFERENCE) {\n        return p.modes.difference(c1, c2);\n      } else if (mode === PConstants.EXCLUSION) {\n        return p.modes.exclusion(c1, c2);\n      } else if (mode === PConstants.MULTIPLY) {\n        return p.modes.multiply(c1, c2);\n      } else if (mode === PConstants.SCREEN) {\n        return p.modes.screen(c1, c2);\n      } else if (mode === PConstants.HARD_LIGHT) {\n        return p.modes.hard_light(c1, c2);\n      } else if (mode === PConstants.SOFT_LIGHT) {\n        return p.modes.soft_light(c1, c2);\n      } else if (mode === PConstants.OVERLAY) {\n        return p.modes.overlay(c1, c2);\n      } else if (mode === PConstants.DODGE) {\n        return p.modes.dodge(c1, c2);\n      } else if (mode === PConstants.BURN) {\n        return p.modes.burn(c1, c2);\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Canvas-Matrix manipulation\n    ////////////////////////////////////////////////////////////////////////////\n\n    function saveContext() {\n      curContext.save();\n    }\n\n    function restoreContext() {\n      curContext.restore();\n      isStrokeDirty = true;\n      isFillDirty = true;\n    }\n\n    /**\n    * Prints the current matrix to the text window.\n    *\n    * @returns none\n    *\n    * @see pushMatrix\n    * @see popMatrix\n    * @see resetMatrix\n    * @see applyMatrix\n    */\n    p.printMatrix = function() {\n      modelView.print();\n    };\n\n    /**\n    * Specifies an amount to displace objects within the display window. The x parameter specifies left/right translation,\n    * the y parameter specifies up/down translation, and the z parameter specifies translations toward/away from the screen.\n    * Using this function with the z  parameter requires using the P3D or OPENGL parameter in combination with size as shown\n    * in the above example. Transformations apply to everything that happens after and subsequent calls to the function\n    * accumulates the effect. For example, calling translate(50, 0) and then translate(20, 0) is the same as translate(70, 0).\n    * If translate() is called within draw(), the transformation is reset when the loop begins again.\n    * This function can be further controlled by the pushMatrix() and popMatrix().\n    *\n    * @param {int|float} x        left/right translation\n    * @param {int|float} y        up/down translation\n    * @param {int|float} z        forward/back translation\n    *\n    * @returns none\n    *\n    * @see pushMatrix\n    * @see popMatrix\n    * @see scale\n    * @see rotate\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    */\n    Drawing2D.prototype.translate = function(x, y) {\n      modelView.translate(x, y);\n      modelViewInv.invTranslate(x, y);\n      curContext.translate(x, y);\n    };\n\n    Drawing3D.prototype.translate = function(x, y, z) {\n      modelView.translate(x, y, z);\n      modelViewInv.invTranslate(x, y, z);\n    };\n\n    /**\n    * Increases or decreases the size of a shape by expanding and contracting vertices. Objects always scale from their\n    * relative origin to the coordinate system. Scale values are specified as decimal percentages. For example, the\n    * function call scale(2.0) increases the dimension of a shape by 200%. Transformations apply to everything that\n    * happens after and subsequent calls to the function multiply the effect. For example, calling scale(2.0) and\n    * then scale(1.5) is the same as scale(3.0). If scale() is called within draw(), the transformation is reset when\n    * the loop begins again. Using this fuction with the z  parameter requires passing P3D or OPENGL into the size()\n    * parameter as shown in the example above. This function can be further controlled by pushMatrix() and popMatrix().\n    *\n    * @param {int|float} size     percentage to scale the object\n    * @param {int|float} x        percentage to scale the object in the x-axis\n    * @param {int|float} y        percentage to scale the object in the y-axis\n    * @param {int|float} z        percentage to scale the object in the z-axis\n    *\n    * @returns none\n    *\n    * @see pushMatrix\n    * @see popMatrix\n    * @see translate\n    * @see rotate\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    */\n    Drawing2D.prototype.scale = function(x, y) {\n      modelView.scale(x, y);\n      modelViewInv.invScale(x, y);\n      curContext.scale(x, y || x);\n    };\n\n    Drawing3D.prototype.scale = function(x, y, z) {\n      modelView.scale(x, y, z);\n      modelViewInv.invScale(x, y, z);\n    };\n\n\n    /**\n     * helper function for applying a transfrom matrix to a 2D context.\n     */\n    Drawing2D.prototype.transform = function(pmatrix) {\n      var e = pmatrix.array();\n      curContext.transform(e[0],e[3],e[1],e[4],e[2],e[5]);\n    };\n\n    /**\n     * helper function for applying a transfrom matrix to a 3D context.\n     * not currently implemented.\n     */\n    Drawing3D.prototype.transformm = function(pmatrix3d) {\n      throw(\"p.transform is currently not supported in 3D mode\");\n    };\n\n\n    /**\n    * Pushes the current transformation matrix onto the matrix stack. Understanding pushMatrix() and popMatrix()\n    * requires understanding the concept of a matrix stack. The pushMatrix() function saves the current coordinate\n    * system to the stack and popMatrix() restores the prior coordinate system. pushMatrix() and popMatrix() are\n    * used in conjuction with the other transformation methods and may be embedded to control the scope of\n    * the transformations.\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see translate\n    * @see rotate\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    */\n    Drawing2D.prototype.pushMatrix = function() {\n      userMatrixStack.load(modelView);\n      userReverseMatrixStack.load(modelViewInv);\n      saveContext();\n    };\n\n    Drawing3D.prototype.pushMatrix = function() {\n      userMatrixStack.load(modelView);\n      userReverseMatrixStack.load(modelViewInv);\n    };\n\n    /**\n    * Pops the current transformation matrix off the matrix stack. Understanding pushing and popping requires\n    * understanding the concept of a matrix stack. The pushMatrix() function saves the current coordinate system to\n    * the stack and popMatrix() restores the prior coordinate system. pushMatrix() and popMatrix() are used in\n    * conjuction with the other transformation methods and may be embedded to control the scope of the transformations.\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    Drawing2D.prototype.popMatrix = function() {\n      modelView.set(userMatrixStack.pop());\n      modelViewInv.set(userReverseMatrixStack.pop());\n      restoreContext();\n    };\n\n    Drawing3D.prototype.popMatrix = function() {\n      modelView.set(userMatrixStack.pop());\n      modelViewInv.set(userReverseMatrixStack.pop());\n    };\n\n    /**\n    * Replaces the current matrix with the identity matrix. The equivalent function in OpenGL is glLoadIdentity().\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see pushMatrix\n    * @see applyMatrix\n    * @see printMatrix\n    */\n    Drawing2D.prototype.resetMatrix = function() {\n      modelView.reset();\n      modelViewInv.reset();\n      curContext.setTransform(1,0,0,1,0,0);\n    };\n\n    Drawing3D.prototype.resetMatrix = function() {\n      modelView.reset();\n      modelViewInv.reset();\n    };\n\n    /**\n    * Multiplies the current matrix by the one specified through the parameters. This is very slow because it will\n    * try to calculate the inverse of the transform, so avoid it whenever possible. The equivalent function\n    * in OpenGL is glMultMatrix().\n    *\n    * @param {int|float} n00-n15      numbers which define the 4x4 matrix to be multiplied\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see pushMatrix\n    * @see resetMatrix\n    * @see printMatrix\n    */\n    DrawingShared.prototype.applyMatrix = function() {\n      var a = arguments;\n      modelView.apply(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n      modelViewInv.invApply(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n    };\n\n    Drawing2D.prototype.applyMatrix = function() {\n      var a = arguments;\n      for (var cnt = a.length; cnt < 16; cnt++) {\n        a[cnt] = 0;\n      }\n      a[10] = a[15] = 1;\n      DrawingShared.prototype.applyMatrix.apply(this, a);\n    };\n\n    /**\n    * Rotates a shape around the x-axis the amount specified by the angle parameter. Angles should be\n    * specified in radians (values from 0 to PI*2) or converted to radians with the radians()  function.\n    * Objects are always rotated around their relative position to the origin and positive numbers\n    * rotate objects in a counterclockwise direction. Transformations apply to everything that happens\n    * after and subsequent calls to the function accumulates the effect. For example, calling rotateX(PI/2)\n    * and then rotateX(PI/2) is the same as rotateX(PI). If rotateX() is called within the draw(), the\n    * transformation is reset when the loop begins again. This function requires passing P3D or OPENGL\n    * into the size() parameter as shown in the example above.\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    p.rotateX = function(angleInRadians) {\n      modelView.rotateX(angleInRadians);\n      modelViewInv.invRotateX(angleInRadians);\n    };\n\n    /**\n    * Rotates a shape around the z-axis the amount specified by the angle parameter. Angles should be\n    * specified in radians (values from 0 to PI*2) or converted to radians with the radians()  function.\n    * Objects are always rotated around their relative position to the origin and positive numbers\n    * rotate objects in a counterclockwise direction. Transformations apply to everything that happens\n    * after and subsequent calls to the function accumulates the effect. For example, calling rotateZ(PI/2)\n    * and then rotateZ(PI/2) is the same as rotateZ(PI). If rotateZ() is called within the draw(), the\n    * transformation is reset when the loop begins again. This function requires passing P3D or OPENGL\n    * into the size() parameter as shown in the example above.\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    Drawing2D.prototype.rotateZ = function() {\n      throw \"rotateZ() is not supported in 2D mode. Use rotate(float) instead.\";\n    };\n\n    Drawing3D.prototype.rotateZ = function(angleInRadians) {\n      modelView.rotateZ(angleInRadians);\n      modelViewInv.invRotateZ(angleInRadians);\n    };\n\n    /**\n    * Rotates a shape around the y-axis the amount specified by the angle parameter. Angles should be\n    * specified in radians (values from 0 to PI*2) or converted to radians with the radians()  function.\n    * Objects are always rotated around their relative position to the origin and positive numbers\n    * rotate objects in a counterclockwise direction. Transformations apply to everything that happens\n    * after and subsequent calls to the function accumulates the effect. For example, calling rotateY(PI/2)\n    * and then rotateY(PI/2) is the same as rotateY(PI). If rotateY() is called within the draw(), the\n    * transformation is reset when the loop begins again. This function requires passing P3D or OPENGL\n    * into the size() parameter as shown in the example above.\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    p.rotateY = function(angleInRadians) {\n      modelView.rotateY(angleInRadians);\n      modelViewInv.invRotateY(angleInRadians);\n    };\n\n    /**\n    * Rotates a shape the amount specified by the angle parameter. Angles should be specified in radians\n    * (values from 0 to TWO_PI) or converted to radians with the radians() function. Objects are always\n    * rotated around their relative position to the origin and positive numbers rotate objects in a\n    * clockwise direction. Transformations apply to everything that happens after and subsequent calls\n    * to the function accumulates the effect. For example, calling rotate(HALF_PI) and then rotate(HALF_PI)\n    * is the same as rotate(PI). All tranformations are reset when draw() begins again. Technically,\n    * rotate() multiplies the current transformation matrix by a rotation matrix. This function can be\n    * further controlled by the pushMatrix() and popMatrix().\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    Drawing2D.prototype.rotate = function(angleInRadians) {\n      modelView.rotateZ(angleInRadians);\n      modelViewInv.invRotateZ(angleInRadians);\n      curContext.rotate(angleInRadians);\n    };\n\n    Drawing3D.prototype.rotate = function(angleInRadians) {\n      p.rotateZ(angleInRadians);\n    };\n\n    /**\n    * Shears a shape around the x-axis the amount specified by the angle parameter.\n    * Angles should be specified in radians (values from 0 to PI*2) or converted to radians\n    * with the radians() function. Objects are always sheared around their relative position\n    * to the origin and positive numbers shear objects in a clockwise direction. Transformations\n    * apply to everything that happens after and subsequent calls to the function accumulates the\n    * effect. For example, calling shearX(PI/2) and then shearX(PI/2) is the same as shearX(PI)\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n\n    Drawing2D.prototype.shearX = function(angleInRadians) {\n      modelView.shearX(angleInRadians);\n      curContext.transform(1,0,angleInRadians,1,0,0);\n    };\n\n    Drawing3D.prototype.shearX = function(angleInRadians) {\n      modelView.shearX(angleInRadians);\n    };\n\n    /**\n    * Shears a shape around the y-axis the amount specified by the angle parameter.\n    * Angles should be specified in radians (values from 0 to PI*2) or converted to\n    * radians with the radians() function. Objects are always sheared around their\n    * relative position to the origin and positive numbers shear objects in a\n    * clockwise direction. Transformations apply to everything that happens after\n    * and subsequent calls to the function accumulates the effect. For example,\n    * calling shearY(PI/2) and then shearY(PI/2) is the same as shearY(PI).\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    * @see shearX\n    */\n\n   Drawing2D.prototype.shearY = function(angleInRadians) {\n      modelView.shearY(angleInRadians);\n      curContext.transform(1,angleInRadians,0,1,0,0);\n    };\n\n    Drawing3D.prototype.shearY = function(angleInRadians) {\n      modelView.shearY(angleInRadians);\n    };\n\n    /**\n    * The pushStyle() function saves the current style settings and popStyle()  restores the prior settings.\n    * Note that these functions are always used together. They allow you to change the style settings and later\n    * return to what you had. When a new style is started with pushStyle(), it builds on the current style information.\n    * The pushStyle() and popStyle() functions can be embedded to provide more control (see the second example\n    * above for a demonstration.)\n    * The style information controlled by the following functions are included in the style: fill(), stroke(), tint(),\n    * strokeWeight(), strokeCap(), strokeJoin(), imageMode(), rectMode(), ellipseMode(), shapeMode(), colorMode(),\n    * textAlign(), textFont(), textMode(), textSize(), textLeading(), emissive(), specular(), shininess(), ambient()\n    *\n    * @returns none\n    *\n    * @see popStyle\n    */\n    p.pushStyle = function() {\n      // Save the canvas state.\n      saveContext();\n\n      p.pushMatrix();\n\n      var newState = {\n        'doFill': doFill,\n        'currentFillColor': currentFillColor,\n        'doStroke': doStroke,\n        'currentStrokeColor': currentStrokeColor,\n        'curTint': curTint,\n        'curRectMode': curRectMode,\n        'curColorMode': curColorMode,\n        'colorModeX': colorModeX,\n        'colorModeZ': colorModeZ,\n        'colorModeY': colorModeY,\n        'colorModeA': colorModeA,\n        'curTextFont': curTextFont,\n        'horizontalTextAlignment': horizontalTextAlignment,\n        'verticalTextAlignment': verticalTextAlignment,\n        'textMode': textMode,\n        'curFontName': curFontName,\n        'curTextSize': curTextSize,\n        'curTextAscent': curTextAscent,\n        'curTextDescent': curTextDescent,\n        'curTextLeading': curTextLeading\n      };\n\n      styleArray.push(newState);\n    };\n\n    /**\n    * The pushStyle() function saves the current style settings and popStyle()  restores the prior settings; these\n    * functions are always used together. They allow you to change the style settings and later return to what you had.\n    * When a new style is started with pushStyle(), it builds on the current style information. The pushStyle() and\n    * popStyle() functions can be embedded to provide more control (see the second example above for a demonstration.)\n    *\n    * @returns none\n    *\n    * @see pushStyle\n    */\n    p.popStyle = function() {\n      var oldState = styleArray.pop();\n\n      if (oldState) {\n        restoreContext();\n\n        p.popMatrix();\n\n        doFill = oldState.doFill;\n        currentFillColor = oldState.currentFillColor;\n        doStroke = oldState.doStroke;\n        currentStrokeColor = oldState.currentStrokeColor;\n        curTint = oldState.curTint;\n        curRectMode = oldState.curRectMode;\n        curColorMode = oldState.curColorMode;\n        colorModeX = oldState.colorModeX;\n        colorModeZ = oldState.colorModeZ;\n        colorModeY = oldState.colorModeY;\n        colorModeA = oldState.colorModeA;\n        curTextFont = oldState.curTextFont;\n        curFontName = oldState.curFontName;\n        curTextSize = oldState.curTextSize;\n        horizontalTextAlignment = oldState.horizontalTextAlignment;\n        verticalTextAlignment = oldState.verticalTextAlignment;\n        textMode = oldState.textMode;\n        curTextAscent = oldState.curTextAscent;\n        curTextDescent = oldState.curTextDescent;\n        curTextLeading = oldState.curTextLeading;\n      } else {\n        throw \"Too many popStyle() without enough pushStyle()\";\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Time based functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * Processing communicates with the clock on your computer.\n    * The year() function returns the current year as an integer (2003, 2004, 2005, etc).\n    *\n    * @returns {float} The current year.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see hour\n    * @see day\n    * @see month\n    */\n    p.year = function() {\n      return new Date().getFullYear();\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The month() function returns the current month as a value from 1 - 12.\n    *\n    * @returns {float} The current month.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see hour\n    * @see day\n    * @see year\n    */\n    p.month = function() {\n      return new Date().getMonth() + 1;\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The day() function returns the current day as a value from 1 - 31.\n    *\n    * @returns {float} The current day.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see hour\n    * @see month\n    * @see year\n    */\n    p.day = function() {\n      return new Date().getDate();\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The hour() function returns the current hour as a value from 0 - 23.\n    *\n    * @returns {float} The current hour.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see month\n    * @see day\n    * @see year\n    */\n    p.hour = function() {\n      return new Date().getHours();\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The minute() function returns the current minute as a value from 0 - 59.\n    *\n    * @returns {float} The current minute.\n    *\n    * @see millis\n    * @see second\n    * @see month\n    * @see hour\n    * @see day\n    * @see year\n    */\n    p.minute = function() {\n      return new Date().getMinutes();\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The second() function returns the current second as a value from 0 - 59.\n    *\n    * @returns {float} The current minute.\n    *\n    * @see millis\n    * @see month\n    * @see minute\n    * @see hour\n    * @see day\n    * @see year\n    */\n    p.second = function() {\n      return new Date().getSeconds();\n    };\n    /**\n    * Returns the number of milliseconds (thousandths of a second) since starting a sketch.\n    * This information is often used for timing animation sequences.\n    *\n    * @returns {long} The number of milliseconds since starting the sketch.\n    *\n    * @see month\n    * @see second\n    * @see minute\n    * @see hour\n    * @see day\n    * @see year\n    */\n    p.millis = function() {\n      return Date.now() - start;\n    };\n\n    /**\n    * Executes the code within draw() one time. This functions allows the program to update\n    * the display window only when necessary, for example when an event registered by\n    * mousePressed() or keyPressed() occurs.\n    * In structuring a program, it only makes sense to call redraw() within events such as\n    * mousePressed(). This is because redraw() does not run draw() immediately (it only sets\n    * a flag that indicates an update is needed).\n    * Calling redraw() within draw() has no effect because draw() is continuously called anyway.\n    *\n    * @returns none\n    *\n    * @see noLoop\n    * @see loop\n    */\n    function redrawHelper() {\n      var sec = (Date.now() - timeSinceLastFPS) / 1000;\n      framesSinceLastFPS++;\n      var fps = framesSinceLastFPS / sec;\n\n      // recalculate FPS every half second for better accuracy.\n      if (sec > 0.5) {\n        timeSinceLastFPS = Date.now();\n        framesSinceLastFPS = 0;\n        p.__frameRate = fps;\n      }\n\n      p.frameCount++;\n    }\n\n    Drawing2D.prototype.redraw = function() {\n      redrawHelper();\n\n      curContext.lineWidth = lineWidth;\n      var pmouseXLastEvent = p.pmouseX,\n          pmouseYLastEvent = p.pmouseY;\n      p.pmouseX = pmouseXLastFrame;\n      p.pmouseY = pmouseYLastFrame;\n\n      saveContext();\n      p.draw();\n      restoreContext();\n\n      pmouseXLastFrame = p.mouseX;\n      pmouseYLastFrame = p.mouseY;\n      p.pmouseX = pmouseXLastEvent;\n      p.pmouseY = pmouseYLastEvent;\n    };\n\n    Drawing3D.prototype.redraw = function() {\n      redrawHelper();\n\n      var pmouseXLastEvent = p.pmouseX,\n          pmouseYLastEvent = p.pmouseY;\n      p.pmouseX = pmouseXLastFrame;\n      p.pmouseY = pmouseYLastFrame;\n      // even if the color buffer isn't cleared with background(),\n      // the depth buffer needs to be cleared regardless.\n      curContext.clear(curContext.DEPTH_BUFFER_BIT);\n      curContextCache = { attributes: {}, locations: {} };\n      // Delete all the lighting states and the materials the\n      // user set in the last draw() call.\n      p.noLights();\n      p.lightFalloff(1, 0, 0);\n      p.shininess(1);\n      p.ambient(255, 255, 255);\n      p.specular(0, 0, 0);\n      p.emissive(0, 0, 0);\n      p.camera();\n      p.draw();\n\n      pmouseXLastFrame = p.mouseX;\n      pmouseYLastFrame = p.mouseY;\n      p.pmouseX = pmouseXLastEvent;\n      p.pmouseY = pmouseYLastEvent;\n    };\n\n    /**\n    * Stops Processing from continuously executing the code within draw(). If loop() is\n    * called, the code in draw() begin to run continuously again. If using noLoop() in\n    * setup(), it should be the last line inside the block.\n    * When noLoop() is used, it's not possible to manipulate or access the screen inside event\n    * handling functions such as mousePressed() or keyPressed(). Instead, use those functions\n    * to call redraw() or loop(), which will run draw(), which can update the screen properly.\n    * This means that when noLoop() has been called, no drawing can happen, and functions like\n    * saveFrame() or loadPixels() may not be used.\n    * Note that if the sketch is resized, redraw() will be called to update the sketch, even\n    * after noLoop() has been specified. Otherwise, the sketch would enter an odd state until\n    * loop() was called.\n    *\n    * @returns none\n    *\n    * @see redraw\n    * @see draw\n    * @see loop\n    */\n    p.noLoop = function() {\n      doLoop = false;\n      loopStarted = false;\n      clearInterval(looping);\n      curSketch.onPause();\n    };\n\n    /**\n    * Causes Processing to continuously execute the code within draw(). If noLoop() is called,\n    * the code in draw() stops executing.\n    *\n    * @returns none\n    *\n    * @see noLoop\n    */\n    p.loop = function() {\n      if (loopStarted) {\n        return;\n      }\n\n      timeSinceLastFPS = Date.now();\n      framesSinceLastFPS = 0;\n\n      looping = window.setInterval(function() {\n        try {\n          curSketch.onFrameStart();\n          p.redraw();\n          curSketch.onFrameEnd();\n        } catch(e_loop) {\n          window.clearInterval(looping);\n          throw e_loop;\n        }\n      }, curMsPerFrame);\n      doLoop = true;\n      loopStarted = true;\n      curSketch.onLoop();\n    };\n\n    /**\n    * Specifies the number of frames to be displayed every second. If the processor is not\n    * fast enough to maintain the specified rate, it will not be achieved. For example, the\n    * function call frameRate(30) will attempt to refresh 30 times a second. It is recommended\n    * to set the frame rate within setup(). The default rate is 60 frames per second.\n    *\n    * @param {int} aRate        number of frames per second.\n    *\n    * @returns none\n    *\n    * @see delay\n    */\n    p.frameRate = function(aRate) {\n      curFrameRate = aRate;\n      curMsPerFrame = 1000 / curFrameRate;\n\n      // clear and reset interval\n      if (doLoop) {\n        p.noLoop();\n        p.loop();\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // JavaScript event binding and releasing\n    ////////////////////////////////////////////////////////////////////////////\n\n    var eventHandlers = [];\n\n    function attachEventHandler(elem, type, fn) {\n      if (elem.addEventListener) {\n        elem.addEventListener(type, fn, false);\n      } else {\n        elem.attachEvent(\"on\" + type, fn);\n      }\n      eventHandlers.push({elem: elem, type: type, fn: fn});\n    }\n\n    function detachEventHandler(eventHandler) {\n      var elem = eventHandler.elem,\n          type = eventHandler.type,\n          fn   = eventHandler.fn;\n      if (elem.removeEventListener) {\n        elem.removeEventListener(type, fn, false);\n      } else if (elem.detachEvent) {\n        elem.detachEvent(\"on\" + type, fn);\n      }\n    }\n\n    /**\n    * Quits/stops/exits the program. Programs without a draw() function exit automatically\n    * after the last line has run, but programs with draw() run continuously until the\n    * program is manually stopped or exit() is run.\n    * Rather than terminating immediately, exit() will cause the sketch to exit after draw()\n    * has completed (or after setup() completes if called during the setup() method).\n    *\n    * @returns none\n    */\n    p.exit = function() {\n      // cleanup\n      window.clearInterval(looping);\n      removeInstance(p.externals.canvas.id);\n      delete(curElement.onmousedown);\n\n      // Step through the libraries to detach them\n      for (var lib in Processing.lib) {\n        if (Processing.lib.hasOwnProperty(lib)) {\n          if (Processing.lib[lib].hasOwnProperty(\"detach\")) {\n            Processing.lib[lib].detach(p);\n          }\n        }\n      }\n\n      // clean up all event handling\n      var i = eventHandlers.length;\n      while (i--) {\n        detachEventHandler(eventHandlers[i]);\n      }\n      curSketch.onExit();\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // MISC functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * Sets the cursor to a predefined symbol, an image, or turns it on if already hidden.\n    * If you are trying to set an image as the cursor, it is recommended to make the size\n    * 16x16 or 32x32 pixels. It is not possible to load an image as the cursor if you are\n    * exporting your program for the Web. The values for parameters x and y must be less\n    * than the dimensions of the image.\n    *\n    * @param {MODE} MODE either ARROW, CROSS, HAND, MOVE, TEXT, WAIT\n    * @param {PImage} image       any variable of type PImage\n    * @param {int}    x           the horizonal active spot of the cursor\n    * @param {int}    y           the vertical active spot of the cursor\n    *\n    * @returns none\n    *\n    * @see noCursor\n    */\n    p.cursor = function() {\n      if (arguments.length > 1 || (arguments.length === 1 && arguments[0] instanceof p.PImage)) {\n        var image = arguments[0],\n          x, y;\n        if (arguments.length >= 3) {\n          x = arguments[1];\n          y = arguments[2];\n          if (x < 0 || y < 0 || y >= image.height || x >= image.width) {\n            throw \"x and y must be non-negative and less than the dimensions of the image\";\n          }\n        } else {\n          x = image.width >>> 1;\n          y = image.height >>> 1;\n        }\n\n        // see https://developer.mozilla.org/en/Using_URL_values_for_the_cursor_property\n        var imageDataURL = image.toDataURL();\n        var style = \"url(\\\"\" + imageDataURL + \"\\\") \" + x + \" \" + y + \", default\";\n        curCursor = curElement.style.cursor = style;\n      } else if (arguments.length === 1) {\n        var mode = arguments[0];\n        curCursor = curElement.style.cursor = mode;\n      } else {\n        curCursor = curElement.style.cursor = oldCursor;\n      }\n    };\n\n    /**\n    * Hides the cursor from view.\n    *\n    * @returns none\n    *\n    * @see cursor\n    */\n    p.noCursor = function() {\n      curCursor = curElement.style.cursor = PConstants.NOCURSOR;\n    };\n\n    /**\n    * Links to a webpage either in the same window or in a new window. The complete URL\n    * must be specified.\n    *\n    * @param {String} href      complete url as a String in quotes\n    * @param {String} target    name of the window to load the URL as a string in quotes\n    *\n    * @returns none\n    */\n    p.link = function(href, target) {\n      if (target !== undef) {\n        window.open(href, target);\n      } else {\n        window.location = href;\n      }\n    };\n\n    // PGraphics methods\n    // These functions exist only for compatibility with P5\n    p.beginDraw = nop;\n    p.endDraw = nop;\n\n    /**\n     * This function takes content from a canvas and turns it into an ImageData object to be used with a PImage\n     *\n     * @returns {ImageData}        ImageData object to attach to a PImage (1D array of pixel data)\n     *\n     * @see PImage\n     */\n    Drawing2D.prototype.toImageData = function(x, y, w, h) {\n      x = x !== undef ? x : 0;\n      y = y !== undef ? y : 0;\n      w = w !== undef ? w : p.width;\n      h = h !== undef ? h : p.height;\n      return curContext.getImageData(x, y, w, h);\n    };\n\n    Drawing3D.prototype.toImageData = function(x, y, w, h) {\n      x = x !== undef ? x : 0;\n      y = y !== undef ? y : 0;\n      w = w !== undef ? w : p.width;\n      h = h !== undef ? h : p.height;\n      var c = document.createElement(\"canvas\"),\n          ctx = c.getContext(\"2d\"),\n          obj = ctx.createImageData(w, h),\n          uBuff = new Uint8Array(w * h * 4);\n      curContext.readPixels(x, y, w, h, curContext.RGBA, curContext.UNSIGNED_BYTE, uBuff);\n      for (var i=0, ul=uBuff.length, obj_data=obj.data; i < ul; i++) {\n        obj_data[i] = uBuff[(h - 1 - Math.floor(i / 4 / w)) * w * 4 + (i % (w * 4))];\n      }\n      return obj;\n    };\n\n    /**\n    * Displays message in the browser's status area. This is the text area in the lower\n    * left corner of the browser. The status() function will only work when the\n    * Processing program is running in a web browser.\n    *\n    * @param {String} text      any valid String\n    *\n    * @returns none\n    */\n    p.status = function(text) {\n      window.status = text;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Binary Functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * Converts a byte, char, int, or color to a String containing the equivalent binary\n    * notation. For example color(0, 102, 153, 255) will convert to the String\n    * \"11111111000000000110011010011001\". This function can help make your geeky debugging\n    * sessions much happier.\n    *\n    * @param {byte|char|int|color} num          byte, char, int, color: value to convert\n    * @param {int} numBits                      number of digits to return\n    *\n    * @returns {String}\n    *\n    * @see unhex\n    * @see hex\n    * @see unbinary\n    */\n    p.binary = function(num, numBits) {\n      var bit;\n      if (numBits > 0) {\n        bit = numBits;\n      } else if(num instanceof Char) {\n        bit = 16;\n        num |= 0; // making it int\n      } else {\n        // autodetect, skipping zeros\n        bit = 32;\n        while (bit > 1 && !((num >>> (bit - 1)) & 1)) {\n          bit--;\n        }\n      }\n      var result = \"\";\n      while (bit > 0) {\n        result += ((num >>> (--bit)) & 1) ? \"1\" : \"0\";\n      }\n      return result;\n    };\n\n    /**\n    * Converts a String representation of a binary number to its equivalent integer value.\n    * For example, unbinary(\"00001000\") will return 8.\n    *\n    * @param {String} binaryString String\n    *\n    * @returns {Int}\n    *\n    * @see hex\n    * @see binary\n    * @see unbinary\n    */\n    p.unbinary = function(binaryString) {\n      var i = binaryString.length - 1, mask = 1, result = 0;\n      while (i >= 0) {\n        var ch = binaryString[i--];\n        if (ch !== '0' && ch !== '1') {\n          throw \"the value passed into unbinary was not an 8 bit binary number\";\n        }\n        if (ch === '1') {\n          result += mask;\n        }\n        mask <<= 1;\n      }\n      return result;\n    };\n\n    /**\n    * Number-to-String formatting function. Prepends \"plus\" or \"minus\" depending\n    * on whether the value is positive or negative, respectively, after padding\n    * the value with zeroes on the left and right, the number of zeroes used dictated\n    * by the values 'leftDigits' and 'rightDigits'. 'value' cannot be an array.\n    *\n    * @param {int|float} value                 the number to format\n    * @param {String} plus                     the prefix for positive numbers\n    * @param {String} minus                    the prefix for negative numbers\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    * @param {String} group                    string delimited for groups, such as the comma in \"1,000\"\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfCore\n    */\n    function nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group) {\n      var sign = (value < 0) ? minus : plus;\n      var autoDetectDecimals = rightDigits === 0;\n      var rightDigitsOfDefault = (rightDigits === undef || rightDigits < 0) ? 0 : rightDigits;\n\n      var absValue = Math.abs(value);\n      if (autoDetectDecimals) {\n        rightDigitsOfDefault = 1;\n        absValue *= 10;\n        while (Math.abs(Math.round(absValue) - absValue) > 1e-6 && rightDigitsOfDefault < 7) {\n          ++rightDigitsOfDefault;\n          absValue *= 10;\n        }\n      } else if (rightDigitsOfDefault !== 0) {\n        absValue *= Math.pow(10, rightDigitsOfDefault);\n      }\n\n      // Using Java's default rounding policy HALF_EVEN. This policy is based\n      // on the idea that 0.5 values round to the nearest even number, and\n      // everything else is rounded normally.\n      var number, doubled = absValue * 2;\n      if (Math.floor(absValue) === absValue) {\n        number = absValue;\n      } else if (Math.floor(doubled) === doubled) {\n        var floored = Math.floor(absValue);\n        number = floored + (floored % 2);\n      } else {\n        number = Math.round(absValue);\n      }\n\n      var buffer = \"\";\n      var totalDigits = leftDigits + rightDigitsOfDefault;\n      while (totalDigits > 0 || number > 0) {\n        totalDigits--;\n        buffer = \"\" + (number % 10) + buffer;\n        number = Math.floor(number / 10);\n      }\n      if (group !== undef) {\n        var i = buffer.length - 3 - rightDigitsOfDefault;\n        while(i > 0) {\n          buffer = buffer.substring(0,i) + group + buffer.substring(i);\n          i-=3;\n        }\n      }\n      if (rightDigitsOfDefault > 0) {\n        return sign + buffer.substring(0, buffer.length - rightDigitsOfDefault) +\n               \".\" + buffer.substring(buffer.length - rightDigitsOfDefault, buffer.length);\n      }\n      return sign + buffer;\n    }\n\n    /**\n    * Number-to-String formatting function. Prepends \"plus\" or \"minus\" depending\n    * on whether the value is positive or negative, respectively, after padding\n    * the value with zeroes on the left and right, the number of zeroes used dictated\n    * by the values 'leftDigits' and 'rightDigits'. 'value' can be an array;\n    * if the input is an array, each value in it is formatted separately, and\n    * an array with formatted values is returned.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {String} plus                     the prefix for positive numbers\n    * @param {String} minus                    the prefix for negative numbers\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    * @param {String} group                    string delimited for groups, such as the comma in \"1,000\"\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfCoreScalar\n    */\n    function nfCore(value, plus, minus, leftDigits, rightDigits, group) {\n      if (value instanceof Array) {\n        var arr = [];\n        for (var i = 0, len = value.length; i < len; i++) {\n          arr.push(nfCoreScalar(value[i], plus, minus, leftDigits, rightDigits, group));\n        }\n        return arr;\n      }\n      return nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group);\n    }\n\n    /**\n    * Utility function for formatting numbers into strings. There are two versions, one for\n    * formatting floats and one for formatting ints. The values for the digits, left, and\n    * right parameters should always be positive integers.\n    * As shown in the above example, nf() is used to add zeros to the left and/or right\n    * of a number. This is typically for aligning a list of numbers. To remove digits from\n    * a floating-point number, use the int(), ceil(), floor(), or round() functions.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfs\n    * @see nfp\n    * @see nfc\n    */\n    p.nf = function(value, leftDigits, rightDigits) { return nfCore(value, \"\", \"-\", leftDigits, rightDigits); };\n\n    /**\n    * Utility function for formatting numbers into strings. Similar to nf()  but leaves a blank space in front\n    * of positive numbers so they align with negative numbers in spite of the minus symbol. There are two\n    * versions, one for formatting floats and one for formatting ints. The values for the digits, left,\n    * and right parameters should always be positive integers.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nf\n    * @see nfp\n    * @see nfc\n    */\n    p.nfs = function(value, leftDigits, rightDigits) { return nfCore(value, \" \", \"-\", leftDigits, rightDigits); };\n\n    /**\n    * Utility function for formatting numbers into strings. Similar to nf()  but puts a \"+\" in front of\n    * positive numbers and a \"-\" in front of negative numbers. There are two versions, one for formatting\n    * floats and one for formatting ints. The values for the digits, left, and right parameters should\n    * always be positive integers.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfs\n    * @see nf\n    * @see nfc\n    */\n    p.nfp = function(value, leftDigits, rightDigits) { return nfCore(value, \"+\", \"-\", leftDigits, rightDigits); };\n\n    /**\n    * Utility function for formatting numbers into strings and placing appropriate commas to mark\n    * units of 1000. There are two versions, one for formatting ints and one for formatting an array\n    * of ints. The value for the digits parameter should always be a positive integer.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nf\n    * @see nfs\n    * @see nfp\n    */\n    p.nfc = function(value, leftDigits, rightDigits) { return nfCore(value, \"\", \"-\", leftDigits, rightDigits, \",\"); };\n\n    var decimalToHex = function(d, padding) {\n      //if there is no padding value added, default padding to 8 else go into while statement.\n      padding = (padding === undef || padding === null) ? padding = 8 : padding;\n      if (d < 0) {\n        d = 0xFFFFFFFF + d + 1;\n      }\n      var hex = Number(d).toString(16).toUpperCase();\n      while (hex.length < padding) {\n        hex = \"0\" + hex;\n      }\n      if (hex.length >= padding) {\n        hex = hex.substring(hex.length - padding, hex.length);\n      }\n      return hex;\n    };\n\n    // note: since we cannot keep track of byte, int types by default the returned string is 8 chars long\n    // if no 2nd argument is passed.  closest compromise we can use to match java implementation Feb 5 2010\n    // also the char parser has issues with chars that are not digits or letters IE: !@#$%^&*\n    /**\n    * Converts a byte, char, int, or color to a String containing the equivalent hexadecimal notation.\n    * For example color(0, 102, 153, 255) will convert to the String \"FF006699\". This function can help\n    * make your geeky debugging sessions much happier.\n    *\n    * @param {byte|char|int|Color} value   the value to turn into a hex string\n    * @param {int} digits                 the number of digits to return\n    *\n    * @returns {String}\n    *\n    * @see unhex\n    * @see binary\n    * @see unbinary\n    */\n    p.hex = function(value, len) {\n      if (arguments.length === 1) {\n        if (value instanceof Char) {\n          len = 4;\n        } else { // int or byte, indistinguishable at the moment, default to 8\n          len = 8;\n        }\n      }\n      return decimalToHex(value, len);\n    };\n\n    function unhexScalar(hex) {\n      var value = parseInt(\"0x\" + hex, 16);\n\n      // correct for int overflow java expectation\n      if (value > 2147483647) {\n        value -= 4294967296;\n      }\n      return value;\n    }\n\n    /**\n    * Converts a String representation of a hexadecimal number to its equivalent integer value.\n    *\n    * @param {String} hex   the hex string to convert to an int\n    *\n    * @returns {int}\n    *\n    * @see hex\n    * @see binary\n    * @see unbinary\n    */\n    p.unhex = function(hex) {\n      if (hex instanceof Array) {\n        var arr = [];\n        for (var i = 0; i < hex.length; i++) {\n          arr.push(unhexScalar(hex[i]));\n        }\n        return arr;\n      }\n      return unhexScalar(hex);\n    };\n\n    // Load a file or URL into strings\n    /**\n    * Reads the contents of a file or url and creates a String array of its individual lines.\n    * The filename parameter can also be a URL to a file found online.  If the file is not available or an error occurs,\n    * null will be returned and an error message will be printed to the console. The error message does not halt\n    * the program.\n    *\n    * @param {String} filename    name of the file or url to load\n    *\n    * @returns {String[]}\n    *\n    * @see loadBytes\n    * @see saveStrings\n    * @see saveBytes\n    */\n    p.loadStrings = function(filename) {\n      if (localStorage[filename]) {\n        return localStorage[filename].split(\"\\n\");\n      }\n\n      var filecontent = ajax(filename);\n      if(typeof filecontent !== \"string\" || filecontent === \"\") {\n        return [];\n      }\n\n      // deal with the fact that Windows uses \\r\\n, Unix uses \\n,\n      // Mac uses \\r, and we actually expect \\n\n      filecontent = filecontent.replace(/(\\r\\n?)/g,\"\\n\").replace(/\\n$/,\"\");\n\n      return filecontent.split(\"\\n\");\n    };\n\n    // Writes an array of strings to a file, one line per string\n    /**\n    * Writes an array of strings to a file, one line per string. This file is saved to the localStorage.\n    *\n    * @param {String} filename    name of the file to save to localStorage\n    * @param {String[]} strings   string array to be written\n    *\n    * @see loadBytes\n    * @see loadStrings\n    * @see saveBytes\n    */\n    p.saveStrings = function(filename, strings) {\n      localStorage[filename] = strings.join('\\n');\n    };\n\n    /**\n    * Reads the contents of a file or url and places it in a byte array. If a file is specified, it must be located in the localStorage.\n    * The filename parameter can also be a URL to a file found online.\n    *\n    * @param {String} filename   name of a file in the localStorage or a URL.\n    *\n    * @returns {byte[]}\n    *\n    * @see loadStrings\n    * @see saveStrings\n    * @see saveBytes\n    */\n    p.loadBytes = function(url) {\n      var string = ajax(url);\n      var ret = [];\n\n      for (var i = 0; i < string.length; i++) {\n        ret.push(string.charCodeAt(i));\n      }\n\n      return ret;\n    };\n\n    /**\n     * Removes the first argument from the arguments set -- shifts.\n     *\n     * @param {Arguments} args  The Arguments object.\n     *\n     * @return {Object[]}       Returns an array of arguments except first one.\n     *\n     * @see #match\n     */\n    function removeFirstArgument(args) {\n      return Array.prototype.slice.call(args, 1);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // String Functions\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * The matchAll() function is identical to match(), except that it returns an array of all matches in\n     * the specified String, rather than just the first.\n     *\n     * @param {String} aString  the String to search inside\n     * @param {String} aRegExp  the regexp to be used for matching\n     *\n     * @return {String[]} returns an array of matches\n     *\n     * @see #match\n     */\n    p.matchAll = function(aString, aRegExp) {\n      var results = [],\n          latest;\n      var regexp = new RegExp(aRegExp, \"g\");\n      while ((latest = regexp.exec(aString)) !== null) {\n        results.push(latest);\n        if (latest[0].length === 0) {\n          ++regexp.lastIndex;\n        }\n      }\n      return results.length > 0 ? results : null;\n    };\n    /**\n     * The contains(string) function returns true if the string passed in the parameter\n     * is a substring of this string. It returns false if the string passed\n     * in the parameter is not a substring of this string.\n     *\n     * @param {String} The string to look for in the current string\n     *\n     * @return {boolean} returns true if this string contains\n     * the string passed as parameter. returns false, otherwise.\n     *\n     */\n    p.__contains = function (subject, subStr) {\n      if (typeof subject !== \"string\") {\n        return subject.contains.apply(subject, removeFirstArgument(arguments));\n      }\n      //Parameter is not null AND\n      //The type of the parameter is the same as this object (string)\n      //The javascript function that finds a substring returns 0 or higher\n      return (\n        (subject !== null) &&\n        (subStr !== null) &&\n        (typeof subStr === \"string\") &&\n        (subject.indexOf(subStr) > -1)\n      );\n    };\n    /**\n     * The __replaceAll() function searches all matches between a substring (or regular expression) and a string,\n     * and replaces the matched substring with a new substring\n     *\n     * @param {String} subject    a substring\n     * @param {String} regex      a substring or a regular expression\n     * @param {String} replace    the string to replace the found value\n     *\n     * @return {String} returns result\n     *\n     * @see #match\n     */\n    p.__replaceAll = function(subject, regex, replacement) {\n      if (typeof subject !== \"string\") {\n        return subject.replaceAll.apply(subject, removeFirstArgument(arguments));\n      }\n\n      return subject.replace(new RegExp(regex, \"g\"), replacement);\n    };\n    /**\n     * The __replaceFirst() function searches first matche between a substring (or regular expression) and a string,\n     * and replaces the matched substring with a new substring\n     *\n     * @param {String} subject    a substring\n     * @param {String} regex      a substring or a regular expression\n     * @param {String} replace    the string to replace the found value\n     *\n     * @return {String} returns result\n     *\n     * @see #match\n     */\n    p.__replaceFirst = function(subject, regex, replacement) {\n      if (typeof subject !== \"string\") {\n        return subject.replaceFirst.apply(subject, removeFirstArgument(arguments));\n      }\n\n      return subject.replace(new RegExp(regex, \"\"), replacement);\n    };\n    /**\n     * The __replace() function searches all matches between a substring and a string,\n     * and replaces the matched substring with a new substring\n     *\n     * @param {String} subject         a substring\n     * @param {String} what         a substring to find\n     * @param {String} replacement    the string to replace the found value\n     *\n     * @return {String} returns result\n     */\n    p.__replace = function(subject, what, replacement) {\n      if (typeof subject !== \"string\") {\n        return subject.replace.apply(subject, removeFirstArgument(arguments));\n      }\n      if (what instanceof RegExp) {\n        return subject.replace(what, replacement);\n      }\n\n      if (typeof what !== \"string\") {\n        what = what.toString();\n      }\n      if (what === \"\") {\n        return subject;\n      }\n\n      var i = subject.indexOf(what);\n      if (i < 0) {\n        return subject;\n      }\n\n      var j = 0, result = \"\";\n      do {\n        result += subject.substring(j, i) + replacement;\n        j = i + what.length;\n      } while ( (i = subject.indexOf(what, j)) >= 0);\n      return result + subject.substring(j);\n    };\n    /**\n     * The __equals() function compares two strings (or objects) to see if they are the same.\n     * This method is necessary because it's not possible to compare strings using the equality operator (==).\n     * Returns true if the strings are the same and false if they are not.\n     *\n     * @param {String} subject  a string used for comparison\n     * @param {String} other  a string used for comparison with\n     *\n     * @return {boolean} true is the strings are the same false otherwise\n     */\n    p.__equals = function(subject, other) {\n      if (subject.equals instanceof Function) {\n        return subject.equals.apply(subject, removeFirstArgument(arguments));\n      }\n\n      // TODO use virtEquals for HashMap here\n      return subject.valueOf() === other.valueOf();\n    };\n    /**\n     * The __equalsIgnoreCase() function compares two strings to see if they are the same.\n     * Returns true if the strings are the same, either when forced to all lower case or\n     * all upper case.\n     *\n     * @param {String} subject  a string used for comparison\n     * @param {String} other  a string used for comparison with\n     *\n     * @return {boolean} true is the strings are the same, ignoring case. false otherwise\n     */\n    p.__equalsIgnoreCase = function(subject, other) {\n      if (typeof subject !== \"string\") {\n        return subject.equalsIgnoreCase.apply(subject, removeFirstArgument(arguments));\n      }\n\n      return subject.toLowerCase() === other.toLowerCase();\n    };\n    /**\n     * The __toCharArray() function splits the string into a char array.\n     *\n     * @param {String} subject The string\n     *\n     * @return {Char[]} a char array\n     */\n    p.__toCharArray = function(subject) {\n      if (typeof subject !== \"string\") {\n        return subject.toCharArray.apply(subject, removeFirstArgument(arguments));\n      }\n\n      var chars = [];\n      for (var i = 0, len = subject.length; i < len; ++i) {\n        chars[i] = new Char(subject.charAt(i));\n      }\n      return chars;\n    };\n    /**\n     * The __split() function splits a string using the regex delimiter\n     * specified. If limit is specified, the resultant array will have number\n     * of elements equal to or less than the limit.\n     *\n     * @param {String} subject string to be split\n     * @param {String} regexp  regex string used to split the subject\n     * @param {int}    limit   max number of tokens to be returned\n     *\n     * @return {String[]} an array of tokens from the split string\n     */\n    p.__split = function(subject, regex, limit) {\n      if (typeof subject !== \"string\") {\n        return subject.split.apply(subject, removeFirstArgument(arguments));\n      }\n\n      var pattern = new RegExp(regex);\n\n      // If limit is not specified, use JavaScript's built-in String.split.\n      if ((limit === undef) || (limit < 1)) {\n        return subject.split(pattern);\n      }\n\n      // If limit is specified, JavaScript's built-in String.split has a\n      // different behaviour than Java's. A Java-compatible implementation is\n      // provided here.\n      var result = [], currSubject = subject, pos;\n      while (((pos = currSubject.search(pattern)) !== -1)\n          && (result.length < (limit - 1))) {\n        var match = pattern.exec(currSubject).toString();\n        result.push(currSubject.substring(0, pos));\n        currSubject = currSubject.substring(pos + match.length);\n      }\n      if ((pos !== -1) || (currSubject !== \"\")) {\n        result.push(currSubject);\n      }\n      return result;\n    };\n    /**\n     * The codePointAt() function returns the unicode value of the character at a given index of a string.\n     *\n     * @param  {int} idx         the index of the character\n     *\n     * @return {String} code     the String containing the unicode value of the character\n     */\n    p.__codePointAt = function(subject, idx) {\n      var code = subject.charCodeAt(idx),\n          hi,\n          low;\n      if (0xD800 <= code && code <= 0xDBFF) {\n        hi = code;\n        low = subject.charCodeAt(idx + 1);\n        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n      }\n      return code;\n    };\n    /**\n     * The match() function matches a string with a regular expression, and returns the match as an\n     * array. The first index is the matching expression, and array elements\n     * [1] and higher represent each of the groups (sequences found in parens).\n     *\n     * @param {String} str      the String to be searched\n     * @param {String} regexp   the regexp to be used for matching\n     *\n     * @return {String[]} an array of matching strings\n     */\n    p.match = function(str, regexp) {\n      return str.match(regexp);\n    };\n    /**\n     * The startsWith() function tests if a string starts with the specified prefix.  If the prefix\n     * is the empty String or equal to the subject String, startsWith() will also return true.\n     *\n     * @param {String} prefix   the String used to compare against the start of the subject String.\n     * @param {int}    toffset  (optional) an offset into the subject String where searching should begin.\n     *\n     * @return {boolean} true if the subject String starts with the prefix.\n     */\n    p.__startsWith = function(subject, prefix, toffset) {\n      if (typeof subject !== \"string\") {\n        return subject.startsWith.apply(subject, removeFirstArgument(arguments));\n      }\n\n      toffset = toffset || 0;\n      if (toffset < 0 || toffset > subject.length) {\n        return false;\n      }\n      return (prefix === '' || prefix === subject) ? true : (subject.indexOf(prefix) === toffset);\n    };\n    /**\n     * The endsWith() function tests if a string ends with the specified suffix.  If the suffix\n     * is the empty String, endsWith() will also return true.\n     *\n     * @param {String} suffix   the String used to compare against the end of the subject String.\n     *\n     * @return {boolean} true if the subject String starts with the prefix.\n     */\n    p.__endsWith = function(subject, suffix) {\n      if (typeof subject !== \"string\") {\n        return subject.endsWith.apply(subject, removeFirstArgument(arguments));\n      }\n\n      var suffixLen = suffix ? suffix.length : 0;\n      return (suffix === '' || suffix === subject) ? true :\n        (subject.indexOf(suffix) === subject.length - suffixLen);\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Other java specific functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * The returns hash code of the.\n     *\n     * @param {Object} subject The string\n     *\n     * @return {int} a hash code\n     */\n    p.__hashCode = function(subject) {\n      if (subject.hashCode instanceof Function) {\n        return subject.hashCode.apply(subject, removeFirstArgument(arguments));\n      }\n      return virtHashCode(subject);\n    };\n    /**\n     * The __printStackTrace() prints stack trace to the console.\n     *\n     * @param {Exception} subject The error\n     */\n    p.__printStackTrace = function(subject) {\n      p.println(\"Exception: \" + subject.toString() );\n    };\n\n    var logBuffer = [];\n\n    /**\n     * The println() function writes to the console area of the Processing environment.\n     * Each call to this function creates a new line of output. Individual elements can be separated with quotes (\"\") and joined with the string concatenation operator (+).\n     *\n     * @param {String} message the string to write to the console\n     *\n     * @see #join\n     * @see #print\n     */\n    p.println = function(message) {\n      var bufferLen = logBuffer.length;\n      if (bufferLen) {\n        Processing.logger.log(logBuffer.join(\"\"));\n        logBuffer.length = 0; // clear log buffer\n      }\n\n      if (arguments.length === 0 && bufferLen === 0) {\n        Processing.logger.log(\"\");\n      } else if (arguments.length !== 0) {\n        Processing.logger.log(message);\n      }\n    };\n    /**\n     * The print() function writes to the console area of the Processing environment.\n     *\n     * @param {String} message the string to write to the console\n     *\n     * @see #join\n     */\n    p.print = function(message) {\n      logBuffer.push(message);\n    };\n\n    // Alphanumeric chars arguments automatically converted to numbers when\n    // passed in, and will come out as numbers.\n    p.str = function(val) {\n      if (val instanceof Array) {\n        var arr = [];\n        for (var i = 0; i < val.length; i++) {\n          arr.push(val[i].toString() + \"\");\n        }\n        return arr;\n      }\n      return (val.toString() + \"\");\n    };\n    /**\n     * Remove whitespace characters from the beginning and ending\n     * of a String or a String array. Works like String.trim() but includes the\n     * unicode nbsp character as well. If an array is passed in the function will return a new array not effecting the array passed in.\n     *\n     * @param {String} str    the string to trim\n     * @param {String[]} str  the string array to trim\n     *\n     * @return {String|String[]} retrurns a string or an array will removed whitespaces\n     */\n    p.trim = function(str) {\n      if (str instanceof Array) {\n        var arr = [];\n        for (var i = 0; i < str.length; i++) {\n          arr.push(str[i].replace(/^\\s*/, '').replace(/\\s*$/, '').replace(/\\r*$/, ''));\n        }\n        return arr;\n      }\n      return str.replace(/^\\s*/, '').replace(/\\s*$/, '').replace(/\\r*$/, '');\n    };\n\n    // Conversion\n    function booleanScalar(val) {\n      if (typeof val === 'number') {\n        return val !== 0;\n      }\n      if (typeof val === 'boolean') {\n        return val;\n      }\n      if (typeof val === 'string') {\n        return val.toLowerCase() === 'true';\n      }\n      if (val instanceof Char) {\n        // 1, T or t\n        return val.code === 49 || val.code === 84 || val.code === 116;\n      }\n    }\n\n    /**\n     * Converts the passed parameter to the function to its boolean value.\n     * It will return an array of booleans if an array is passed in.\n     *\n     * @param {int, byte, string} val          the parameter to be converted to boolean\n     * @param {int[], byte[], string[]} val    the array to be converted to boolean[]\n     *\n     * @return {boolean|boolean[]} returns a boolean or an array of booleans\n     */\n    p.parseBoolean = function (val) {\n      if (val instanceof Array) {\n        var ret = [];\n        for (var i = 0; i < val.length; i++) {\n          ret.push(booleanScalar(val[i]));\n        }\n        return ret;\n      }\n      return booleanScalar(val);\n    };\n\n    /**\n     * Converts the passed parameter to the function to its byte value.\n     * A byte is a number between -128 and 127.\n     * It will return an array of bytes if an array is passed in.\n     *\n     * @param {int, char} what        the parameter to be conveted to byte\n     * @param {int[], char[]} what    the array to be converted to byte[]\n     *\n     * @return {byte|byte[]} returns a byte or an array of bytes\n     */\n    p.parseByte = function(what) {\n      if (what instanceof Array) {\n        var bytes = [];\n        for (var i = 0; i < what.length; i++) {\n          bytes.push((0 - (what[i] & 0x80)) | (what[i] & 0x7F));\n        }\n        return bytes;\n      }\n      return (0 - (what & 0x80)) | (what & 0x7F);\n    };\n\n    /**\n     * Converts the passed parameter to the function to its char value.\n     * It will return an array of chars if an array is passed in.\n     *\n     * @param {int, byte} key        the parameter to be conveted to char\n     * @param {int[], byte[]} key    the array to be converted to char[]\n     *\n     * @return {char|char[]} returns a char or an array of chars\n     */\n    p.parseChar = function(key) {\n      if (typeof key === \"number\") {\n        return new Char(String.fromCharCode(key & 0xFFFF));\n      }\n      if (key instanceof Array) {\n        var ret = [];\n        for (var i = 0; i < key.length; i++) {\n          ret.push(new Char(String.fromCharCode(key[i] & 0xFFFF)));\n        }\n        return ret;\n      }\n      throw \"char() may receive only one argument of type int, byte, int[], or byte[].\";\n    };\n\n    // Processing doc claims good argument types are: int, char, byte, boolean,\n    // String, int[], char[], byte[], boolean[], String[].\n    // floats should not work. However, floats with only zeroes right of the\n    // decimal will work because JS converts those to int.\n    function floatScalar(val) {\n      if (typeof val === 'number') {\n        return val;\n      }\n      if (typeof val === 'boolean') {\n        return val ? 1 : 0;\n      }\n      if (typeof val === 'string') {\n        return parseFloat(val);\n      }\n      if (val instanceof Char) {\n        return val.code;\n      }\n    }\n\n    /**\n     * Converts the passed parameter to the function to its float value.\n     * It will return an array of floats if an array is passed in.\n     *\n     * @param {int, char, boolean, string} val            the parameter to be conveted to float\n     * @param {int[], char[], boolean[], string[]} val    the array to be converted to float[]\n     *\n     * @return {float|float[]} returns a float or an array of floats\n     */\n    p.parseFloat = function(val) {\n      if (val instanceof Array) {\n        var ret = [];\n        for (var i = 0; i < val.length; i++) {\n          ret.push(floatScalar(val[i]));\n        }\n        return ret;\n      }\n      return floatScalar(val);\n    };\n\n    function intScalar(val, radix) {\n      if (typeof val === 'number') {\n        return val & 0xFFFFFFFF;\n      }\n      if (typeof val === 'boolean') {\n        return val ? 1 : 0;\n      }\n      if (typeof val === 'string') {\n        var number = parseInt(val, radix || 10); // Default to decimal radix.\n        return number & 0xFFFFFFFF;\n      }\n      if (val instanceof Char) {\n        return val.code;\n      }\n    }\n\n    /**\n     * Converts the passed parameter to the function to its int value.\n     * It will return an array of ints if an array is passed in.\n     *\n     * @param {string, char, boolean, float} val            the parameter to be conveted to int\n     * @param {string[], char[], boolean[], float[]} val    the array to be converted to int[]\n     * @param {int} radix                                   optional the radix of the number (for js compatibility)\n     *\n     * @return {int|int[]} returns a int or an array of ints\n     */\n    p.parseInt = function(val, radix) {\n      if (val instanceof Array) {\n        var ret = [];\n        for (var i = 0; i < val.length; i++) {\n          if (typeof val[i] === 'string' && !/^\\s*[+\\-]?\\d+\\s*$/.test(val[i])) {\n            ret.push(0);\n          } else {\n            ret.push(intScalar(val[i], radix));\n          }\n        }\n        return ret;\n      }\n      return intScalar(val, radix);\n    };\n\n    p.__int_cast = function(val) {\n      return 0|val;\n    };\n\n    p.__instanceof = function(obj, type) {\n      if (typeof type !== \"function\") {\n        throw \"Function is expected as type argument for instanceof operator\";\n      }\n\n      if (typeof obj === \"string\") {\n        // special case for strings\n        return type === Object || type === String;\n      }\n\n      if (obj instanceof type) {\n        // fast check if obj is already of type instance\n        return true;\n      }\n\n      if (typeof obj !== \"object\" || obj === null) {\n        return false; // not an object or null\n      }\n\n      var objType = obj.constructor;\n      if (type.$isInterface) {\n        // expecting the interface\n        // queueing interfaces from type and its base classes\n        var interfaces = [];\n        while (objType) {\n          if (objType.$interfaces) {\n            interfaces = interfaces.concat(objType.$interfaces);\n          }\n          objType = objType.$base;\n        }\n        while (interfaces.length > 0) {\n          var i = interfaces.shift();\n          if (i === type) {\n            return true;\n          }\n          // wide search in base interfaces\n          if (i.$interfaces) {\n            interfaces = interfaces.concat(i.$interfaces);\n          }\n        }\n        return false;\n      }\n\n      while (objType.hasOwnProperty(\"$base\")) {\n        objType = objType.$base;\n        if (objType === type) {\n          return true; // object was found\n        }\n      }\n\n      return false;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Math functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Calculation\n    /**\n    * Calculates the absolute value (magnitude) of a number. The absolute value of a number is always positive.\n    *\n    * @param {int|float} value   int or float\n    *\n    * @returns {int|float}\n    */\n    p.abs = Math.abs;\n\n    /**\n    * Calculates the closest int value that is greater than or equal to the value of the parameter.\n    * For example, ceil(9.03) returns the value 10.\n    *\n    * @param {float} value   float\n    *\n    * @returns {int}\n    *\n    * @see floor\n    * @see round\n    */\n    p.ceil = Math.ceil;\n\n    /**\n    * Constrains a value to not exceed a maximum and minimum value.\n    *\n    * @param {int|float} value   the value to constrain\n    * @param {int|float} value   minimum limit\n    * @param {int|float} value   maximum limit\n    *\n    * @returns {int|float}\n    *\n    * @see max\n    * @see min\n    */\n    p.constrain = function(aNumber, aMin, aMax) {\n      return aNumber > aMax ? aMax : aNumber < aMin ? aMin : aNumber;\n    };\n\n    /**\n    * Calculates the distance between two points.\n    *\n    * @param {int|float} x1     int or float: x-coordinate of the first point\n    * @param {int|float} y1     int or float: y-coordinate of the first point\n    * @param {int|float} z1     int or float: z-coordinate of the first point\n    * @param {int|float} x2     int or float: x-coordinate of the second point\n    * @param {int|float} y2     int or float: y-coordinate of the second point\n    * @param {int|float} z2     int or float: z-coordinate of the second point\n    *\n    * @returns {float}\n    */\n    p.dist = function() {\n      var dx, dy, dz;\n      if (arguments.length === 4) {\n        dx = arguments[0] - arguments[2];\n        dy = arguments[1] - arguments[3];\n        return Math.sqrt(dx * dx + dy * dy);\n      }\n      if (arguments.length === 6) {\n        dx = arguments[0] - arguments[3];\n        dy = arguments[1] - arguments[4];\n        dz = arguments[2] - arguments[5];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n      }\n    };\n\n    /**\n    * Returns Euler's number e (2.71828...) raised to the power of the value parameter.\n    *\n    * @param {int|float} value   int or float: the exponent to raise e to\n    *\n    * @returns {float}\n    */\n    p.exp = Math.exp;\n\n    /**\n    * Calculates the closest int value that is less than or equal to the value of the parameter.\n    *\n    * @param {int|float} value        the value to floor\n    *\n    * @returns {int|float}\n    *\n    * @see ceil\n    * @see round\n    */\n    p.floor = Math.floor;\n\n    /**\n    * Calculates a number between two numbers at a specific increment. The amt  parameter is the\n    * amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very\n    * near the first point, 0.5 is half-way in between, etc. The lerp function is convenient for\n    * creating motion along a straight path and for drawing dotted lines.\n    *\n    * @param {int|float} value1       float or int: first value\n    * @param {int|float} value2       float or int: second value\n    * @param {int|float} amt          float: between 0.0 and 1.0\n    *\n    * @returns {float}\n    *\n    * @see curvePoint\n    * @see bezierPoint\n    */\n    p.lerp = function(value1, value2, amt) {\n      return ((value2 - value1) * amt) + value1;\n    };\n\n    /**\n    * Calculates the natural logarithm (the base-e logarithm) of a number. This function\n    * expects the values greater than 0.0.\n    *\n    * @param {int|float} value        int or float: number must be greater then 0.0\n    *\n    * @returns {float}\n    */\n    p.log = Math.log;\n\n    /**\n    * Calculates the magnitude (or length) of a vector. A vector is a direction in space commonly\n    * used in computer graphics and linear algebra. Because it has no \"start\" position, the magnitude\n    * of a vector can be thought of as the distance from coordinate (0,0) to its (x,y) value.\n    * Therefore, mag() is a shortcut for writing \"dist(0, 0, x, y)\".\n    *\n    * @param {int|float} a       float or int: first value\n    * @param {int|float} b       float or int: second value\n    * @param {int|float} c       float or int: third value\n    *\n    * @returns {float}\n    *\n    * @see dist\n    */\n    p.mag = function(a, b, c) {\n      if (c) {\n        return Math.sqrt(a * a + b * b + c * c);\n      }\n\n      return Math.sqrt(a * a + b * b);\n    };\n\n    /**\n    * Re-maps a number from one range to another. In the example above, the number '25' is converted from\n    * a value in the range 0..100 into a value that ranges from the left edge (0) to the right edge (width) of the screen.\n    * Numbers outside the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful.\n    *\n    * @param {float} value        The incoming value to be converted\n    * @param {float} istart       Lower bound of the value's current range\n    * @param {float} istop        Upper bound of the value's current range\n    * @param {float} ostart       Lower bound of the value's target range\n    * @param {float} ostop        Upper bound of the value's target range\n    *\n    * @returns {float}\n    *\n    * @see norm\n    * @see lerp\n    */\n    p.map = function(value, istart, istop, ostart, ostop) {\n      return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n    };\n\n    /**\n    * Determines the largest value in a sequence of numbers.\n    *\n    * @param {int|float} value1         int or float\n    * @param {int|float} value2         int or float\n    * @param {int|float} value3         int or float\n    * @param {int|float} array          int or float array\n    *\n    * @returns {int|float}\n    *\n    * @see min\n    */\n    p.max = function() {\n      if (arguments.length === 2) {\n        return arguments[0] < arguments[1] ? arguments[1] : arguments[0];\n      }\n      var numbers = arguments.length === 1 ? arguments[0] : arguments; // if single argument, array is used\n      if (! (\"length\" in numbers && numbers.length > 0)) {\n        throw \"Non-empty array is expected\";\n      }\n      var max = numbers[0],\n        count = numbers.length;\n      for (var i = 1; i < count; ++i) {\n        if (max < numbers[i]) {\n          max = numbers[i];\n        }\n      }\n      return max;\n    };\n\n    /**\n    * Determines the smallest value in a sequence of numbers.\n    *\n    * @param {int|float} value1         int or float\n    * @param {int|float} value2         int or float\n    * @param {int|float} value3         int or float\n    * @param {int|float} array          int or float array\n    *\n    * @returns {int|float}\n    *\n    * @see max\n    */\n    p.min = function() {\n      if (arguments.length === 2) {\n        return arguments[0] < arguments[1] ? arguments[0] : arguments[1];\n      }\n      var numbers = arguments.length === 1 ? arguments[0] : arguments; // if single argument, array is used\n      if (! (\"length\" in numbers && numbers.length > 0)) {\n        throw \"Non-empty array is expected\";\n      }\n      var min = numbers[0],\n        count = numbers.length;\n      for (var i = 1; i < count; ++i) {\n        if (min > numbers[i]) {\n          min = numbers[i];\n        }\n      }\n      return min;\n    };\n\n    /**\n    * Normalizes a number from another range into a value between 0 and 1.\n    * Identical to map(value, low, high, 0, 1);\n    * Numbers outside the range are not clamped to 0 and 1, because out-of-range\n    * values are often intentional and useful.\n    *\n    * @param {float} aNumber    The incoming value to be converted\n    * @param {float} low        Lower bound of the value's current range\n    * @param {float} high       Upper bound of the value's current range\n    *\n    * @returns {float}\n    *\n    * @see map\n    * @see lerp\n    */\n    p.norm = function(aNumber, low, high) {\n      return (aNumber - low) / (high - low);\n    };\n\n    /**\n    * Facilitates exponential expressions. The pow() function is an efficient way of\n    * multiplying numbers by themselves (or their reciprocal) in large quantities.\n    * For example, pow(3, 5) is equivalent to the expression 3*3*3*3*3 and pow(3, -5)\n    * is equivalent to 1 / 3*3*3*3*3.\n    *\n    * @param {int|float} num        base of the exponential expression\n    * @param {int|float} exponent   power of which to raise the base\n    *\n    * @returns {float}\n    *\n    * @see sqrt\n    */\n    p.pow = Math.pow;\n\n    /**\n    * Calculates the integer closest to the value parameter. For example, round(9.2) returns the value 9.\n    *\n    * @param {float} value        number to round\n    *\n    * @returns {int}\n    *\n    * @see floor\n    * @see ceil\n    */\n    p.round = Math.round;\n\n    /**\n    * Squares a number (multiplies a number by itself). The result is always a positive number,\n    * as multiplying two negative numbers always yields a positive result. For example, -1 * -1 = 1.\n    *\n    * @param {float} value        int or float\n    *\n    * @returns {float}\n    *\n    * @see sqrt\n    */\n    p.sq = function(aNumber) {\n      return aNumber * aNumber;\n    };\n\n    /**\n    * Calculates the square root of a number. The square root of a number is always positive,\n    * even though there may be a valid negative root. The square root s of number a is such\n    * that s*s = a. It is the opposite of squaring.\n    *\n    * @param {float} value        int or float, non negative\n    *\n    * @returns {float}\n    *\n    * @see pow\n    * @see sq\n    */\n    p.sqrt = Math.sqrt;\n\n    // Trigonometry\n    /**\n    * The inverse of cos(), returns the arc cosine of a value. This function expects the\n    * values in the range of -1 to 1 and values are returned in the range 0 to PI (3.1415927).\n    *\n    * @param {float} value        the value whose arc cosine is to be returned\n    *\n    * @returns {float}\n    *\n    * @see cos\n    * @see asin\n    * @see atan\n    */\n    p.acos = Math.acos;\n\n    /**\n    * The inverse of sin(), returns the arc sine of a value. This function expects the values\n    * in the range of -1 to 1 and values are returned in the range -PI/2 to PI/2.\n    *\n    * @param {float} value        the value whose arc sine is to be returned\n    *\n    * @returns {float}\n    *\n    * @see sin\n    * @see acos\n    * @see atan\n    */\n    p.asin = Math.asin;\n\n    /**\n    * The inverse of tan(), returns the arc tangent of a value. This function expects the values\n    * in the range of -Infinity to Infinity (exclusive) and values are returned in the range -PI/2 to PI/2 .\n    *\n    * @param {float} value        -Infinity to Infinity (exclusive)\n    *\n    * @returns {float}\n    *\n    * @see tan\n    * @see asin\n    * @see acos\n    */\n    p.atan = Math.atan;\n\n    /**\n    * Calculates the angle (in radians) from a specified point to the coordinate origin as measured from\n    * the positive x-axis. Values are returned as a float in the range from PI to -PI. The atan2() function\n    * is most often used for orienting geometry to the position of the cursor. Note: The y-coordinate of the\n    * point is the first parameter and the x-coordinate is the second due the the structure of calculating the tangent.\n    *\n    * @param {float} y        y-coordinate of the point\n    * @param {float} x        x-coordinate of the point\n    *\n    * @returns {float}\n    *\n    * @see tan\n    */\n    p.atan2 = Math.atan2;\n\n    /**\n    * Calculates the cosine of an angle. This function expects the values of the angle parameter to be provided\n    * in radians (values from 0 to PI*2). Values are returned in the range -1 to 1.\n    *\n    * @param {float} value        an angle in radians\n    *\n    * @returns {float}\n    *\n    * @see tan\n    * @see sin\n    */\n    p.cos = Math.cos;\n\n    /**\n    * Converts a radian measurement to its corresponding value in degrees. Radians and degrees are two ways of\n    * measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example,\n    * 90 degrees = PI/2 = 1.5707964. All trigonometric methods in Processing require their parameters to be specified in radians.\n    *\n    * @param {int|float} value        an angle in radians\n    *\n    * @returns {float}\n    *\n    * @see radians\n    */\n    p.degrees = function(aAngle) {\n      return (aAngle * 180) / Math.PI;\n    };\n\n    /**\n    * Converts a degree measurement to its corresponding value in radians. Radians and degrees are two ways of\n    * measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example,\n    * 90 degrees = PI/2 = 1.5707964. All trigonometric methods in Processing require their parameters to be specified in radians.\n    *\n    * @param {int|float} value        an angle in radians\n    *\n    * @returns {float}\n    *\n    * @see degrees\n    */\n    p.radians = function(aAngle) {\n      return (aAngle / 180) * Math.PI;\n    };\n\n    /**\n    * Calculates the sine of an angle. This function expects the values of the angle parameter to be provided in\n    * radians (values from 0 to 6.28). Values are returned in the range -1 to 1.\n    *\n    * @param {float} value        an angle in radians\n    *\n    * @returns {float}\n    *\n    * @see cos\n    * @see radians\n    */\n    p.sin = Math.sin;\n\n    /**\n    * Calculates the ratio of the sine and cosine of an angle. This function expects the values of the angle\n    * parameter to be provided in radians (values from 0 to PI*2). Values are returned in the range infinity to -infinity.\n    *\n    * @param {float} value        an angle in radians\n    *\n    * @returns {float}\n    *\n    * @see cos\n    * @see sin\n    * @see radians\n    */\n    p.tan = Math.tan;\n\n    var currentRandom = Math.random;\n\n    /**\n    * Generates random numbers. Each time the random() function is called, it returns an unexpected value within\n    * the specified range. If one parameter is passed to the function it will return a float between zero and the\n    * value of the high parameter. The function call random(5) returns values between 0 and 5 (starting at zero,\n    * up to but not including 5). If two parameters are passed, it will return a float with a value between the\n    * parameters. The function call random(-5, 10.2) returns values starting at -5 up to (but not including) 10.2.\n    * To convert a floating-point random number to an integer, use the int() function.\n    *\n    * @param {int|float} value1         if one parameter is used, the top end to random from, if two params the low end\n    * @param {int|float} value2         the top end of the random range\n    *\n    * @returns {float}\n    *\n    * @see randomSeed\n    * @see noise\n    */\n    p.random = function() {\n      if(arguments.length === 0) {\n        return currentRandom();\n      }\n      if(arguments.length === 1) {\n        return currentRandom() * arguments[0];\n      }\n      var aMin = arguments[0], aMax = arguments[1];\n      return currentRandom() * (aMax - aMin) + aMin;\n    };\n\n    // Pseudo-random generator\n    function Marsaglia(i1, i2) {\n      // from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c\n      var z=i1 || 362436069, w= i2 || 521288629;\n      var nextInt = function() {\n        z=(36969*(z&65535)+(z>>>16)) & 0xFFFFFFFF;\n        w=(18000*(w&65535)+(w>>>16)) & 0xFFFFFFFF;\n        return (((z&0xFFFF)<<16) | (w&0xFFFF)) & 0xFFFFFFFF;\n      };\n\n      this.nextDouble = function() {\n        var i = nextInt() / 4294967296;\n        return i < 0 ? 1 + i : i;\n      };\n      this.nextInt = nextInt;\n    }\n    Marsaglia.createRandomized = function() {\n      var now = new Date();\n      return new Marsaglia((now / 60000) & 0xFFFFFFFF, now & 0xFFFFFFFF);\n    };\n\n    /**\n    * Sets the seed value for random(). By default, random() produces different results each time the\n    * program is run. Set the value parameter to a constant to return the same pseudo-random numbers\n    * each time the software is run.\n    *\n    * @param {int|float} seed         int\n    *\n    * @see random\n    * @see noise\n    * @see noiseSeed\n    */\n    p.randomSeed = function(seed) {\n      currentRandom = (new Marsaglia(seed)).nextDouble;\n    };\n\n    // Random\n    // We have two random()'s in the code... what does this do ? and which one is current ?\n    p.Random = function(seed) {\n      var haveNextNextGaussian = false, nextNextGaussian, random;\n\n      this.nextGaussian = function() {\n        if (haveNextNextGaussian) {\n          haveNextNextGaussian = false;\n          return nextNextGaussian;\n        }\n        var v1, v2, s;\n        do {\n          v1 = 2 * random() - 1; // between -1.0 and 1.0\n          v2 = 2 * random() - 1; // between -1.0 and 1.0\n          s = v1 * v1 + v2 * v2;\n        }\n        while (s >= 1 || s === 0);\n\n        var multiplier = Math.sqrt(-2 * Math.log(s) / s);\n        nextNextGaussian = v2 * multiplier;\n        haveNextNextGaussian = true;\n\n        return v1 * multiplier;\n      };\n\n      // by default use standard random, otherwise seeded\n      random = (seed === undef) ? Math.random : (new Marsaglia(seed)).nextDouble;\n    };\n\n    // Noise functions and helpers\n    function PerlinNoise(seed) {\n      var rnd = seed !== undef ? new Marsaglia(seed) : Marsaglia.createRandomized();\n      var i, j;\n      // http://www.noisemachine.com/talk1/17b.html\n      // http://mrl.nyu.edu/~perlin/noise/\n      // generate permutation\n      var perm = new Uint8Array(512);\n      for(i=0;i<256;++i) { perm[i] = i; }\n      for(i=0;i<256;++i) { var t = perm[j = rnd.nextInt() & 0xFF]; perm[j] = perm[i]; perm[i] = t; }\n      // copy to avoid taking mod in perm[0];\n      for(i=0;i<256;++i) { perm[i + 256] = perm[i]; }\n\n      function grad3d(i,x,y,z) {\n        var h = i & 15; // convert into 12 gradient directions\n        var u = h<8 ? x : y,\n            v = h<4 ? y : h===12||h===14 ? x : z;\n        return ((h&1) === 0 ? u : -u) + ((h&2) === 0 ? v : -v);\n      }\n\n      function grad2d(i,x,y) {\n        var v = (i & 1) === 0 ? x : y;\n        return (i&2) === 0 ? -v : v;\n      }\n\n      function grad1d(i,x) {\n        return (i&1) === 0 ? -x : x;\n      }\n\n      function lerp(t,a,b) { return a + t * (b - a); }\n\n      this.noise3d = function(x, y, z) {\n        var X = Math.floor(x)&255, Y = Math.floor(y)&255, Z = Math.floor(z)&255;\n        x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);\n        var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y, fz = (3-2*z)*z*z;\n        var p0 = perm[X]+Y, p00 = perm[p0] + Z, p01 = perm[p0 + 1] + Z,\n            p1 = perm[X + 1] + Y, p10 = perm[p1] + Z, p11 = perm[p1 + 1] + Z;\n        return lerp(fz,\n          lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x-1, y, z)),\n                   lerp(fx, grad3d(perm[p01], x, y-1, z), grad3d(perm[p11], x-1, y-1,z))),\n          lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z-1), grad3d(perm[p10 + 1], x-1, y, z-1)),\n                   lerp(fx, grad3d(perm[p01 + 1], x, y-1, z-1), grad3d(perm[p11 + 1], x-1, y-1,z-1))));\n      };\n\n      this.noise2d = function(x, y) {\n        var X = Math.floor(x)&255, Y = Math.floor(y)&255;\n        x -= Math.floor(x); y -= Math.floor(y);\n        var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y;\n        var p0 = perm[X]+Y, p1 = perm[X + 1] + Y;\n        return lerp(fy,\n          lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x-1, y)),\n          lerp(fx, grad2d(perm[p0 + 1], x, y-1), grad2d(perm[p1 + 1], x-1, y-1)));\n      };\n\n      this.noise1d = function(x) {\n        var X = Math.floor(x)&255;\n        x -= Math.floor(x);\n        var fx = (3-2*x)*x*x;\n        return lerp(fx, grad1d(perm[X], x), grad1d(perm[X+1], x-1));\n      };\n    }\n\n    // processing defaults\n    var noiseProfile = { generator: undef, octaves: 4, fallout: 0.5, seed: undef};\n\n    /**\n    * Returns the Perlin noise value at specified coordinates. Perlin noise is a random sequence\n    * generator producing a more natural ordered, harmonic succession of numbers compared to the\n    * standard random() function. It was invented by Ken Perlin in the 1980s and been used since\n    * in graphical applications to produce procedural textures, natural motion, shapes, terrains etc.\n    * The main difference to the random() function is that Perlin noise is defined in an infinite\n    * n-dimensional space where each pair of coordinates corresponds to a fixed semi-random value\n    * (fixed only for the lifespan of the program). The resulting value will always be between 0.0\n    * and 1.0. Processing can compute 1D, 2D and 3D noise, depending on the number of coordinates\n    * given. The noise value can be animated by moving through the noise space as demonstrated in\n    * the example above. The 2nd and 3rd dimension can also be interpreted as time.\n    * The actual noise is structured similar to an audio signal, in respect to the function's use\n    * of frequencies. Similar to the concept of harmonics in physics, perlin noise is computed over\n    * several octaves which are added together for the final result.\n    * Another way to adjust the character of the resulting sequence is the scale of the input\n    * coordinates. As the function works within an infinite space the value of the coordinates\n    * doesn't matter as such, only the distance between successive coordinates does (eg. when using\n    * noise() within a loop). As a general rule the smaller the difference between coordinates, the\n    * smoother the resulting noise sequence will be. Steps of 0.005-0.03 work best for most applications,\n    * but this will differ depending on use.\n    *\n    * @param {float} x          x coordinate in noise space\n    * @param {float} y          y coordinate in noise space\n    * @param {float} z          z coordinate in noise space\n    *\n    * @returns {float}\n    *\n    * @see random\n    * @see noiseDetail\n    */\n    p.noise = function(x, y, z) {\n      if(noiseProfile.generator === undef) {\n        // caching\n        noiseProfile.generator = new PerlinNoise(noiseProfile.seed);\n      }\n      var generator = noiseProfile.generator;\n      var effect = 1, k = 1, sum = 0;\n      for(var i=0; i<noiseProfile.octaves; ++i) {\n        effect *= noiseProfile.fallout;\n        switch (arguments.length) {\n        case 1:\n          sum += effect * (1 + generator.noise1d(k*x))/2; break;\n        case 2:\n          sum += effect * (1 + generator.noise2d(k*x, k*y))/2; break;\n        case 3:\n          sum += effect * (1 + generator.noise3d(k*x, k*y, k*z))/2; break;\n        }\n        k *= 2;\n      }\n      return sum;\n    };\n\n    /**\n    * Adjusts the character and level of detail produced by the Perlin noise function.\n    * Similar to harmonics in physics, noise is computed over several octaves. Lower octaves\n    * contribute more to the output signal and as such define the overal intensity of the noise,\n    * whereas higher octaves create finer grained details in the noise sequence. By default,\n    * noise is computed over 4 octaves with each octave contributing exactly half than its\n    * predecessor, starting at 50% strength for the 1st octave. This falloff amount can be\n    * changed by adding an additional function parameter. Eg. a falloff factor of 0.75 means\n    * each octave will now have 75% impact (25% less) of the previous lower octave. Any value\n    * between 0.0 and 1.0 is valid, however note that values greater than 0.5 might result in\n    * greater than 1.0 values returned by noise(). By changing these parameters, the signal\n    * created by the noise() function can be adapted to fit very specific needs and characteristics.\n    *\n    * @param {int} octaves          number of octaves to be used by the noise() function\n    * @param {float} falloff        falloff factor for each octave\n    *\n    * @see noise\n    */\n    p.noiseDetail = function(octaves, fallout) {\n      noiseProfile.octaves = octaves;\n      if(fallout !== undef) {\n        noiseProfile.fallout = fallout;\n      }\n    };\n\n    /**\n    * Sets the seed value for noise(). By default, noise() produces different results each\n    * time the program is run. Set the value parameter to a constant to return the same\n    * pseudo-random numbers each time the software is run.\n    *\n    * @param {int} seed         int\n    *\n    * @returns {float}\n    *\n    * @see random\n    * @see radomSeed\n    * @see noise\n    * @see noiseDetail\n    */\n    p.noiseSeed = function(seed) {\n      noiseProfile.seed = seed;\n      noiseProfile.generator = undef;\n    };\n\n    /**\n    * Defines the dimension of the display window in units of pixels. The size() function must\n    * be the first line in setup(). If size() is not called, the default size of the window is\n    * 100x100 pixels. The system variables width and height are set by the parameters passed to\n    * the size() function.\n    *\n    * @param {int} aWidth     width of the display window in units of pixels\n    * @param {int} aHeight    height of the display window in units of pixels\n    * @param {MODE} aMode     Either P2D, P3D, JAVA2D, or OPENGL\n    *\n    * @see createGraphics\n    * @see screen\n    */\n    DrawingShared.prototype.size = function(aWidth, aHeight, aMode) {\n      if (doStroke) {\n        p.stroke(0);\n      }\n\n      if (doFill) {\n        p.fill(255);\n      }\n\n      // The default 2d context has already been created in the p.init() stage if\n      // a 3d context was not specified. This is so that a 2d context will be\n      // available if size() was not called.\n      var savedProperties = {\n        fillStyle: curContext.fillStyle,\n        strokeStyle: curContext.strokeStyle,\n        lineCap: curContext.lineCap,\n        lineJoin: curContext.lineJoin\n      };\n      // remove the style width and height properties to ensure that the canvas gets set to\n      // aWidth and aHeight coming in\n      if (curElement.style.length > 0 ) {\n        curElement.style.removeProperty(\"width\");\n        curElement.style.removeProperty(\"height\");\n      }\n\n      curElement.width = p.width = aWidth || 100;\n      curElement.height = p.height = aHeight || 100;\n\n      for (var prop in savedProperties) {\n        if (savedProperties.hasOwnProperty(prop)) {\n          curContext[prop] = savedProperties[prop];\n        }\n      }\n\n      // make sure to set the default font the first time round.\n      p.textFont(curTextFont);\n\n      // Set the background to whatever it was called last as if background() was called before size()\n      // If background() hasn't been called before, set background() to a light gray\n      p.background();\n\n      // set 5% for pixels to cache (or 1000)\n      maxPixelsCached = Math.max(1000, aWidth * aHeight * 0.05);\n\n      // Externalize the context\n      p.externals.context = curContext;\n\n      for (var i = 0; i < PConstants.SINCOS_LENGTH; i++) {\n        sinLUT[i] = p.sin(i * (PConstants.PI / 180) * 0.5);\n        cosLUT[i] = p.cos(i * (PConstants.PI / 180) * 0.5);\n      }\n    };\n\n    Drawing2D.prototype.size = function(aWidth, aHeight, aMode) {\n      if (curContext === undef) {\n        // size() was called without p.init() default context, i.e. p.createGraphics()\n        curContext = curElement.getContext(\"2d\");\n        userMatrixStack = new PMatrixStack();\n        userReverseMatrixStack = new PMatrixStack();\n        modelView = new PMatrix2D();\n        modelViewInv = new PMatrix2D();\n      }\n\n      DrawingShared.prototype.size.apply(this, arguments);\n    };\n\n    Drawing3D.prototype.size = (function() {\n      var size3DCalled = false;\n\n      return function size(aWidth, aHeight, aMode) {\n        if (size3DCalled) {\n          throw \"Multiple calls to size() for 3D renders are not allowed.\";\n        }\n        size3DCalled = true;\n\n        function getGLContext(canvas) {\n          var ctxNames = ['experimental-webgl', 'webgl', 'webkit-3d'],\n              gl;\n\n          for (var i=0, l=ctxNames.length; i<l; i++) {\n            gl = canvas.getContext(ctxNames[i], {antialias: false, preserveDrawingBuffer: true});\n            if (gl) {\n              break;\n            }\n          }\n\n          return gl;\n        }\n\n        // Get the 3D rendering context.\n        try {\n          // If the HTML <canvas> dimensions differ from the\n          // dimensions specified in the size() call in the sketch, for\n          // 3D sketches, browsers will either not render or render the\n          // scene incorrectly. To fix this, we need to adjust the\n          // width and height attributes of the canvas.\n          curElement.width = p.width = aWidth || 100;\n          curElement.height = p.height = aHeight || 100;\n          curContext = getGLContext(curElement);\n          canTex = curContext.createTexture();\n          textTex = curContext.createTexture();\n        } catch(e_size) {\n          Processing.debug(e_size);\n        }\n\n        if (!curContext) {\n          throw \"WebGL context is not supported on this browser.\";\n        }\n\n        // Set defaults\n        curContext.viewport(0, 0, curElement.width, curElement.height);\n        curContext.enable(curContext.DEPTH_TEST);\n        curContext.enable(curContext.BLEND);\n        curContext.blendFunc(curContext.SRC_ALPHA, curContext.ONE_MINUS_SRC_ALPHA);\n\n        // Create the program objects to render 2D (points, lines) and\n        // 3D (spheres, boxes) shapes. Because 2D shapes are not lit,\n        // lighting calculations are ommitted from this program object.\n        programObject2D = createProgramObject(curContext, vertexShaderSrc2D, fragmentShaderSrc2D);\n\n        programObjectUnlitShape = createProgramObject(curContext, vertexShaderSrcUnlitShape, fragmentShaderSrcUnlitShape);\n\n        // Set the default point and line width for the 2D and unlit shapes.\n        p.strokeWeight(1);\n\n        // Now that the programs have been compiled, we can set the default\n        // states for the lights.\n        programObject3D = createProgramObject(curContext, vertexShaderSrc3D, fragmentShaderSrc3D);\n        curContext.useProgram(programObject3D);\n\n        // Assume we aren't using textures by default.\n        uniformi(\"usingTexture3d\", programObject3D, \"usingTexture\", usingTexture);\n\n        // Set some defaults.\n        p.lightFalloff(1, 0, 0);\n        p.shininess(1);\n        p.ambient(255, 255, 255);\n        p.specular(0, 0, 0);\n        p.emissive(0, 0, 0);\n\n        // Create buffers for 3D primitives\n        boxBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, boxBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, boxVerts, curContext.STATIC_DRAW);\n\n        boxNormBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, boxNormBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, boxNorms, curContext.STATIC_DRAW);\n\n        boxOutlineBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, boxOutlineBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, boxOutlineVerts, curContext.STATIC_DRAW);\n\n        // used to draw the rectangle and the outline\n        rectBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, rectBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, rectVerts, curContext.STATIC_DRAW);\n\n        rectNormBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, rectNormBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, rectNorms, curContext.STATIC_DRAW);\n\n        // The sphere vertices are specified dynamically since the user\n        // can change the level of detail. Everytime the user does that\n        // using sphereDetail(), the new vertices are calculated.\n        sphereBuffer = curContext.createBuffer();\n\n        lineBuffer = curContext.createBuffer();\n\n        // Shape buffers\n        fillBuffer = curContext.createBuffer();\n        fillColorBuffer = curContext.createBuffer();\n        strokeColorBuffer = curContext.createBuffer();\n        shapeTexVBO = curContext.createBuffer();\n\n        pointBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, pointBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array([0, 0, 0]), curContext.STATIC_DRAW);\n\n        textBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, textBuffer );\n        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array([1,1,0,-1,1,0,-1,-1,0,1,-1,0]), curContext.STATIC_DRAW);\n\n        textureBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, textureBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array([0,0,1,0,1,1,0,1]), curContext.STATIC_DRAW);\n\n        indexBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ELEMENT_ARRAY_BUFFER, indexBuffer);\n        curContext.bufferData(curContext.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2,2,3,0]), curContext.STATIC_DRAW);\n\n        cam = new PMatrix3D();\n        cameraInv = new PMatrix3D();\n        modelView = new PMatrix3D();\n        modelViewInv = new PMatrix3D();\n        projection = new PMatrix3D();\n        p.camera();\n        p.perspective();\n\n        userMatrixStack = new PMatrixStack();\n        userReverseMatrixStack = new PMatrixStack();\n        // used by both curve and bezier, so just init here\n        curveBasisMatrix = new PMatrix3D();\n        curveToBezierMatrix = new PMatrix3D();\n        curveDrawMatrix = new PMatrix3D();\n        bezierDrawMatrix = new PMatrix3D();\n        bezierBasisInverse = new PMatrix3D();\n        bezierBasisMatrix = new PMatrix3D();\n        bezierBasisMatrix.set(-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0);\n\n        DrawingShared.prototype.size.apply(this, arguments);\n      };\n    }());\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Lights\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Adds an ambient light. Ambient light doesn't come from a specific direction,\n     * the rays have light have bounced around so much that objects are evenly lit\n     * from all sides. Ambient lights are almost always used in combination with\n     * other types of lights. Lights need to be included in the <b>draw()</b> to\n     * remain persistent in a looping program. Placing them in the <b>setup()</b>\n     * of a looping program will cause them to only have an effect the first time\n     * through the loop. The effect of the parameters is determined by the current\n     * color mode.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     *\n     * @param {int | float} x x position of light (used for falloff)\n     * @param {int | float} y y position of light (used for falloff)\n     * @param {int | float} z z position of light (used for falloff)\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see directionalLight\n     * @see pointLight\n     * @see spotLight\n    */\n    Drawing2D.prototype.ambientLight = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.ambientLight = function(r, g, b, x, y, z) {\n      if (lightCount === PConstants.MAX_LIGHTS) {\n        throw \"can only create \" + PConstants.MAX_LIGHTS + \" lights\";\n      }\n\n      var pos = new PVector(x, y, z);\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.mult(pos, pos);\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      curContext.useProgram(programObject3D);\n      uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n      uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", pos.array());\n      uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 0);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n    };\n\n    /**\n     * Adds a directional light. Directional light comes from one direction and\n     * is stronger when hitting a surface squarely and weaker if it hits at a\n     * gentle angle. After hitting a surface, a directional lights scatters in\n     * all directions. Lights need to be included in the <b>draw()</b> to remain\n     * persistent in a looping program. Placing them in the <b>setup()</b> of a\n     * looping program will cause them to only have an effect the first time\n     * through the loop. The affect of the <br>r</b>, <br>g</b>, and <br>b</b>\n     * parameters is determined by the current color mode. The <b>nx</b>,\n     * <b>ny</b>, and <b>nz</b> parameters specify the direction the light is\n     * facing. For example, setting <b>ny</b> to -1 will cause the geometry to be\n     * lit from below (the light is facing directly upward).\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     *\n     * @param {int | float} nx direction along the x axis\n     * @param {int | float} ny direction along the y axis\n     * @param {int | float} nz direction along the z axis\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see ambientLight\n     * @see pointLight\n     * @see spotLight\n    */\n    Drawing2D.prototype.directionalLight = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.directionalLight = function(r, g, b, nx, ny, nz) {\n      if (lightCount === PConstants.MAX_LIGHTS) {\n        throw \"can only create \" + PConstants.MAX_LIGHTS + \" lights\";\n      }\n\n      curContext.useProgram(programObject3D);\n\n      var mvm = new PMatrix3D();\n      mvm.scale(1, -1, 1);\n      mvm.apply(modelView.array());\n      mvm = mvm.array();\n\n      // We need to multiply the direction by the model view matrix, but\n      // the mult function checks the w component of the vector, if it isn't\n      // present, it uses 1, so we manually multiply.\n      var dir = [\n        mvm[0] * nx + mvm[4] * ny + mvm[8] * nz,\n        mvm[1] * nx + mvm[5] * ny + mvm[9] * nz,\n        mvm[2] * nx + mvm[6] * ny + mvm[10] * nz\n      ];\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n      uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", dir);\n      uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 1);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n    };\n\n    /**\n     * Sets the falloff rates for point lights, spot lights, and ambient lights.\n     * The parameters are used to determine the falloff with the following equation:\n     *\n     * d = distance from light position to vertex position\n     * falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\n     *\n     * Like <b>fill()</b>, it affects only the elements which are created after it in the\n     * code. The default value if <b>LightFalloff(1.0, 0.0, 0.0)</b>. Thinking about an\n     * ambient light with a falloff can be tricky. It is used, for example, if you\n     * wanted a region of your scene to be lit ambiently one color and another region\n     * to be lit ambiently by another color, you would use an ambient light with location\n     * and falloff. You can think of it as a point light that doesn't care which direction\n     * a surface is facing.\n     *\n     * @param {int | float} constant constant value for determining falloff\n     * @param {int | float} linear linear value for determining falloff\n     * @param {int | float} quadratic quadratic value for determining falloff\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see ambientLight\n     * @see pointLight\n     * @see spotLight\n     * @see lightSpecular\n    */\n    Drawing2D.prototype.lightFalloff = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.lightFalloff = function(constant, linear, quadratic) {\n      curContext.useProgram(programObject3D);\n      uniformf(\"uFalloff3d\", programObject3D, \"uFalloff\", [constant, linear, quadratic]);\n    };\n\n    /**\n     * Sets the specular color for lights. Like <b>fill()</b>, it affects only the\n     * elements which are created after it in the code. Specular refers to light\n     * which bounces off a surface in a perferred direction (rather than bouncing\n     * in all directions like a diffuse light) and is used for creating highlights.\n     * The specular quality of a light interacts with the specular material qualities\n     * set through the <b>specular()</b> and <b>shininess()</b> functions.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see ambientLight\n     * @see pointLight\n     * @see spotLight\n    */\n    Drawing2D.prototype.lightSpecular = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.lightSpecular = function(r, g, b) {\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      curContext.useProgram(programObject3D);\n      uniformf(\"uSpecular3d\", programObject3D, \"uSpecular\", normalizedCol);\n    };\n\n    /**\n     * Sets the default ambient light, directional light, falloff, and specular\n     * values. The defaults are ambientLight(128, 128, 128) and\n     * directionalLight(128, 128, 128, 0, 0, -1), lightFalloff(1, 0, 0), and\n     * lightSpecular(0, 0, 0). Lights need to be included in the draw() to remain\n     * persistent in a looping program. Placing them in the setup() of a looping\n     * program will cause them to only have an effect the first time through the\n     * loop.\n     *\n     * @returns none\n     *\n     * @see ambientLight\n     * @see directionalLight\n     * @see pointLight\n     * @see spotLight\n     * @see noLights\n     *\n    */\n    p.lights = function() {\n      p.ambientLight(128, 128, 128);\n      p.directionalLight(128, 128, 128, 0, 0, -1);\n      p.lightFalloff(1, 0, 0);\n      p.lightSpecular(0, 0, 0);\n    };\n\n    /**\n     * Adds a point light. Lights need to be included in the <b>draw()</b> to remain\n     * persistent in a looping program. Placing them in the <b>setup()</b> of a\n     * looping program will cause them to only have an effect the first time through\n     * the loop. The affect of the <b>r</b>, <b>g</b>, and <b>b</b> parameters\n     * is determined by the current color mode. The <b>x</b>, <b>y</b>, and <b>z</b>\n     * parameters set the position of the light.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     * @param {int | float} x x coordinate of the light\n     * @param {int | float} y y coordinate of the light\n     * @param {int | float} z z coordinate of the light\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see directionalLight\n     * @see ambientLight\n     * @see spotLight\n    */\n    Drawing2D.prototype.pointLight = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.pointLight = function(r, g, b, x, y, z) {\n      if (lightCount === PConstants.MAX_LIGHTS) {\n        throw \"can only create \" + PConstants.MAX_LIGHTS + \" lights\";\n      }\n\n      // Place the point in view space once instead of once per vertex\n      // in the shader.\n      var pos = new PVector(x, y, z);\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.mult(pos, pos);\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      curContext.useProgram(programObject3D);\n      uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n      uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", pos.array());\n      uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 2);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n    };\n\n    /**\n     * Disable all lighting. Lighting is turned off by default and enabled with\n     * the lights() method. This function can be used to disable lighting so\n     * that 2D geometry (which does not require lighting) can be drawn after a\n     * set of lighted 3D geometry.\n     *\n     * @returns none\n     *\n     * @see lights\n    */\n    Drawing2D.prototype.noLights = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.noLights = function() {\n      lightCount = 0;\n      curContext.useProgram(programObject3D);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", lightCount);\n    };\n\n    /**\n     * Adds a spot light. Lights need to be included in the <b>draw()</b> to\n     * remain persistent in a looping program. Placing them in the <b>setup()</b>\n     * of a looping program will cause them to only have an effect the first time\n     * through the loop. The affect of the <b>r</b>, <b>g</b>, and <b>b</b> parameters\n     * is determined by the current color mode. The <b>x</b>, <b>y</b>, and <b>z</b>\n     * parameters specify the position of the light and <b>nx</b>, <b>ny</b>, <b>nz</b>\n     * specify the direction or light. The angle parameter affects <b>angle</b> of the\n     * spotlight cone.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     * @param {int | float} x coordinate of the light\n     * @param {int | float} y coordinate of the light\n     * @param {int | float} z coordinate of the light\n     * @param {int | float} nx direction along the x axis\n     * @param {int | float} ny direction along the y axis\n     * @param {int | float} nz direction along the z axis\n     * @param {float} angle angle of the spotlight cone\n     * @param {float} concentration exponent determining the center bias of the cone\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see directionalLight\n     * @see ambientLight\n     * @see pointLight\n    */\n    Drawing2D.prototype.spotLight = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.spotLight = function(r, g, b, x, y, z, nx, ny, nz, angle, concentration) {\n      if (lightCount === PConstants.MAX_LIGHTS) {\n        throw \"can only create \" + PConstants.MAX_LIGHTS + \" lights\";\n      }\n\n      curContext.useProgram(programObject3D);\n\n      // multiply the position and direction by the model view matrix\n      // once per object rather than once per vertex.\n      var pos = new PVector(x, y, z);\n      var mvm = new PMatrix3D();\n      mvm.scale(1, -1, 1);\n      mvm.apply(modelView.array());\n      mvm.mult(pos, pos);\n\n      // Convert to array since we need to directly access the elements.\n      mvm = mvm.array();\n\n      // We need to multiply the direction by the model view matrix, but\n      // the mult function checks the w component of the vector, if it isn't\n      // present, it uses 1, so we use a very small value as a work around.\n      var dir = [\n          mvm[0] * nx + mvm[4] * ny + mvm[8] * nz,\n          mvm[1] * nx + mvm[5] * ny + mvm[9] * nz,\n          mvm[2] * nx + mvm[6] * ny + mvm[10] * nz\n      ];\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n      uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", pos.array());\n      uniformf(\"uLights.direction.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".direction\", dir);\n      uniformf(\"uLights.concentration.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".concentration\", concentration);\n      uniformf(\"uLights.angle.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".angle\", angle);\n      uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 3);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Camera functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * The <b>beginCamera()</b> and <b>endCamera()</b> functions enable advanced customization of the camera space.\n     * The functions are useful if you want to more control over camera movement, however for most users, the <b>camera()</b>\n     * function will be sufficient.<br /><br />The camera functions will replace any transformations (such as <b>rotate()</b>\n     * or <b>translate()</b>) that occur before them in <b>draw()</b>, but they will not automatically replace the camera\n     * transform itself. For this reason, camera functions should be placed at the beginning of <b>draw()</b> (so that\n     * transformations happen afterwards), and the <b>camera()</b> function can be used after <b>beginCamera()</b> if\n     * you want to reset the camera before applying transformations.<br /><br />This function sets the matrix mode to the\n     * camera matrix so calls such as <b>translate()</b>, <b>rotate()</b>, applyMatrix() and resetMatrix() affect the camera.\n     * <b>beginCamera()</b> should always be used with a following <b>endCamera()</b> and pairs of <b>beginCamera()</b> and\n     * <b>endCamera()</b> cannot be nested.\n     *\n     * @see camera\n     * @see endCamera\n     * @see applyMatrix\n     * @see resetMatrix\n     * @see translate\n     * @see rotate\n     * @see scale\n     */\n    Drawing2D.prototype.beginCamera = function() {\n      throw (\"beginCamera() is not available in 2D mode\");\n    };\n\n    Drawing3D.prototype.beginCamera = function() {\n      if (manipulatingCamera) {\n        throw (\"You cannot call beginCamera() again before calling endCamera()\");\n      }\n      manipulatingCamera = true;\n      modelView = cameraInv;\n      modelViewInv = cam;\n    };\n\n    /**\n     * The <b>beginCamera()</b> and <b>endCamera()</b> functions enable advanced customization of the camera space.\n     * Please see the reference for <b>beginCamera()</b> for a description of how the functions are used.\n     *\n     * @see beginCamera\n     */\n    Drawing2D.prototype.endCamera = function() {\n      throw (\"endCamera() is not available in 2D mode\");\n    };\n\n    Drawing3D.prototype.endCamera = function() {\n      if (!manipulatingCamera) {\n        throw (\"You cannot call endCamera() before calling beginCamera()\");\n      }\n      modelView.set(cam);\n      modelViewInv.set(cameraInv);\n      manipulatingCamera = false;\n    };\n\n    /**\n     * Sets the position of the camera through setting the eye position, the center of the scene, and which axis is facing\n     * upward. Moving the eye position and the direction it is pointing (the center of the scene) allows the images to be\n     * seen from different angles. The version without any parameters sets the camera to the default position, pointing to\n     * the center of the display window with the Y axis as up. The default values are camera(width/2.0, height/2.0,\n     * (height/2.0) / tan(PI*60.0 / 360.0), width/2.0, height/2.0, 0, 0, 1, 0). This function is similar to gluLookAt()\n     * in OpenGL, but it first clears the current camera settings.\n     *\n     * @param {float} eyeX    x-coordinate for the eye\n     * @param {float} eyeY    y-coordinate for the eye\n     * @param {float} eyeZ    z-coordinate for the eye\n     * @param {float} centerX x-coordinate for the center of the scene\n     * @param {float} centerY y-coordinate for the center of the scene\n     * @param {float} centerZ z-coordinate for the center of the scene\n     * @param {float} upX     usually 0.0, 1.0, -1.0\n     * @param {float} upY     usually 0.0, 1.0, -1.0\n     * @param {float} upZ     usually 0.0, 1.0, -1.0\n     *\n     * @see beginCamera\n     * @see endCamera\n     * @see frustum\n     */\n    p.camera = function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\n      if (eyeX === undef) {\n        // Workaround if createGraphics is used.\n        cameraX = p.width / 2;\n        cameraY = p.height / 2;\n        cameraZ = cameraY / Math.tan(cameraFOV / 2);\n        eyeX = cameraX;\n        eyeY = cameraY;\n        eyeZ = cameraZ;\n        centerX = cameraX;\n        centerY = cameraY;\n        centerZ = 0;\n        upX = 0;\n        upY = 1;\n        upZ = 0;\n      }\n\n      var z = new PVector(eyeX - centerX, eyeY - centerY, eyeZ - centerZ);\n      var y = new PVector(upX, upY, upZ);\n      z.normalize();\n      var x = PVector.cross(y, z);\n      y = PVector.cross(z, x);\n      x.normalize();\n      y.normalize();\n\n      var xX = x.x,\n          xY = x.y,\n          xZ = x.z;\n\n      var yX = y.x,\n          yY = y.y,\n          yZ = y.z;\n\n      var zX = z.x,\n          zY = z.y,\n          zZ = z.z;\n\n      cam.set(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);\n\n      cam.translate(-eyeX, -eyeY, -eyeZ);\n\n      cameraInv.reset();\n      cameraInv.invApply(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);\n\n      cameraInv.translate(eyeX, eyeY, eyeZ);\n\n      modelView.set(cam);\n      modelViewInv.set(cameraInv);\n    };\n\n    /**\n     * Sets a perspective projection applying foreshortening, making distant objects appear smaller than closer ones. The\n     * parameters define a viewing volume with the shape of truncated pyramid. Objects near to the front of the volume appear\n     * their actual size, while farther objects appear smaller. This projection simulates the perspective of the world more\n     * accurately than orthographic projection. The version of perspective without parameters sets the default perspective and\n     * the version with four parameters allows the programmer to set the area precisely. The default values are:\n     * perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\n     *\n     * @param {float} fov     field-of-view angle (in radians) for vertical direction\n     * @param {float} aspect  ratio of width to height\n     * @param {float} zNear   z-position of nearest clipping plane\n     * @param {float} zFar    z-positions of farthest clipping plane\n     */\n    p.perspective = function(fov, aspect, near, far) {\n      if (arguments.length === 0) {\n        //in case canvas is resized\n        cameraY = curElement.height / 2;\n        cameraZ = cameraY / Math.tan(cameraFOV / 2);\n        cameraNear = cameraZ / 10;\n        cameraFar = cameraZ * 10;\n        cameraAspect = p.width / p.height;\n        fov = cameraFOV;\n        aspect = cameraAspect;\n        near = cameraNear;\n        far = cameraFar;\n      }\n\n      var yMax, yMin, xMax, xMin;\n      yMax = near * Math.tan(fov / 2);\n      yMin = -yMax;\n      xMax = yMax * aspect;\n      xMin = yMin * aspect;\n      p.frustum(xMin, xMax, yMin, yMax, near, far);\n    };\n\n    /**\n     * Sets a perspective matrix defined through the parameters. Works like glFrustum, except it wipes out the current\n     * perspective matrix rather than muliplying itself with it.\n     *\n     * @param {float} left   left coordinate of the clipping plane\n     * @param {float} right  right coordinate of the clipping plane\n     * @param {float} bottom bottom coordinate of the clipping plane\n     * @param {float} top    top coordinate of the clipping plane\n     * @param {float} near   near coordinate of the clipping plane\n     * @param {float} far    far coordinate of the clipping plane\n     *\n     * @see beginCamera\n     * @see camera\n     * @see endCamera\n     * @see perspective\n     */\n    Drawing2D.prototype.frustum = function() {\n      throw(\"Processing.js: frustum() is not supported in 2D mode\");\n    };\n\n    Drawing3D.prototype.frustum = function(left, right, bottom, top, near, far) {\n      frustumMode = true;\n      projection = new PMatrix3D();\n      projection.set((2 * near) / (right - left), 0, (right + left) / (right - left),\n                     0, 0, (2 * near) / (top - bottom), (top + bottom) / (top - bottom),\n                     0, 0, 0, -(far + near) / (far - near), -(2 * far * near) / (far - near),\n                     0, 0, -1, 0);\n      var proj = new PMatrix3D();\n      proj.set(projection);\n      proj.transpose();\n      curContext.useProgram(programObject2D);\n      uniformMatrix(\"projection2d\", programObject2D, \"uProjection\", false, proj.array());\n      curContext.useProgram(programObject3D);\n      uniformMatrix(\"projection3d\", programObject3D, \"uProjection\", false, proj.array());\n      curContext.useProgram(programObjectUnlitShape);\n      uniformMatrix(\"uProjectionUS\", programObjectUnlitShape, \"uProjection\", false, proj.array());\n    };\n\n    /**\n     * Sets an orthographic projection and defines a parallel clipping volume. All objects with the same dimension appear\n     * the same size, regardless of whether they are near or far from the camera. The parameters to this function specify\n     * the clipping volume where left and right are the minimum and maximum x values, top and bottom are the minimum and\n     * maximum y values, and near and far are the minimum and maximum z values. If no parameters are given, the default\n     * is used: ortho(0, width, 0, height, -10, 10).\n     *\n     * @param {float} left   left plane of the clipping volume\n     * @param {float} right  right plane of the clipping volume\n     * @param {float} bottom bottom plane of the clipping volume\n     * @param {float} top    top plane of the clipping volume\n     * @param {float} near   maximum distance from the origin to the viewer\n     * @param {float} far    maximum distance from the origin away from the viewer\n     */\n    p.ortho = function(left, right, bottom, top, near, far) {\n      if (arguments.length === 0) {\n        left = 0;\n        right = p.width;\n        bottom = 0;\n        top = p.height;\n        near = -10;\n        far = 10;\n      }\n\n      var x = 2 / (right - left);\n      var y = 2 / (top - bottom);\n      var z = -2 / (far - near);\n\n      var tx = -(right + left) / (right - left);\n      var ty = -(top + bottom) / (top - bottom);\n      var tz = -(far + near) / (far - near);\n\n      projection = new PMatrix3D();\n      projection.set(x, 0, 0, tx, 0, y, 0, ty, 0, 0, z, tz, 0, 0, 0, 1);\n\n      var proj = new PMatrix3D();\n      proj.set(projection);\n      proj.transpose();\n      curContext.useProgram(programObject2D);\n      uniformMatrix(\"projection2d\", programObject2D, \"uProjection\", false, proj.array());\n      curContext.useProgram(programObject3D);\n      uniformMatrix(\"projection3d\", programObject3D, \"uProjection\", false, proj.array());\n      curContext.useProgram(programObjectUnlitShape);\n      uniformMatrix(\"uProjectionUS\", programObjectUnlitShape, \"uProjection\", false, proj.array());\n      frustumMode = false;\n    };\n    /**\n     * The printProjection() prints the current projection matrix to the text window.\n     */\n    p.printProjection = function() {\n      projection.print();\n    };\n    /**\n     * The printCamera() function prints the current camera matrix.\n     */\n    p.printCamera = function() {\n      cam.print();\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Shapes\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * The box() function renders a box. A box is an extruded rectangle. A box with equal dimension on all sides is a cube.\n     * Calling this function with only one parameter will create a cube.\n     *\n     * @param {int|float} w  dimension of the box in the x-dimension\n     * @param {int|float} h  dimension of the box in the y-dimension\n     * @param {int|float} d  dimension of the box in the z-dimension\n     */\n    Drawing2D.prototype.box = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.box = function(w, h, d) {\n      // user can uniformly scale the box by\n      // passing in only one argument.\n      if (!h || !d) {\n        h = d = w;\n      }\n\n      // Modeling transformation\n      var model = new PMatrix3D();\n      model.scale(w, h, d);\n\n      // Viewing transformation needs to have Y flipped\n      // becuase that's what Processing does.\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      if (doFill) {\n        curContext.useProgram(programObject3D);\n        uniformMatrix(\"model3d\", programObject3D, \"uModel\", false, model.array());\n        uniformMatrix(\"view3d\", programObject3D, \"uView\", false, view.array());\n        // Fix stitching problems. (lines get occluded by triangles\n        // since they share the same depth values). This is not entirely\n        // working, but it's a start for drawing the outline. So\n        // developers can start playing around with styles.\n        curContext.enable(curContext.POLYGON_OFFSET_FILL);\n        curContext.polygonOffset(1, 1);\n        uniformf(\"color3d\", programObject3D, \"uColor\", fillStyle);\n\n        // Calculating the normal matrix can be expensive, so only\n        // do it if it's necessary.\n        if(lightCount > 0){\n          // Create the normal transformation matrix.\n          var v = new PMatrix3D();\n          v.set(view);\n\n          var m = new PMatrix3D();\n          m.set(model);\n\n          v.mult(m);\n\n          var normalMatrix = new PMatrix3D();\n          normalMatrix.set(v);\n          normalMatrix.invert();\n          normalMatrix.transpose();\n\n          uniformMatrix(\"uNormalTransform3d\", programObject3D, \"uNormalTransform\", false, normalMatrix.array());\n          vertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\", 3, boxNormBuffer);\n        }\n        else{\n          disableVertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\");\n        }\n\n        vertexAttribPointer(\"aVertex3d\", programObject3D, \"aVertex\", 3, boxBuffer);\n\n        // Turn off per vertex colors.\n        disableVertexAttribPointer(\"aColor3d\", programObject3D, \"aColor\");\n        disableVertexAttribPointer(\"aTexture3d\", programObject3D, \"aTexture\");\n\n        curContext.drawArrays(curContext.TRIANGLES, 0, boxVerts.length / 3);\n        curContext.disable(curContext.POLYGON_OFFSET_FILL);\n      }\n\n      // Draw the box outline.\n      if (lineWidth > 0 && doStroke) {\n        curContext.useProgram(programObject2D);\n        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", false);\n        vertexAttribPointer(\"vertex2d\", programObject2D, \"aVertex\", 3, boxOutlineBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n        curContext.drawArrays(curContext.LINES, 0, boxOutlineVerts.length / 3);\n      }\n    };\n\n    /**\n     * The initSphere() function is a helper function used by <b>sphereDetail()</b>\n     * This function creates and stores sphere vertices every time the user changes sphere detail.\n     *\n     * @see #sphereDetail\n     */\n    var initSphere = function() {\n      var i;\n      sphereVerts = [];\n\n      for (i = 0; i < sphereDetailU; i++) {\n        sphereVerts.push(0);\n        sphereVerts.push(-1);\n        sphereVerts.push(0);\n        sphereVerts.push(sphereX[i]);\n        sphereVerts.push(sphereY[i]);\n        sphereVerts.push(sphereZ[i]);\n      }\n      sphereVerts.push(0);\n      sphereVerts.push(-1);\n      sphereVerts.push(0);\n      sphereVerts.push(sphereX[0]);\n      sphereVerts.push(sphereY[0]);\n      sphereVerts.push(sphereZ[0]);\n\n      var v1, v11, v2;\n\n      // middle rings\n      var voff = 0;\n      for (i = 2; i < sphereDetailV; i++) {\n        v1 = v11 = voff;\n        voff += sphereDetailU;\n        v2 = voff;\n        for (var j = 0; j < sphereDetailU; j++) {\n          sphereVerts.push(sphereX[v1]);\n          sphereVerts.push(sphereY[v1]);\n          sphereVerts.push(sphereZ[v1++]);\n          sphereVerts.push(sphereX[v2]);\n          sphereVerts.push(sphereY[v2]);\n          sphereVerts.push(sphereZ[v2++]);\n        }\n\n        // close each ring\n        v1 = v11;\n        v2 = voff;\n\n        sphereVerts.push(sphereX[v1]);\n        sphereVerts.push(sphereY[v1]);\n        sphereVerts.push(sphereZ[v1]);\n        sphereVerts.push(sphereX[v2]);\n        sphereVerts.push(sphereY[v2]);\n        sphereVerts.push(sphereZ[v2]);\n      }\n\n      // add the northern cap\n      for (i = 0; i < sphereDetailU; i++) {\n        v2 = voff + i;\n\n        sphereVerts.push(sphereX[v2]);\n        sphereVerts.push(sphereY[v2]);\n        sphereVerts.push(sphereZ[v2]);\n        sphereVerts.push(0);\n        sphereVerts.push(1);\n        sphereVerts.push(0);\n      }\n\n      sphereVerts.push(sphereX[voff]);\n      sphereVerts.push(sphereY[voff]);\n      sphereVerts.push(sphereZ[voff]);\n      sphereVerts.push(0);\n      sphereVerts.push(1);\n      sphereVerts.push(0);\n\n      //set the buffer data\n      curContext.bindBuffer(curContext.ARRAY_BUFFER, sphereBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(sphereVerts), curContext.STATIC_DRAW);\n    };\n\n    /**\n     * The sphereDetail() function controls the detail used to render a sphere by adjusting the number of\n     * vertices of the sphere mesh. The default resolution is 30, which creates\n     * a fairly detailed sphere definition with vertices every 360/30 = 12\n     * degrees. If you're going to render a great number of spheres per frame,\n     * it is advised to reduce the level of detail using this function.\n     * The setting stays active until <b>sphereDetail()</b> is called again with\n     * a new parameter and so should <i>not</i> be called prior to every\n     * <b>sphere()</b> statement, unless you wish to render spheres with\n     * different settings, e.g. using less detail for smaller spheres or ones\n     * further away from the camera. To control the detail of the horizontal\n     * and vertical resolution independently, use the version of the functions\n     * with two parameters. Calling this function with one parameter sets the number of segments\n     *(minimum of 3) used per full circle revolution. This is equivalent to calling the function with\n     * two identical values.\n     *\n     * @param {int} ures    number of segments used horizontally (longitudinally) per full circle revolution\n     * @param {int} vres    number of segments used vertically (latitudinally) from top to bottom\n     *\n     * @see #sphere()\n     */\n    p.sphereDetail = function(ures, vres) {\n      var i;\n\n      if (arguments.length === 1) {\n        ures = vres = arguments[0];\n      }\n\n      if (ures < 3) {\n        ures = 3;\n      } // force a minimum res\n      if (vres < 2) {\n        vres = 2;\n      } // force a minimum res\n      // if it hasn't changed do nothing\n      if ((ures === sphereDetailU) && (vres === sphereDetailV)) {\n        return;\n      }\n\n      var delta = PConstants.SINCOS_LENGTH / ures;\n      var cx = new Float32Array(ures);\n      var cz = new Float32Array(ures);\n      // calc unit circle in XZ plane\n      for (i = 0; i < ures; i++) {\n        cx[i] = cosLUT[((i * delta) % PConstants.SINCOS_LENGTH) | 0];\n        cz[i] = sinLUT[((i * delta) % PConstants.SINCOS_LENGTH) | 0];\n      }\n\n      // computing vertexlist\n      // vertexlist starts at south pole\n      var vertCount = ures * (vres - 1) + 2;\n      var currVert = 0;\n\n      // re-init arrays to store vertices\n      sphereX = new Float32Array(vertCount);\n      sphereY = new Float32Array(vertCount);\n      sphereZ = new Float32Array(vertCount);\n\n      var angle_step = (PConstants.SINCOS_LENGTH * 0.5) / vres;\n      var angle = angle_step;\n\n      // step along Y axis\n      for (i = 1; i < vres; i++) {\n        var curradius = sinLUT[(angle % PConstants.SINCOS_LENGTH) | 0];\n        var currY = -cosLUT[(angle % PConstants.SINCOS_LENGTH) | 0];\n        for (var j = 0; j < ures; j++) {\n          sphereX[currVert] = cx[j] * curradius;\n          sphereY[currVert] = currY;\n          sphereZ[currVert++] = cz[j] * curradius;\n        }\n        angle += angle_step;\n      }\n      sphereDetailU = ures;\n      sphereDetailV = vres;\n\n      // make the sphere verts and norms\n      initSphere();\n    };\n\n    /**\n     * The sphere() function draws a sphere with radius r centered at coordinate 0, 0, 0.\n     * A sphere is a hollow ball made from tessellated triangles.\n     *\n     * @param {int|float} r the radius of the sphere\n     */\n    Drawing2D.prototype.sphere = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.sphere = function() {\n      var sRad = arguments[0];\n\n      if ((sphereDetailU < 3) || (sphereDetailV < 2)) {\n        p.sphereDetail(30);\n      }\n\n      // Modeling transformation.\n      var model = new PMatrix3D();\n      model.scale(sRad, sRad, sRad);\n\n      // viewing transformation needs to have Y flipped\n      // becuase that's what Processing does.\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      if (doFill) {\n        // Calculating the normal matrix can be expensive, so only\n        // do it if it's necessary.\n        if(lightCount > 0){\n          // Create a normal transformation matrix.\n          var v = new PMatrix3D();\n          v.set(view);\n\n          var m = new PMatrix3D();\n          m.set(model);\n\n          v.mult(m);\n\n          var normalMatrix = new PMatrix3D();\n          normalMatrix.set(v);\n          normalMatrix.invert();\n          normalMatrix.transpose();\n\n          uniformMatrix(\"uNormalTransform3d\", programObject3D, \"uNormalTransform\", false, normalMatrix.array());\n          vertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\", 3, sphereBuffer);\n        }\n        else{\n          disableVertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\");\n        }\n\n        curContext.useProgram(programObject3D);\n        disableVertexAttribPointer(\"aTexture3d\", programObject3D, \"aTexture\");\n\n        uniformMatrix(\"uModel3d\", programObject3D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView3d\", programObject3D, \"uView\", false, view.array());\n        vertexAttribPointer(\"aVertex3d\", programObject3D, \"aVertex\", 3, sphereBuffer);\n\n        // Turn off per vertex colors.\n        disableVertexAttribPointer(\"aColor3d\", programObject3D, \"aColor\");\n\n        // fix stitching problems. (lines get occluded by triangles\n        // since they share the same depth values). This is not entirely\n        // working, but it's a start for drawing the outline. So\n        // developers can start playing around with styles.\n        curContext.enable(curContext.POLYGON_OFFSET_FILL);\n        curContext.polygonOffset(1, 1);\n        uniformf(\"uColor3d\", programObject3D, \"uColor\", fillStyle);\n        curContext.drawArrays(curContext.TRIANGLE_STRIP, 0, sphereVerts.length / 3);\n        curContext.disable(curContext.POLYGON_OFFSET_FILL);\n      }\n\n      // Draw the sphere outline.\n      if (lineWidth > 0 && doStroke) {\n        curContext.useProgram(programObject2D);\n        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, sphereBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText\", programObject2D, \"uIsDrawingText\", false);\n        curContext.drawArrays(curContext.LINE_STRIP, 0, sphereVerts.length / 3);\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Coordinates\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Returns the three-dimensional X, Y, Z position in model space. This returns\n     * the X value for a given coordinate based on the current set of transformations\n     * (scale, rotate, translate, etc.) The X value can be used to place an object\n     * in space relative to the location of the original point once the transformations\n     * are no longer in use.<br />\n     * <br />\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see modelY\n     * @see modelZ\n    */\n    p.modelX = function(x, y, z) {\n      var mv = modelView.array();\n      var ci = cameraInv.array();\n\n      var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n      var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n      var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n      var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n\n      var ox = ci[0] * ax + ci[1] * ay + ci[2] * az + ci[3] * aw;\n      var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;\n\n      return (ow !== 0) ? ox / ow : ox;\n    };\n\n    /**\n     * Returns the three-dimensional X, Y, Z position in model space. This returns\n     * the Y value for a given coordinate based on the current set of transformations\n     * (scale, rotate, translate, etc.) The Y value can be used to place an object in\n     * space relative to the location of the original point once the transformations\n     * are no longer in use.<br />\n     * <br />\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see modelX\n     * @see modelZ\n    */\n    p.modelY = function(x, y, z) {\n      var mv = modelView.array();\n      var ci = cameraInv.array();\n\n      var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n      var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n      var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n      var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n\n      var oy = ci[4] * ax + ci[5] * ay + ci[6] * az + ci[7] * aw;\n      var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;\n\n      return (ow !== 0) ? oy / ow : oy;\n    };\n\n    /**\n     * Returns the three-dimensional X, Y, Z position in model space. This returns\n     * the Z value for a given coordinate based on the current set of transformations\n     * (scale, rotate, translate, etc.) The Z value can be used to place an object in\n     * space relative to the location of the original point once the transformations\n     * are no longer in use.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see modelX\n     * @see modelY\n    */\n    p.modelZ = function(x, y, z) {\n      var mv = modelView.array();\n      var ci = cameraInv.array();\n\n      var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n      var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n      var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n      var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n\n      var oz = ci[8] * ax + ci[9] * ay + ci[10] * az + ci[11] * aw;\n      var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;\n\n      return (ow !== 0) ? oz / ow : oz;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Material Properties\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Sets the ambient reflectance for shapes drawn to the screen. This is\n     * combined with the ambient light component of environment. The color\n     * components set through the parameters define the reflectance. For example in\n     * the default color mode, setting v1=255, v2=126, v3=0, would cause all the\n     * red light to reflect and half of the green light to reflect. Used in combination\n     * with <b>emissive()</b>, <b>specular()</b>, and <b>shininess()</b> in setting\n     * the materal properties of shapes.\n     *\n     * @param {int | float} gray\n     *\n     * @returns none\n     *\n     * @see emissive\n     * @see specular\n     * @see shininess\n    */\n    Drawing2D.prototype.ambient = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.ambient = function(v1, v2, v3) {\n      curContext.useProgram(programObject3D);\n      uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n      var col = p.color(v1, v2, v3);\n      uniformf(\"uMaterialAmbient3d\", programObject3D, \"uMaterialAmbient\", p.color.toGLArray(col).slice(0, 3));\n    };\n\n    /**\n     * Sets the emissive color of the material used for drawing shapes\n     * drawn to the screen. Used in combination with ambient(), specular(),\n     * and shininess() in setting the material properties of shapes.\n     *\n     * Can be called in the following ways:\n     *\n     * emissive(gray)\n     * @param {int | float} gray number specifying value between white and black\n     *\n     * emissive(color)\n     * @param {color} color any value of the color datatype\n     *\n     * emissive(v1, v2, v3)\n     * @param {int | float} v1 red or hue value\n     * @param {int | float} v2 green or saturation value\n     * @param {int | float} v3 blue or brightness value\n     *\n     * @returns none\n     *\n     * @see ambient\n     * @see specular\n     * @see shininess\n    */\n    Drawing2D.prototype.emissive = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.emissive = function(v1, v2, v3) {\n      curContext.useProgram(programObject3D);\n      uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n      var col = p.color(v1, v2, v3);\n      uniformf(\"uMaterialEmissive3d\", programObject3D, \"uMaterialEmissive\", p.color.toGLArray(col).slice(0, 3));\n    };\n\n    /**\n     * Sets the amount of gloss in the surface of shapes. Used in combination with\n     * <b>ambient()</b>, <b>specular()</b>, and <b>emissive()</b> in setting the\n     * material properties of shapes.\n     *\n     * @param {float} shine degree of shininess\n     *\n     * @returns none\n    */\n    Drawing2D.prototype.shininess = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.shininess = function(shine) {\n      curContext.useProgram(programObject3D);\n      uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n      uniformf(\"uShininess3d\", programObject3D, \"uShininess\", shine);\n    };\n\n    /**\n     * Sets the specular color of the materials used for shapes drawn to the screen,\n     * which sets the color of hightlights. Specular refers to light which bounces\n     * off a surface in a perferred direction (rather than bouncing in all directions\n     * like a diffuse light). Used in combination with emissive(), ambient(), and\n     * shininess() in setting the material properties of shapes.\n     *\n     * Can be called in the following ways:\n     *\n     * specular(gray)\n     * @param {int | float} gray number specifying value between white and black\n     *\n     * specular(gray, alpha)\n     * @param {int | float} gray number specifying value between white and black\n     * @param {int | float} alpha opacity\n     *\n     * specular(color)\n     * @param {color} color any value of the color datatype\n     *\n     * specular(v1, v2, v3)\n     * @param {int | float} v1 red or hue value\n     * @param {int | float} v2 green or saturation value\n     * @param {int | float} v3 blue or brightness value\n     *\n     * specular(v1, v2, v3, alpha)\n     * @param {int | float} v1 red or hue value\n     * @param {int | float} v2 green or saturation value\n     * @param {int | float} v3 blue or brightness value\n     * @param {int | float} alpha opacity\n     *\n     * @returns none\n     *\n     * @see ambient\n     * @see emissive\n     * @see shininess\n    */\n    Drawing2D.prototype.specular = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.specular = function(v1, v2, v3) {\n      curContext.useProgram(programObject3D);\n      uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n      var col = p.color(v1, v2, v3);\n      uniformf(\"uMaterialSpecular3d\", programObject3D, \"uMaterialSpecular\", p.color.toGLArray(col).slice(0, 3));\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Coordinates\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Takes a three-dimensional X, Y, Z position and returns the X value for\n     * where it will appear on a (two-dimensional) screen.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z optional coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see screenY\n     * @see screenZ\n    */\n    p.screenX = function( x, y, z ) {\n      var mv = modelView.array();\n      if( mv.length === 16 )\n      {\n        var ax = mv[ 0]*x + mv[ 1]*y + mv[ 2]*z + mv[ 3];\n        var ay = mv[ 4]*x + mv[ 5]*y + mv[ 6]*z + mv[ 7];\n        var az = mv[ 8]*x + mv[ 9]*y + mv[10]*z + mv[11];\n        var aw = mv[12]*x + mv[13]*y + mv[14]*z + mv[15];\n\n        var pj = projection.array();\n\n        var ox = pj[ 0]*ax + pj[ 1]*ay + pj[ 2]*az + pj[ 3]*aw;\n        var ow = pj[12]*ax + pj[13]*ay + pj[14]*az + pj[15]*aw;\n\n        if ( ow !== 0 ){\n          ox /= ow;\n        }\n        return p.width * ( 1 + ox ) / 2.0;\n      }\n      // We assume that we're in 2D\n      return modelView.multX(x, y);\n    };\n\n    /**\n     * Takes a three-dimensional X, Y, Z position and returns the Y value for\n     * where it will appear on a (two-dimensional) screen.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z optional coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see screenX\n     * @see screenZ\n    */\n    p.screenY = function screenY( x, y, z ) {\n      var mv = modelView.array();\n      if( mv.length === 16 ) {\n        var ax = mv[ 0]*x + mv[ 1]*y + mv[ 2]*z + mv[ 3];\n        var ay = mv[ 4]*x + mv[ 5]*y + mv[ 6]*z + mv[ 7];\n        var az = mv[ 8]*x + mv[ 9]*y + mv[10]*z + mv[11];\n        var aw = mv[12]*x + mv[13]*y + mv[14]*z + mv[15];\n\n        var pj = projection.array();\n\n        var oy = pj[ 4]*ax + pj[ 5]*ay + pj[ 6]*az + pj[ 7]*aw;\n        var ow = pj[12]*ax + pj[13]*ay + pj[14]*az + pj[15]*aw;\n\n        if ( ow !== 0 ){\n          oy /= ow;\n        }\n        return p.height * ( 1 + oy ) / 2.0;\n      }\n      // We assume that we're in 2D\n      return modelView.multY(x, y);\n    };\n\n    /**\n     * Takes a three-dimensional X, Y, Z position and returns the Z value for\n     * where it will appear on a (two-dimensional) screen.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see screenX\n     * @see screenY\n    */\n    p.screenZ = function screenZ( x, y, z ) {\n      var mv = modelView.array();\n      if( mv.length !== 16 ) {\n        return 0;\n      }\n\n      var pj = projection.array();\n\n      var ax = mv[ 0]*x + mv[ 1]*y + mv[ 2]*z + mv[ 3];\n      var ay = mv[ 4]*x + mv[ 5]*y + mv[ 6]*z + mv[ 7];\n      var az = mv[ 8]*x + mv[ 9]*y + mv[10]*z + mv[11];\n      var aw = mv[12]*x + mv[13]*y + mv[14]*z + mv[15];\n\n      var oz = pj[ 8]*ax + pj[ 9]*ay + pj[10]*az + pj[11]*aw;\n      var ow = pj[12]*ax + pj[13]*ay + pj[14]*az + pj[15]*aw;\n\n      if ( ow !== 0 ) {\n        oz /= ow;\n      }\n      return ( oz + 1 ) / 2.0;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Style functions\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * The fill() function sets the color used to fill shapes. For example, if you run <b>fill(204, 102, 0)</b>, all subsequent shapes will be filled with orange.\n     * This color is either specified in terms of the RGB or HSB color depending on the current <b>colorMode()</b>\n     *(the default color space is RGB, with each value in the range from 0 to 255).\n     * <br><br>When using hexadecimal notation to specify a color, use \"#\" or \"0x\" before the values (e.g. #CCFFAA, 0xFFCCFFAA).\n     * The # syntax uses six digits to specify a color (the way colors are specified in HTML and CSS). When using the hexadecimal notation starting with \"0x\",\n     * the hexadecimal value must be specified with eight characters; the first two characters define the alpha component and the remainder the red, green, and blue components.\n     * <br><br>The value for the parameter \"gray\" must be less than or equal to the current maximum value as specified by <b>colorMode()</b>. The default maximum value is 255.\n     * <br><br>To change the color of an image (or a texture), use tint().\n     *\n     * @param {int|float} gray    number specifying value between white and black\n     * @param {int|float} value1  red or hue value\n     * @param {int|float} value2  green or saturation value\n     * @param {int|float} value3  blue or brightness value\n     * @param {int|float} alpha   opacity of the fill\n     * @param {Color} color       any value of the color datatype\n     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     *\n     * @see #noFill()\n     * @see #stroke()\n     * @see #tint()\n     * @see #background()\n     * @see #colorMode()\n     */\n    DrawingShared.prototype.fill = function() {\n      var color = p.color(arguments[0], arguments[1], arguments[2], arguments[3]);\n      if(color === currentFillColor && doFill) {\n        return;\n      }\n      doFill = true;\n      currentFillColor = color;\n    };\n\n    Drawing2D.prototype.fill = function() {\n      DrawingShared.prototype.fill.apply(this, arguments);\n      isFillDirty = true;\n    };\n\n    Drawing3D.prototype.fill = function() {\n      DrawingShared.prototype.fill.apply(this, arguments);\n      fillStyle = p.color.toGLArray(currentFillColor);\n    };\n\n    function executeContextFill() {\n      if(doFill) {\n        if(isFillDirty) {\n          curContext.fillStyle = p.color.toString(currentFillColor);\n          isFillDirty = false;\n        }\n        curContext.fill();\n      }\n    }\n\n    /**\n     * The noFill() function disables filling geometry. If both <b>noStroke()</b> and <b>noFill()</b>\n     * are called, no shapes will be drawn to the screen.\n     *\n     * @see #fill()\n     *\n     */\n    p.noFill = function() {\n      doFill = false;\n    };\n\n    /**\n     * The stroke() function sets the color used to draw lines and borders around shapes. This color\n     * is either specified in terms of the RGB or HSB color depending on the\n     * current <b>colorMode()</b> (the default color space is RGB, with each\n     * value in the range from 0 to 255).\n     * <br><br>When using hexadecimal notation to specify a color, use \"#\" or\n     * \"0x\" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six\n     * digits to specify a color (the way colors are specified in HTML and CSS).\n     * When using the hexadecimal notation starting with \"0x\", the hexadecimal\n     * value must be specified with eight characters; the first two characters\n     * define the alpha component and the remainder the red, green, and blue\n     * components.\n     * <br><br>The value for the parameter \"gray\" must be less than or equal\n     * to the current maximum value as specified by <b>colorMode()</b>.\n     * The default maximum value is 255.\n     *\n     * @param {int|float} gray    number specifying value between white and black\n     * @param {int|float} value1  red or hue value\n     * @param {int|float} value2  green or saturation value\n     * @param {int|float} value3  blue or brightness value\n     * @param {int|float} alpha   opacity of the stroke\n     * @param {Color} color       any value of the color datatype\n     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     *\n     * @see #fill()\n     * @see #noStroke()\n     * @see #tint()\n     * @see #background()\n     * @see #colorMode()\n     */\n    DrawingShared.prototype.stroke = function() {\n      var color = p.color(arguments[0], arguments[1], arguments[2], arguments[3]);\n      if(color === currentStrokeColor && doStroke) {\n        return;\n      }\n      doStroke = true;\n      currentStrokeColor = color;\n    };\n\n    Drawing2D.prototype.stroke = function() {\n      DrawingShared.prototype.stroke.apply(this, arguments);\n      isStrokeDirty = true;\n    };\n\n    Drawing3D.prototype.stroke = function() {\n      DrawingShared.prototype.stroke.apply(this, arguments);\n      strokeStyle = p.color.toGLArray(currentStrokeColor);\n    };\n\n    function executeContextStroke() {\n      if(doStroke) {\n        if(isStrokeDirty) {\n          curContext.strokeStyle = p.color.toString(currentStrokeColor);\n          isStrokeDirty = false;\n        }\n        curContext.stroke();\n      }\n    }\n\n    /**\n     * The noStroke() function disables drawing the stroke (outline). If both <b>noStroke()</b> and\n     * <b>noFill()</b> are called, no shapes will be drawn to the screen.\n     *\n     * @see #stroke()\n     */\n    p.noStroke = function() {\n      doStroke = false;\n    };\n\n    /**\n     * The strokeWeight() function sets the width of the stroke used for lines, points, and the border around shapes.\n     * All widths are set in units of pixels.\n     *\n     * @param {int|float} w the weight (in pixels) of the stroke\n     */\n    DrawingShared.prototype.strokeWeight = function(w) {\n      lineWidth = w;\n    };\n\n    Drawing2D.prototype.strokeWeight = function(w) {\n      DrawingShared.prototype.strokeWeight.apply(this, arguments);\n      curContext.lineWidth = w;\n    };\n\n    Drawing3D.prototype.strokeWeight = function(w) {\n      DrawingShared.prototype.strokeWeight.apply(this, arguments);\n\n      // Processing groups the weight of points and lines under this one function,\n      // but for WebGL, we need to set a uniform for points and call a function for line.\n\n      curContext.useProgram(programObject2D);\n      uniformf(\"pointSize2d\", programObject2D, \"uPointSize\", w);\n\n      curContext.useProgram(programObjectUnlitShape);\n      uniformf(\"pointSizeUnlitShape\", programObjectUnlitShape, \"uPointSize\", w);\n\n      curContext.lineWidth(w);\n    };\n\n    /**\n     * The strokeCap() function sets the style for rendering line endings. These ends are either squared, extended, or rounded and\n     * specified with the corresponding parameters SQUARE, PROJECT, and ROUND. The default cap is ROUND.\n     * This function is not available with the P2D, P3D, or OPENGL renderers\n     *\n     * @param {int} value Either SQUARE, PROJECT, or ROUND\n     */\n    p.strokeCap = function(value) {\n      drawing.$ensureContext().lineCap = value;\n    };\n\n    /**\n     * The strokeJoin() function sets the style of the joints which connect line segments.\n     * These joints are either mitered, beveled, or rounded and specified with the corresponding parameters MITER, BEVEL, and ROUND. The default joint is MITER.\n     * This function is not available with the P2D, P3D, or OPENGL renderers\n     *\n     * @param {int} value Either SQUARE, PROJECT, or ROUND\n     */\n    p.strokeJoin = function(value) {\n      drawing.$ensureContext().lineJoin = value;\n    };\n\n    /**\n     * The smooth() function draws all geometry with smooth (anti-aliased) edges. This will slow down the frame rate of the application,\n     * but will enhance the visual refinement. <br/><br/>\n     * Note that smooth() will also improve image quality of resized images, and noSmooth() will disable image (and font) smoothing altogether.\n     * When working with a 3D sketch, smooth will draw points as circles rather than squares.\n     *\n     * @see #noSmooth()\n     * @see #hint()\n     * @see #size()\n     */\n\n    Drawing2D.prototype.smooth = function() {\n      renderSmooth = true;\n      var style = curElement.style;\n      style.setProperty(\"image-rendering\", \"optimizeQuality\", \"important\");\n      style.setProperty(\"-ms-interpolation-mode\", \"bicubic\", \"important\");\n      if (curContext.hasOwnProperty(\"mozImageSmoothingEnabled\")) {\n        curContext.mozImageSmoothingEnabled = true;\n      }\n    };\n\n    Drawing3D.prototype.smooth = function(){\n      renderSmooth = true;\n    };\n\n    /**\n     * The noSmooth() function draws all geometry with jagged (aliased) edges.\n     *\n     * @see #smooth()\n     */\n\n    Drawing2D.prototype.noSmooth = function() {\n      renderSmooth = false;\n      var style = curElement.style;\n      style.setProperty(\"image-rendering\", \"optimizeSpeed\", \"important\");\n      style.setProperty(\"image-rendering\", \"-moz-crisp-edges\", \"important\");\n      style.setProperty(\"image-rendering\", \"-webkit-optimize-contrast\", \"important\");\n      style.setProperty(\"image-rendering\", \"optimize-contrast\", \"important\");\n      style.setProperty(\"-ms-interpolation-mode\", \"nearest-neighbor\", \"important\");\n      if (curContext.hasOwnProperty(\"mozImageSmoothingEnabled\")) {\n        curContext.mozImageSmoothingEnabled = false;\n      }\n    };\n\n    Drawing3D.prototype.noSmooth = function(){\n      renderSmooth = false;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Vector drawing functions\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * The point() function draws a point, a coordinate in space at the dimension of one pixel.\n     * The first parameter is the horizontal value for the point, the second\n     * value is the vertical value for the point, and the optional third value\n     * is the depth value. Drawing this shape in 3D using the <b>z</b>\n     * parameter requires the P3D or OPENGL parameter in combination with\n     * size as shown in the above example.\n     *\n     * @param {int|float} x x-coordinate of the point\n     * @param {int|float} y y-coordinate of the point\n     * @param {int|float} z z-coordinate of the point\n     *\n     * @see #beginShape()\n     */\n    Drawing2D.prototype.point = function(x, y) {\n      if (!doStroke) {\n        return;\n      }\n\n      x = Math.round(x);\n      y = Math.round(y);\n      curContext.fillStyle = p.color.toString(currentStrokeColor);\n      isFillDirty = true;\n      // Draw a circle for any point larger than 1px\n      if (lineWidth > 1) {\n        curContext.beginPath();\n        curContext.arc(x, y, lineWidth / 2, 0, PConstants.TWO_PI, false);\n        curContext.fill();\n      } else {\n        curContext.fillRect(x, y, 1, 1);\n      }\n    };\n\n    Drawing3D.prototype.point = function(x, y, z) {\n      var model = new PMatrix3D();\n\n      // move point to position\n      model.translate(x, y, z || 0);\n      model.transpose();\n\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      curContext.useProgram(programObject2D);\n      uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n      uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n\n      if (lineWidth > 0 && doStroke) {\n        // this will be replaced with the new bit shifting color code\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", false);\n        uniformi(\"uSmooth2d\", programObject2D, \"uSmooth\", renderSmooth);\n        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, pointBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n        curContext.drawArrays(curContext.POINTS, 0, 1);\n      }\n    };\n\n    /**\n     * Using the <b>beginShape()</b> and <b>endShape()</b> functions allow creating more complex forms.\n     * <b>beginShape()</b> begins recording vertices for a shape and <b>endShape()</b> stops recording.\n     * The value of the <b>MODE</b> parameter tells it which types of shapes to create from the provided vertices.\n     * With no mode specified, the shape can be any irregular polygon. After calling the <b>beginShape()</b> function,\n     * a series of <b>vertex()</b> commands must follow. To stop drawing the shape, call <b>endShape()</b>.\n     * The <b>vertex()</b> function with two parameters specifies a position in 2D and the <b>vertex()</b>\n     * function with three parameters specifies a position in 3D. Each shape will be outlined with the current\n     * stroke color and filled with the fill color.\n     *\n     * @param {int} MODE either POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP.\n     *\n     * @see endShape\n     * @see vertex\n     * @see curveVertex\n     * @see bezierVertex\n     */\n    p.beginShape = function(type) {\n      curShape = type;\n      curvePoints = [];\n      vertArray = [];\n    };\n\n    /**\n     * All shapes are constructed by connecting a series of vertices. <b>vertex()</b> is used to specify the vertex\n     * coordinates for points, lines, triangles, quads, and polygons and is used exclusively within the <b>beginShape()</b>\n     * and <b>endShape()</b> function. <br /><br />Drawing a vertex in 3D using the <b>z</b> parameter requires the P3D or\n     * OPENGL parameter in combination with size as shown in the above example.<br /><br />This function is also used to map a\n     * texture onto the geometry. The <b>texture()</b> function declares the texture to apply to the geometry and the <b>u</b>\n     * and <b>v</b> coordinates set define the mapping of this texture to the form. By default, the coordinates used for\n     * <b>u</b> and <b>v</b> are specified in relation to the image's size in pixels, but this relation can be changed with\n     * <b>textureMode()</b>.\n     *\n     * @param {int | float} x x-coordinate of the vertex\n     * @param {int | float} y y-coordinate of the vertex\n     * @param {boolean} moveto flag to indicate whether this is a new subpath\n     *\n     * @see beginShape\n     * @see endShape\n     * @see bezierVertex\n     * @see curveVertex\n     * @see texture\n     */\n\n    Drawing2D.prototype.vertex = function(x, y, moveTo) {\n      var vert = [];\n\n      if (firstVert) { firstVert = false; }\n      vert[\"isVert\"] = true;\n\n      vert[0] = x;\n      vert[1] = y;\n      vert[2] = 0;\n      vert[3] = 0;\n      vert[4] = 0;\n\n      // fill and stroke color\n      vert[5] = currentFillColor;\n      vert[6] = currentStrokeColor;\n\n      vertArray.push(vert);\n      if (moveTo) {\n        vertArray[vertArray.length-1][\"moveTo\"] = moveTo;\n      }\n    };\n\n    Drawing3D.prototype.vertex = function(x, y, z, u, v) {\n      var vert = [];\n\n      if (firstVert) { firstVert = false; }\n      vert[\"isVert\"] = true;\n\n      if (v === undef && usingTexture) {\n        v = u;\n        u = z;\n        z = 0;\n      }\n\n      // Convert u and v to normalized coordinates\n      if (u !== undef && v !== undef) {\n        if (curTextureMode === PConstants.IMAGE) {\n          u /= curTexture.width;\n          v /= curTexture.height;\n        }\n        u = u > 1 ? 1 : u;\n        u = u < 0 ? 0 : u;\n        v = v > 1 ? 1 : v;\n        v = v < 0 ? 0 : v;\n      }\n\n      vert[0] = x;\n      vert[1] = y;\n      vert[2] = z || 0;\n      vert[3] = u || 0;\n      vert[4] = v || 0;\n\n      // fill rgba\n      vert[5] = fillStyle[0];\n      vert[6] = fillStyle[1];\n      vert[7] = fillStyle[2];\n      vert[8] = fillStyle[3];\n      // stroke rgba\n      vert[9] = strokeStyle[0];\n      vert[10] = strokeStyle[1];\n      vert[11] = strokeStyle[2];\n      vert[12] = strokeStyle[3];\n      //normals\n      vert[13] = normalX;\n      vert[14] = normalY;\n      vert[15] = normalZ;\n\n      vertArray.push(vert);\n    };\n\n    /**\n     * @private\n     * Renders 3D points created from calls to vertex and beginShape/endShape\n     *\n     * @param {Array} vArray an array of vertex coordinate\n     * @param {Array} cArray an array of colours used for the vertices\n     *\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     */\n    var point3D = function(vArray, cArray){\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      curContext.useProgram(programObjectUnlitShape);\n\n      uniformMatrix(\"uViewUS\", programObjectUnlitShape, \"uView\", false, view.array());\n      uniformi(\"uSmoothUS\", programObjectUnlitShape, \"uSmooth\", renderSmooth);\n\n      vertexAttribPointer(\"aVertexUS\", programObjectUnlitShape, \"aVertex\", 3, pointBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(vArray), curContext.STREAM_DRAW);\n\n      vertexAttribPointer(\"aColorUS\", programObjectUnlitShape, \"aColor\", 4, fillColorBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(cArray), curContext.STREAM_DRAW);\n\n      curContext.drawArrays(curContext.POINTS, 0, vArray.length/3);\n    };\n\n    /**\n     * @private\n     * Renders 3D lines created from calls to beginShape/vertex/endShape - based on the mode specified LINES, LINE_LOOP, etc.\n     *\n     * @param {Array} vArray an array of vertex coordinate\n     * @param {String} mode  either LINES, LINE_LOOP, or LINE_STRIP\n     * @param {Array} cArray an array of colours used for the vertices\n     *\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     */\n    var line3D = function(vArray, mode, cArray){\n      var ctxMode;\n      if (mode === \"LINES\"){\n        ctxMode = curContext.LINES;\n      }\n      else if(mode === \"LINE_LOOP\"){\n        ctxMode = curContext.LINE_LOOP;\n      }\n      else{\n        ctxMode = curContext.LINE_STRIP;\n      }\n\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      curContext.useProgram(programObjectUnlitShape);\n      uniformMatrix(\"uViewUS\", programObjectUnlitShape, \"uView\", false, view.array());\n      vertexAttribPointer(\"aVertexUS\", programObjectUnlitShape, \"aVertex\", 3, lineBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(vArray), curContext.STREAM_DRAW);\n      vertexAttribPointer(\"aColorUS\", programObjectUnlitShape, \"aColor\", 4, strokeColorBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(cArray), curContext.STREAM_DRAW);\n      curContext.drawArrays(ctxMode, 0, vArray.length/3);\n    };\n\n    /**\n     * @private\n     * Render filled shapes created from calls to beginShape/vertex/endShape - based on the mode specified TRIANGLES, etc.\n     *\n     * @param {Array} vArray an array of vertex coordinate\n     * @param {String} mode  either LINES, LINE_LOOP, or LINE_STRIP\n     * @param {Array} cArray an array of colours used for the vertices\n     * @param {Array} tArray an array of u,v coordinates for textures\n     *\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     */\n    var fill3D = function(vArray, mode, cArray, tArray){\n      var ctxMode;\n      if (mode === \"TRIANGLES\") {\n        ctxMode = curContext.TRIANGLES;\n      } else if(mode === \"TRIANGLE_FAN\") {\n        ctxMode = curContext.TRIANGLE_FAN;\n      } else {\n        ctxMode = curContext.TRIANGLE_STRIP;\n      }\n\n      var view = new PMatrix3D();\n      view.scale( 1, -1, 1 );\n      view.apply( modelView.array() );\n      view.transpose();\n\n      curContext.useProgram( programObject3D );\n      uniformMatrix( \"model3d\", programObject3D, \"uModel\", false,  [1,0,0,0,  0,1,0,0,   0,0,1,0,   0,0,0,1] );\n      uniformMatrix( \"view3d\", programObject3D, \"uView\", false, view.array() );\n      curContext.enable( curContext.POLYGON_OFFSET_FILL );\n      curContext.polygonOffset( 1, 1 );\n      uniformf( \"color3d\", programObject3D, \"uColor\", [-1,0,0,0] );\n      vertexAttribPointer( \"vertex3d\", programObject3D, \"aVertex\", 3, fillBuffer );\n      curContext.bufferData( curContext.ARRAY_BUFFER, new Float32Array(vArray), curContext.STREAM_DRAW );\n\n      // if we are using a texture and a tint, then overwrite the\n      // contents of the color buffer with the current tint\n      if ( usingTexture && curTint !== null ){\n        curTint3d( cArray );\n      }\n\n      vertexAttribPointer( \"aColor3d\", programObject3D, \"aColor\", 4, fillColorBuffer );\n      curContext.bufferData( curContext.ARRAY_BUFFER, new Float32Array(cArray), curContext.STREAM_DRAW );\n\n      // No support for lights....yet\n      disableVertexAttribPointer( \"aNormal3d\", programObject3D, \"aNormal\" );\n\n      if ( usingTexture ) {\n        uniformi( \"uUsingTexture3d\", programObject3D, \"uUsingTexture\", usingTexture );\n        vertexAttribPointer( \"aTexture3d\", programObject3D, \"aTexture\", 2, shapeTexVBO );\n        curContext.bufferData( curContext.ARRAY_BUFFER, new Float32Array(tArray), curContext.STREAM_DRAW );\n      }\n\n      curContext.drawArrays( ctxMode, 0, vArray.length/3 );\n      curContext.disable( curContext.POLYGON_OFFSET_FILL );\n    };\n\n    /**\n     * this series of three operations is used a lot in Drawing2D.prototype.endShape\n     * and has been split off as its own function, to tighten the code and allow for\n     * fewer bugs.\n     */\n    function fillStrokeClose() {\n      executeContextFill();\n      executeContextStroke();\n      curContext.closePath();\n    }\n\n    /**\n     * The endShape() function is the companion to beginShape() and may only be called after beginShape().\n     * When endshape() is called, all of image data defined since the previous call to beginShape() is written\n     * into the image buffer.\n     *\n     * @param {int} MODE Use CLOSE to close the shape\n     *\n     * @see beginShape\n     */\n    Drawing2D.prototype.endShape = function(mode) {\n      // Duplicated in Drawing3D; too many variables used\n      if (vertArray.length === 0) { return; }\n\n      var closeShape = mode === PConstants.CLOSE;\n\n      // if the shape is closed, the first element is also the last element\n      if (closeShape) {\n        vertArray.push(vertArray[0]);\n      }\n\n      var lineVertArray = [];\n      var fillVertArray = [];\n      var colorVertArray = [];\n      var strokeVertArray = [];\n      var texVertArray = [];\n      var cachedVertArray;\n\n      firstVert = true;\n      var i, j, k;\n      var vertArrayLength = vertArray.length;\n\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 0; j < 3; j++) {\n          fillVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // 5,6,7,8\n      // R,G,B,A - fill colour\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 5; j < 9; j++) {\n          colorVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // 9,10,11,12\n      // R, G, B, A - stroke colour\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 9; j < 13; j++) {\n          strokeVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // texture u,v\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        texVertArray.push(cachedVertArray[3]);\n        texVertArray.push(cachedVertArray[4]);\n      }\n\n      // curveVertex\n      if ( isCurve && (curShape === PConstants.POLYGON || curShape === undef) ) {\n        if (vertArrayLength > 3) {\n          var b = [],\n              s = 1 - curTightness;\n          curContext.beginPath();\n          curContext.moveTo(vertArray[1][0], vertArray[1][1]);\n            /*\n            * Matrix to convert from Catmull-Rom to cubic Bezier\n            * where t = curTightness\n            * |0         1          0         0       |\n            * |(t-1)/6   1          (1-t)/6   0       |\n            * |0         (1-t)/6    1         (t-1)/6 |\n            * |0         0          0         0       |\n            */\n          for (i = 1; (i+2) < vertArrayLength; i++) {\n            cachedVertArray = vertArray[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * vertArray[i+1][0] - s * vertArray[i-1][0]) / 6,\n                   cachedVertArray[1] + (s * vertArray[i+1][1] - s * vertArray[i-1][1]) / 6];\n            b[2] = [vertArray[i+1][0] + (s * vertArray[i][0] - s * vertArray[i+2][0]) / 6,\n                   vertArray[i+1][1] + (s * vertArray[i][1] - s * vertArray[i+2][1]) / 6];\n            b[3] = [vertArray[i+1][0], vertArray[i+1][1]];\n            curContext.bezierCurveTo(b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]);\n          }\n          fillStrokeClose();\n        }\n      }\n\n      // bezierVertex\n      else if ( isBezier && (curShape === PConstants.POLYGON || curShape === undef) ) {\n        curContext.beginPath();\n        for (i = 0; i < vertArrayLength; i++) {\n          cachedVertArray = vertArray[i];\n          if (vertArray[i][\"isVert\"]) { //if it is a vertex move to the position\n            if (vertArray[i][\"moveTo\"]) {\n              curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n            } else {\n              curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n            }\n          } else { //otherwise continue drawing bezier\n            curContext.bezierCurveTo(vertArray[i][0], vertArray[i][1], vertArray[i][2], vertArray[i][3], vertArray[i][4], vertArray[i][5]);\n          }\n        }\n        fillStrokeClose();\n      }\n\n      // render the vertices provided\n      else {\n        if (curShape === PConstants.POINTS) {\n          for (i = 0; i < vertArrayLength; i++) {\n            cachedVertArray = vertArray[i];\n            if (doStroke) {\n              p.stroke(cachedVertArray[6]);\n            }\n            p.point(cachedVertArray[0], cachedVertArray[1]);\n          }\n        } else if (curShape === PConstants.LINES) {\n          for (i = 0; (i + 1) < vertArrayLength; i+=2) {\n            cachedVertArray = vertArray[i];\n            if (doStroke) {\n              p.stroke(vertArray[i+1][6]);\n            }\n            p.line(cachedVertArray[0], cachedVertArray[1], vertArray[i+1][0], vertArray[i+1][1]);\n          }\n        } else if (curShape === PConstants.TRIANGLES) {\n          for (i = 0; (i + 2) < vertArrayLength; i+=3) {\n            cachedVertArray = vertArray[i];\n            curContext.beginPath();\n            curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n            curContext.lineTo(vertArray[i+1][0], vertArray[i+1][1]);\n            curContext.lineTo(vertArray[i+2][0], vertArray[i+2][1]);\n            curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n\n            if (doFill) {\n              p.fill(vertArray[i+2][5]);\n              executeContextFill();\n            }\n            if (doStroke) {\n              p.stroke(vertArray[i+2][6]);\n              executeContextStroke();\n            }\n\n            curContext.closePath();\n          }\n        } else if (curShape === PConstants.TRIANGLE_STRIP) {\n          for (i = 0; (i+1) < vertArrayLength; i++) {\n            cachedVertArray = vertArray[i];\n            curContext.beginPath();\n            curContext.moveTo(vertArray[i+1][0], vertArray[i+1][1]);\n            curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n\n            if (doStroke) {\n              p.stroke(vertArray[i+1][6]);\n            }\n            if (doFill) {\n              p.fill(vertArray[i+1][5]);\n            }\n\n            if (i + 2 < vertArrayLength) {\n              curContext.lineTo(vertArray[i+2][0], vertArray[i+2][1]);\n              if (doStroke) {\n                p.stroke(vertArray[i+2][6]);\n              }\n              if (doFill) {\n                p.fill(vertArray[i+2][5]);\n              }\n            }\n            fillStrokeClose();\n          }\n        } else if (curShape === PConstants.TRIANGLE_FAN) {\n          if (vertArrayLength > 2) {\n            curContext.beginPath();\n            curContext.moveTo(vertArray[0][0], vertArray[0][1]);\n            curContext.lineTo(vertArray[1][0], vertArray[1][1]);\n            curContext.lineTo(vertArray[2][0], vertArray[2][1]);\n\n            if (doFill) {\n              p.fill(vertArray[2][5]);\n              executeContextFill();\n            }\n            if (doStroke) {\n              p.stroke(vertArray[2][6]);\n              executeContextStroke();\n            }\n\n            curContext.closePath();\n            for (i = 3; i < vertArrayLength; i++) {\n              cachedVertArray = vertArray[i];\n              curContext.beginPath();\n              curContext.moveTo(vertArray[0][0], vertArray[0][1]);\n              curContext.lineTo(vertArray[i-1][0], vertArray[i-1][1]);\n              curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n\n              if (doFill) {\n                p.fill(cachedVertArray[5]);\n                executeContextFill();\n              }\n              if (doStroke) {\n                p.stroke(cachedVertArray[6]);\n                executeContextStroke();\n              }\n\n              curContext.closePath();\n            }\n          }\n        } else if (curShape === PConstants.QUADS) {\n          for (i = 0; (i + 3) < vertArrayLength; i+=4) {\n            cachedVertArray = vertArray[i];\n            curContext.beginPath();\n            curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n            for (j = 1; j < 4; j++) {\n              curContext.lineTo(vertArray[i+j][0], vertArray[i+j][1]);\n            }\n            curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n\n            if (doFill) {\n              p.fill(vertArray[i+3][5]);\n              executeContextFill();\n            }\n            if (doStroke) {\n              p.stroke(vertArray[i+3][6]);\n              executeContextStroke();\n            }\n\n            curContext.closePath();\n          }\n        } else if (curShape === PConstants.QUAD_STRIP) {\n          if (vertArrayLength > 3) {\n            for (i = 0; (i+1) < vertArrayLength; i+=2) {\n              cachedVertArray = vertArray[i];\n              curContext.beginPath();\n              if (i+3 < vertArrayLength) {\n                curContext.moveTo(vertArray[i+2][0], vertArray[i+2][1]);\n                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n                curContext.lineTo(vertArray[i+1][0], vertArray[i+1][1]);\n                curContext.lineTo(vertArray[i+3][0], vertArray[i+3][1]);\n\n                if (doFill) {\n                  p.fill(vertArray[i+3][5]);\n                }\n                if (doStroke) {\n                  p.stroke(vertArray[i+3][6]);\n                }\n              } else {\n                curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n                curContext.lineTo(vertArray[i+1][0], vertArray[i+1][1]);\n              }\n              fillStrokeClose();\n            }\n          }\n        } else {\n          curContext.beginPath();\n          curContext.moveTo(vertArray[0][0], vertArray[0][1]);\n          for (i = 1; i < vertArrayLength; i++) {\n            cachedVertArray = vertArray[i];\n            if (cachedVertArray[\"isVert\"]) { //if it is a vertex move to the position\n              if (cachedVertArray[\"moveTo\"]) {\n                curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n              } else {\n                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n              }\n            }\n          }\n          fillStrokeClose();\n        }\n      }\n\n      // Reset some settings\n      isCurve = false;\n      isBezier = false;\n      curveVertArray = [];\n      curveVertCount = 0;\n\n      // If the shape is closed, the first element was added as last element.\n      // We must remove it again to prevent the list of vertices from growing\n      // over successive calls to endShape(CLOSE)\n      if (closeShape) {\n        vertArray.pop();\n      }\n    };\n\n    Drawing3D.prototype.endShape = function(mode) {\n      // Duplicated in Drawing3D; too many variables used\n      if (vertArray.length === 0) { return; }\n\n      var closeShape = mode === PConstants.CLOSE;\n      var lineVertArray = [];\n      var fillVertArray = [];\n      var colorVertArray = [];\n      var strokeVertArray = [];\n      var texVertArray = [];\n      var cachedVertArray;\n\n      firstVert = true;\n      var i, j, k;\n      var vertArrayLength = vertArray.length;\n\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 0; j < 3; j++) {\n          fillVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // 5,6,7,8\n      // R,G,B,A - fill colour\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 5; j < 9; j++) {\n          colorVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // 9,10,11,12\n      // R, G, B, A - stroke colour\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 9; j < 13; j++) {\n          strokeVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // texture u,v\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        texVertArray.push(cachedVertArray[3]);\n        texVertArray.push(cachedVertArray[4]);\n      }\n\n      // if shape is closed, push the first point into the last point (including colours)\n      if (closeShape) {\n        fillVertArray.push(vertArray[0][0]);\n        fillVertArray.push(vertArray[0][1]);\n        fillVertArray.push(vertArray[0][2]);\n\n        for (i = 5; i < 9; i++) {\n          colorVertArray.push(vertArray[0][i]);\n        }\n\n        for (i = 9; i < 13; i++) {\n          strokeVertArray.push(vertArray[0][i]);\n        }\n\n        texVertArray.push(vertArray[0][3]);\n        texVertArray.push(vertArray[0][4]);\n      }\n      // End duplication\n\n      // curveVertex\n      if ( isCurve && (curShape === PConstants.POLYGON || curShape === undef) ) {\n        lineVertArray = fillVertArray;\n        if (doStroke) {\n          line3D(lineVertArray, null, strokeVertArray);\n        }\n        if (doFill) {\n          fill3D(fillVertArray, null, colorVertArray);\n        }\n      }\n      // bezierVertex\n      else if ( isBezier && (curShape === PConstants.POLYGON || curShape === undef) ) {\n        lineVertArray = fillVertArray;\n        lineVertArray.splice(lineVertArray.length - 3);\n        strokeVertArray.splice(strokeVertArray.length - 4);\n        if (doStroke) {\n          line3D(lineVertArray, null, strokeVertArray);\n        }\n        if (doFill) {\n          fill3D(fillVertArray, \"TRIANGLES\", colorVertArray);\n        }\n      }\n\n      // render the vertices provided\n      else {\n        if (curShape === PConstants.POINTS) {       // if POINTS was the specified parameter in beginShape\n          for (i = 0; i < vertArrayLength; i++) {  // loop through and push the point location information to the array\n            cachedVertArray = vertArray[i];\n            for (j = 0; j < 3; j++) {\n              lineVertArray.push(cachedVertArray[j]);\n            }\n          }\n          point3D(lineVertArray, strokeVertArray);  // render function for points\n        } else if (curShape === PConstants.LINES) { // if LINES was the specified parameter in beginShape\n          for (i = 0; i < vertArrayLength; i++) {  // loop through and push the point location information to the array\n            cachedVertArray = vertArray[i];\n            for (j = 0; j < 3; j++) {\n              lineVertArray.push(cachedVertArray[j]);\n            }\n          }\n          for (i = 0; i < vertArrayLength; i++) {  // loop through and push the color information to the array\n            cachedVertArray = vertArray[i];\n            for (j = 5; j < 9; j++) {\n              colorVertArray.push(cachedVertArray[j]);\n            }\n          }\n          line3D(lineVertArray, \"LINES\", strokeVertArray);  // render function for lines\n        } else if (curShape === PConstants.TRIANGLES) {     // if TRIANGLES was the specified parameter in beginShape\n          if (vertArrayLength > 2) {\n            for (i = 0; (i+2) < vertArrayLength; i+=3) {   // loop through the array per triangle\n              fillVertArray = [];\n              texVertArray = [];\n              lineVertArray = [];\n              colorVertArray = [];\n              strokeVertArray = [];\n              for (j = 0; j < 3; j++) {\n                for (k = 0; k < 3; k++) {                   // loop through and push\n                  lineVertArray.push(vertArray[i+j][k]);    // the line point location information\n                  fillVertArray.push(vertArray[i+j][k]);    // and fill point location information\n                }\n              }\n              for (j = 0; j < 3; j++) {                     // loop through and push the texture information\n                for (k = 3; k < 5; k++) {\n                  texVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              for (j = 0; j < 3; j++) {\n                for (k = 5; k < 9; k++) {                   // loop through and push\n                  colorVertArray.push(vertArray[i+j][k]);   // the colour information\n                  strokeVertArray.push(vertArray[i+j][k+4]);// and the stroke information\n                }\n              }\n              if (doStroke) {\n                line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray );               // line render function\n              }\n              if (doFill || usingTexture) {\n                fill3D(fillVertArray, \"TRIANGLES\", colorVertArray, texVertArray);   // fill shape render function\n              }\n            }\n          }\n        } else if (curShape === PConstants.TRIANGLE_STRIP) {    // if TRIANGLE_STRIP was the specified parameter in beginShape\n          if (vertArrayLength > 2) {\n            for (i = 0; (i+2) < vertArrayLength; i++) {\n              lineVertArray = [];\n              fillVertArray = [];\n              strokeVertArray = [];\n              colorVertArray = [];\n              texVertArray = [];\n              for (j = 0; j < 3; j++) {\n                for (k = 0; k < 3; k++) {\n                  lineVertArray.push(vertArray[i+j][k]);\n                  fillVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              for (j = 0; j < 3; j++) {\n                for (k = 3; k < 5; k++) {\n                  texVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              for (j = 0; j < 3; j++) {\n                for (k = 5; k < 9; k++) {\n                  strokeVertArray.push(vertArray[i+j][k+4]);\n                  colorVertArray.push(vertArray[i+j][k]);\n                }\n              }\n\n              if (doFill || usingTexture) {\n                fill3D(fillVertArray, \"TRIANGLE_STRIP\", colorVertArray, texVertArray);\n              }\n              if (doStroke) {\n                line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n              }\n            }\n          }\n        } else if (curShape === PConstants.TRIANGLE_FAN) {\n          if (vertArrayLength > 2) {\n            for (i = 0; i < 3; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(cachedVertArray[j]);\n              }\n            }\n            for (i = 0; i < 3; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(cachedVertArray[j]);\n              }\n            }\n            if (doStroke) {\n              line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n            }\n\n            for (i = 2; (i+1) < vertArrayLength; i++) {\n              lineVertArray = [];\n              strokeVertArray = [];\n              lineVertArray.push(vertArray[0][0]);\n              lineVertArray.push(vertArray[0][1]);\n              lineVertArray.push(vertArray[0][2]);\n\n              strokeVertArray.push(vertArray[0][9]);\n              strokeVertArray.push(vertArray[0][10]);\n              strokeVertArray.push(vertArray[0][11]);\n              strokeVertArray.push(vertArray[0][12]);\n\n              for (j = 0; j < 2; j++) {\n                for (k = 0; k < 3; k++) {\n                  lineVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              for (j = 0; j < 2; j++) {\n                for (k = 9; k < 13; k++) {\n                  strokeVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              if (doStroke) {\n                line3D(lineVertArray, \"LINE_STRIP\",strokeVertArray);\n              }\n            }\n            if (doFill || usingTexture) {\n              fill3D(fillVertArray, \"TRIANGLE_FAN\", colorVertArray, texVertArray);\n            }\n          }\n        } else if (curShape === PConstants.QUADS) {\n          for (i = 0; (i + 3) < vertArrayLength; i+=4) {\n            lineVertArray = [];\n            for (j = 0; j < 4; j++) {\n              cachedVertArray = vertArray[i+j];\n              for (k = 0; k < 3; k++) {\n                lineVertArray.push(cachedVertArray[k]);\n              }\n            }\n            if (doStroke) {\n              line3D(lineVertArray, \"LINE_LOOP\",strokeVertArray);\n            }\n\n            if (doFill) {\n              fillVertArray = [];\n              colorVertArray = [];\n              texVertArray = [];\n              for (j = 0; j < 3; j++) {\n                fillVertArray.push(vertArray[i][j]);\n              }\n              for (j = 5; j < 9; j++) {\n                colorVertArray.push(vertArray[i][j]);\n              }\n\n              for (j = 0; j < 3; j++) {\n                fillVertArray.push(vertArray[i+1][j]);\n              }\n              for (j = 5; j < 9; j++) {\n                colorVertArray.push(vertArray[i+1][j]);\n              }\n\n              for (j = 0; j < 3; j++) {\n                fillVertArray.push(vertArray[i+3][j]);\n              }\n              for (j = 5; j < 9; j++) {\n                colorVertArray.push(vertArray[i+3][j]);\n              }\n\n              for (j = 0; j < 3; j++) {\n                fillVertArray.push(vertArray[i+2][j]);\n              }\n              for (j = 5; j < 9; j++) {\n                colorVertArray.push(vertArray[i+2][j]);\n              }\n\n              if (usingTexture) {\n                texVertArray.push(vertArray[i+0][3]);\n                texVertArray.push(vertArray[i+0][4]);\n                texVertArray.push(vertArray[i+1][3]);\n                texVertArray.push(vertArray[i+1][4]);\n                texVertArray.push(vertArray[i+3][3]);\n                texVertArray.push(vertArray[i+3][4]);\n                texVertArray.push(vertArray[i+2][3]);\n                texVertArray.push(vertArray[i+2][4]);\n              }\n\n              fill3D(fillVertArray, \"TRIANGLE_STRIP\", colorVertArray, texVertArray);\n            }\n          }\n        } else if (curShape === PConstants.QUAD_STRIP) {\n          var tempArray = [];\n          if (vertArrayLength > 3) {\n            for (i = 0; i < 2; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(cachedVertArray[j]);\n              }\n            }\n\n            for (i = 0; i < 2; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(cachedVertArray[j]);\n              }\n            }\n\n            line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n            if (vertArrayLength > 4 && vertArrayLength % 2 > 0) {\n              tempArray = fillVertArray.splice(fillVertArray.length - 3);\n              vertArray.pop();\n            }\n            for (i = 0; (i+3) < vertArrayLength; i+=2) {\n              lineVertArray = [];\n              strokeVertArray = [];\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(vertArray[i+1][j]);\n              }\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(vertArray[i+3][j]);\n              }\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(vertArray[i+2][j]);\n              }\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(vertArray[i+0][j]);\n              }\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(vertArray[i+1][j]);\n              }\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(vertArray[i+3][j]);\n              }\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(vertArray[i+2][j]);\n              }\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(vertArray[i+0][j]);\n              }\n              if (doStroke) {\n                line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n              }\n            }\n\n            if (doFill || usingTexture) {\n              fill3D(fillVertArray, \"TRIANGLE_LIST\", colorVertArray, texVertArray);\n            }\n          }\n        }\n        // If the user didn't specify a type (LINES, TRIANGLES, etc)\n        else {\n          // If only one vertex was specified, it must be a point\n          if (vertArrayLength === 1) {\n            for (j = 0; j < 3; j++) {\n              lineVertArray.push(vertArray[0][j]);\n            }\n            for (j = 9; j < 13; j++) {\n              strokeVertArray.push(vertArray[0][j]);\n            }\n            point3D(lineVertArray,strokeVertArray);\n          } else {\n            for (i = 0; i < vertArrayLength; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(cachedVertArray[j]);\n              }\n              for (j = 5; j < 9; j++) {\n                strokeVertArray.push(cachedVertArray[j]);\n              }\n            }\n            if (doStroke && closeShape) {\n              line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n            } else if (doStroke && !closeShape) {\n              line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n            }\n\n            // fill is ignored if textures are used\n            if (doFill || usingTexture) {\n              fill3D(fillVertArray, \"TRIANGLE_FAN\", colorVertArray, texVertArray);\n            }\n          }\n        }\n        // everytime beginShape is followed by a call to\n        // texture(), texturing it turned back on. We do this to\n        // figure out if the shape should be textured or filled\n        // with a color.\n        usingTexture = false;\n        curContext.useProgram(programObject3D);\n        uniformi(\"usingTexture3d\", programObject3D, \"uUsingTexture\", usingTexture);\n      }\n\n      // Reset some settings\n      isCurve = false;\n      isBezier = false;\n      curveVertArray = [];\n      curveVertCount = 0;\n    };\n\n    /**\n     * The function splineForward() setup forward-differencing matrix to be used for speedy\n     * curve rendering. It's based on using a specific number\n     * of curve segments and just doing incremental adds for each\n     * vertex of the segment, rather than running the mathematically\n     * expensive cubic equation. This function is used by both curveDetail and bezierDetail.\n     *\n     * @param {int} segments      number of curve segments to use when drawing\n     * @param {PMatrix3D} matrix  target object for the new matrix\n     */\n    var splineForward = function(segments, matrix) {\n      var f = 1.0 / segments;\n      var ff = f * f;\n      var fff = ff * f;\n\n      matrix.set(0, 0, 0, 1, fff, ff, f, 0, 6 * fff, 2 * ff, 0, 0, 6 * fff, 0, 0, 0);\n    };\n\n    /**\n     * The curveInit() function set the number of segments to use when drawing a Catmull-Rom\n     * curve, and setting the s parameter, which defines how tightly\n     * the curve fits to each vertex. Catmull-Rom curves are actually\n     * a subset of this curve type where the s is set to zero.\n     * This in an internal function used by curveDetail() and curveTightness().\n     */\n    var curveInit = function() {\n      // allocate only if/when used to save startup time\n      if (!curveDrawMatrix) {\n        curveBasisMatrix = new PMatrix3D();\n        curveDrawMatrix = new PMatrix3D();\n        curveInited = true;\n      }\n\n      var s = curTightness;\n      curveBasisMatrix.set((s - 1) / 2, (s + 3) / 2, (-3 - s) / 2, (1 - s) / 2,\n                           (1 - s), (-5 - s) / 2, (s + 2), (s - 1) / 2,\n                           (s - 1) / 2, 0, (1 - s) / 2, 0, 0, 1, 0, 0);\n\n      splineForward(curveDet, curveDrawMatrix);\n\n      if (!bezierBasisInverse) {\n        //bezierBasisInverse = bezierBasisMatrix.get();\n        //bezierBasisInverse.invert();\n        curveToBezierMatrix = new PMatrix3D();\n      }\n\n      // TODO only needed for PGraphicsJava2D? if so, move it there\n      // actually, it's generally useful for other renderers, so keep it\n      // or hide the implementation elsewhere.\n      curveToBezierMatrix.set(curveBasisMatrix);\n      curveToBezierMatrix.preApply(bezierBasisInverse);\n\n      // multiply the basis and forward diff matrices together\n      // saves much time since this needn't be done for each curve\n      curveDrawMatrix.apply(curveBasisMatrix);\n    };\n\n    /**\n     * Specifies vertex coordinates for Bezier curves. Each call to <b>bezierVertex()</b> defines the position of two control\n     * points and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time\n     * <b>bezierVertex()</b> is used within a <b>beginShape()</b> call, it must be prefaced with a call to <b>vertex()</b>\n     * to set the first anchor point. This function must be used between <b>beginShape()</b> and <b>endShape()</b> and only\n     * when there is no MODE parameter specified to <b>beginShape()</b>. Using the 3D version of requires rendering with P3D\n     * or OPENGL (see the Environment reference for more information). <br /> <br /> <b>NOTE: </b> Fill does not work properly yet.\n     *\n     * @param {float | int} cx1 The x-coordinate of 1st control point\n     * @param {float | int} cy1 The y-coordinate of 1st control point\n     * @param {float | int} cz1 The z-coordinate of 1st control point\n     * @param {float | int} cx2 The x-coordinate of 2nd control point\n     * @param {float | int} cy2 The y-coordinate of 2nd control point\n     * @param {float | int} cz2 The z-coordinate of 2nd control point\n     * @param {float | int} x   The x-coordinate of the anchor point\n     * @param {float | int} y   The y-coordinate of the anchor point\n     * @param {float | int} z   The z-coordinate of the anchor point\n     *\n     * @see curveVertex\n     * @see vertex\n     * @see bezier\n     */\n    Drawing2D.prototype.bezierVertex = function() {\n      isBezier = true;\n      var vert = [];\n      if (firstVert) {\n        throw (\"vertex() must be used at least once before calling bezierVertex()\");\n      }\n\n      for (var i = 0; i < arguments.length; i++) {\n        vert[i] = arguments[i];\n      }\n      vertArray.push(vert);\n      vertArray[vertArray.length -1][\"isVert\"] = false;\n    };\n\n    Drawing3D.prototype.bezierVertex = function() {\n      isBezier = true;\n      var vert = [];\n      if (firstVert) {\n        throw (\"vertex() must be used at least once before calling bezierVertex()\");\n      }\n\n      if (arguments.length === 9) {\n        if (bezierDrawMatrix === undef) {\n          bezierDrawMatrix = new PMatrix3D();\n        }\n        // setup matrix for forward differencing to speed up drawing\n        var lastPoint = vertArray.length - 1;\n        splineForward( bezDetail, bezierDrawMatrix );\n        bezierDrawMatrix.apply( bezierBasisMatrix );\n        var draw = bezierDrawMatrix.array();\n        var x1 = vertArray[lastPoint][0],\n            y1 = vertArray[lastPoint][1],\n            z1 = vertArray[lastPoint][2];\n        var xplot1 = draw[4] * x1 + draw[5] * arguments[0] + draw[6] * arguments[3] + draw[7] * arguments[6];\n        var xplot2 = draw[8] * x1 + draw[9] * arguments[0] + draw[10]* arguments[3] + draw[11]* arguments[6];\n        var xplot3 = draw[12]* x1 + draw[13]* arguments[0] + draw[14]* arguments[3] + draw[15]* arguments[6];\n\n        var yplot1 = draw[4] * y1 + draw[5] * arguments[1] + draw[6] * arguments[4] + draw[7] * arguments[7];\n        var yplot2 = draw[8] * y1 + draw[9] * arguments[1] + draw[10]* arguments[4] + draw[11]* arguments[7];\n        var yplot3 = draw[12]* y1 + draw[13]* arguments[1] + draw[14]* arguments[4] + draw[15]* arguments[7];\n\n        var zplot1 = draw[4] * z1 + draw[5] * arguments[2] + draw[6] * arguments[5] + draw[7] * arguments[8];\n        var zplot2 = draw[8] * z1 + draw[9] * arguments[2] + draw[10]* arguments[5] + draw[11]* arguments[8];\n        var zplot3 = draw[12]* z1 + draw[13]* arguments[2] + draw[14]* arguments[5] + draw[15]* arguments[8];\n        for (var j = 0; j < bezDetail; j++) {\n          x1 += xplot1; xplot1 += xplot2; xplot2 += xplot3;\n          y1 += yplot1; yplot1 += yplot2; yplot2 += yplot3;\n          z1 += zplot1; zplot1 += zplot2; zplot2 += zplot3;\n          p.vertex(x1, y1, z1);\n        }\n        p.vertex(arguments[6], arguments[7], arguments[8]);\n      }\n    };\n\n    /**\n     * Sets a texture to be applied to vertex points. The <b>texture()</b> function\n     * must be called between <b>beginShape()</b> and <b>endShape()</b> and before\n     * any calls to vertex().\n     *\n     * When textures are in use, the fill color is ignored. Instead, use tint() to\n     * specify the color of the texture as it is applied to the shape.\n     *\n     * @param {PImage} pimage the texture to apply\n     *\n     * @returns none\n     *\n     * @see textureMode\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n    */\n    p.texture = function(pimage) {\n      var curContext = drawing.$ensureContext();\n\n      if (pimage.__texture) {\n        curContext.bindTexture(curContext.TEXTURE_2D, pimage.__texture);\n      } else if (pimage.localName === \"canvas\") {\n        curContext.bindTexture(curContext.TEXTURE_2D, canTex);\n        curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, pimage);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR);\n        curContext.generateMipmap(curContext.TEXTURE_2D);\n        curTexture.width = pimage.width;\n        curTexture.height = pimage.height;\n      } else {\n        var texture = curContext.createTexture(),\n            cvs = document.createElement('canvas'),\n            cvsTextureCtx = cvs.getContext('2d'),\n            pot;\n\n        // WebGL requires power of two textures\n        if (pimage.width & (pimage.width-1) === 0) {\n          cvs.width = pimage.width;\n        } else {\n          pot = 1;\n          while (pot < pimage.width) {\n            pot *= 2;\n          }\n          cvs.width = pot;\n        }\n\n        if (pimage.height & (pimage.height-1) === 0) {\n          cvs.height = pimage.height;\n        } else {\n          pot = 1;\n          while (pot < pimage.height) {\n            pot *= 2;\n          }\n          cvs.height = pot;\n        }\n\n        cvsTextureCtx.drawImage(pimage.sourceImg, 0, 0, pimage.width, pimage.height, 0, 0, cvs.width, cvs.height);\n\n        curContext.bindTexture(curContext.TEXTURE_2D, texture);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR_MIPMAP_LINEAR);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_T, curContext.CLAMP_TO_EDGE);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_S, curContext.CLAMP_TO_EDGE);\n        curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, cvs);\n        curContext.generateMipmap(curContext.TEXTURE_2D);\n\n        pimage.__texture = texture;\n        curTexture.width = pimage.width;\n        curTexture.height = pimage.height;\n      }\n\n      usingTexture = true;\n      curContext.useProgram(programObject3D);\n      uniformi(\"usingTexture3d\", programObject3D, \"uUsingTexture\", usingTexture);\n    };\n\n    /**\n     * Sets the coordinate space for texture mapping. There are two options, IMAGE,\n     * which refers to the actual coordinates of the image, and NORMALIZED, which\n     * refers to a normalized space of values ranging from 0 to 1. The default mode\n     * is IMAGE. In IMAGE, if an image is 100 x 200 pixels, mapping the image onto\n     * the entire size of a quad would require the points (0,0) (0,100) (100,200) (0,200).\n     * The same mapping in NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).\n     *\n     * @param MODE either IMAGE or NORMALIZED\n     *\n     * @returns none\n     *\n     * @see texture\n    */\n    p.textureMode = function(mode){\n      curTextureMode = mode;\n    };\n    /**\n     * The curveVertexSegment() function handle emitting a specific segment of Catmull-Rom curve. Internal helper function used by <b>curveVertex()</b>.\n     */\n    var curveVertexSegment = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {\n      var x0 = x2;\n      var y0 = y2;\n      var z0 = z2;\n\n      var draw = curveDrawMatrix.array();\n\n      var xplot1 = draw[4] * x1 + draw[5] * x2 + draw[6] * x3 + draw[7] * x4;\n      var xplot2 = draw[8] * x1 + draw[9] * x2 + draw[10] * x3 + draw[11] * x4;\n      var xplot3 = draw[12] * x1 + draw[13] * x2 + draw[14] * x3 + draw[15] * x4;\n\n      var yplot1 = draw[4] * y1 + draw[5] * y2 + draw[6] * y3 + draw[7] * y4;\n      var yplot2 = draw[8] * y1 + draw[9] * y2 + draw[10] * y3 + draw[11] * y4;\n      var yplot3 = draw[12] * y1 + draw[13] * y2 + draw[14] * y3 + draw[15] * y4;\n\n      var zplot1 = draw[4] * z1 + draw[5] * z2 + draw[6] * z3 + draw[7] * z4;\n      var zplot2 = draw[8] * z1 + draw[9] * z2 + draw[10] * z3 + draw[11] * z4;\n      var zplot3 = draw[12] * z1 + draw[13] * z2 + draw[14] * z3 + draw[15] * z4;\n\n      p.vertex(x0, y0, z0);\n      for (var j = 0; j < curveDet; j++) {\n        x0 += xplot1; xplot1 += xplot2; xplot2 += xplot3;\n        y0 += yplot1; yplot1 += yplot2; yplot2 += yplot3;\n        z0 += zplot1; zplot1 += zplot2; zplot2 += zplot3;\n        p.vertex(x0, y0, z0);\n      }\n    };\n\n    /**\n     * Specifies vertex coordinates for curves. This function may only be used between <b>beginShape()</b> and\n     * <b>endShape()</b> and only when there is no MODE parameter specified to <b>beginShape()</b>. The first and last points\n     * in a series of <b>curveVertex()</b> lines will be used to guide the beginning and end of a the curve. A minimum of four\n     * points is required to draw a tiny curve between the second and third points. Adding a fifth point with\n     * <b>curveVertex()</b> will draw the curve between the second, third, and fourth points. The <b>curveVertex()</b> function\n     * is an implementation of Catmull-Rom splines. Using the 3D version of requires rendering with P3D or OPENGL (see the\n     * Environment reference for more information). <br /> <br /><b>NOTE: </b> Fill does not work properly yet.\n     *\n     * @param {float | int} x The x-coordinate of the vertex\n     * @param {float | int} y The y-coordinate of the vertex\n     * @param {float | int} z The z-coordinate of the vertex\n     *\n     * @see curve\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     * @see bezierVertex\n     */\n    Drawing2D.prototype.curveVertex = function(x, y) {\n      isCurve = true;\n\n      p.vertex(x, y);\n    };\n\n    Drawing3D.prototype.curveVertex = function(x, y, z) {\n      isCurve = true;\n\n      if (!curveInited) {\n        curveInit();\n      }\n      var vert = [];\n      vert[0] = x;\n      vert[1] = y;\n      vert[2] = z;\n      curveVertArray.push(vert);\n      curveVertCount++;\n\n      if (curveVertCount > 3) {\n        curveVertexSegment( curveVertArray[curveVertCount-4][0],\n                            curveVertArray[curveVertCount-4][1],\n                            curveVertArray[curveVertCount-4][2],\n                            curveVertArray[curveVertCount-3][0],\n                            curveVertArray[curveVertCount-3][1],\n                            curveVertArray[curveVertCount-3][2],\n                            curveVertArray[curveVertCount-2][0],\n                            curveVertArray[curveVertCount-2][1],\n                            curveVertArray[curveVertCount-2][2],\n                            curveVertArray[curveVertCount-1][0],\n                            curveVertArray[curveVertCount-1][1],\n                            curveVertArray[curveVertCount-1][2] );\n      }\n    };\n\n    /**\n     * The curve() function draws a curved line on the screen. The first and second parameters\n     * specify the beginning control point and the last two parameters specify\n     * the ending control point. The middle parameters specify the start and\n     * stop of the curve. Longer curves can be created by putting a series of\n     * <b>curve()</b> functions together or using <b>curveVertex()</b>.\n     * An additional function called <b>curveTightness()</b> provides control\n     * for the visual quality of the curve. The <b>curve()</b> function is an\n     * implementation of Catmull-Rom splines. Using the 3D version of requires\n     * rendering with P3D or OPENGL (see the Environment reference for more\n     * information).\n     *\n     * @param {int|float} x1 coordinates for the beginning control point\n     * @param {int|float} y1 coordinates for the beginning control point\n     * @param {int|float} z1 coordinates for the beginning control point\n     * @param {int|float} x2 coordinates for the first point\n     * @param {int|float} y2 coordinates for the first point\n     * @param {int|float} z2 coordinates for the first point\n     * @param {int|float} x3 coordinates for the second point\n     * @param {int|float} y3 coordinates for the second point\n     * @param {int|float} z3 coordinates for the second point\n     * @param {int|float} x4 coordinates for the ending control point\n     * @param {int|float} y4 coordinates for the ending control point\n     * @param {int|float} z4 coordinates for the ending control point\n     *\n     * @see #curveVertex()\n     * @see #curveTightness()\n     * @see #bezier()\n     */\n    Drawing2D.prototype.curve = function(x1, y1, x2, y2, x3, y3, x4, y4) {\n      p.beginShape();\n      p.curveVertex(x1, y1);\n      p.curveVertex(x2, y2);\n      p.curveVertex(x3, y3);\n      p.curveVertex(x4, y4);\n      p.endShape();\n    };\n\n    Drawing3D.prototype.curve = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {\n      if (z4 !== undef) {\n        p.beginShape();\n        p.curveVertex(x1, y1, z1);\n        p.curveVertex(x2, y2, z2);\n        p.curveVertex(x3, y3, z3);\n        p.curveVertex(x4, y4, z4);\n        p.endShape();\n        return;\n      }\n      p.beginShape();\n      p.curveVertex(x1, y1);\n      p.curveVertex(z1, x2);\n      p.curveVertex(y2, z2);\n      p.curveVertex(x3, y3);\n      p.endShape();\n    };\n\n    /**\n     * The curveTightness() function modifies the quality of forms created with <b>curve()</b> and\n     * <b>curveVertex()</b>. The parameter <b>squishy</b> determines how the\n     * curve fits to the vertex points. The value 0.0 is the default value for\n     * <b>squishy</b> (this value defines the curves to be Catmull-Rom splines)\n     * and the value 1.0 connects all the points with straight lines.\n     * Values within the range -5.0 and 5.0 will deform the curves but\n     * will leave them recognizable and as values increase in magnitude,\n     * they will continue to deform.\n     *\n     * @param {float} tightness amount of deformation from the original vertices\n     *\n     * @see #curve()\n     * @see #curveVertex()\n     *\n     */\n    p.curveTightness = function(tightness) {\n      curTightness = tightness;\n    };\n\n    /**\n     * The curveDetail() function sets the resolution at which curves display. The default value is 20.\n     * This function is only useful when using the P3D or OPENGL renderer.\n     *\n     * @param {int} detail resolution of the curves\n     *\n     * @see curve()\n     * @see curveVertex()\n     * @see curveTightness()\n     */\n    p.curveDetail = function(detail) {\n      curveDet = detail;\n      curveInit();\n    };\n\n    /**\n    * Modifies the location from which rectangles draw. The default mode is rectMode(CORNER), which\n    * specifies the location to be the upper left corner of the shape and uses the third and fourth\n    * parameters of rect() to specify the width and height. The syntax rectMode(CORNERS) uses the\n    * first and second parameters of rect() to set the location of one corner and uses the third and\n    * fourth parameters to set the opposite corner. The syntax rectMode(CENTER) draws the image from\n    * its center point and uses the third and forth parameters of rect() to specify the image's width\n    * and height. The syntax rectMode(RADIUS) draws the image from its center point and uses the third\n    * and forth parameters of rect()  to specify half of the image's width and height. The parameter must\n    * be written in ALL CAPS because Processing is a case sensitive language. Note: In version 125, the\n    * mode named CENTER_RADIUS was shortened to RADIUS.\n    *\n    * @param {MODE} MODE      Either CORNER, CORNERS, CENTER, or RADIUS\n    *\n    * @see rect\n    */\n    p.rectMode = function(aRectMode) {\n      curRectMode = aRectMode;\n    };\n\n    /**\n    * Modifies the location from which images draw. The default mode is imageMode(CORNER), which specifies\n    * the location to be the upper left corner and uses the fourth and fifth parameters of image() to set\n    * the image's width and height. The syntax imageMode(CORNERS) uses the second and third parameters of\n    * image() to set the location of one corner of the image and uses the fourth and fifth parameters to\n    * set the opposite corner. Use imageMode(CENTER) to draw images centered at the given x and y position.\n    * The parameter to imageMode() must be written in ALL CAPS because Processing is a case sensitive language.\n    *\n    * @param {MODE} MODE      Either CORNER, CORNERS, or CENTER\n    *\n    * @see loadImage\n    * @see PImage\n    * @see image\n    * @see background\n    */\n    p.imageMode = function(mode) {\n      switch (mode) {\n      case PConstants.CORNER:\n        imageModeConvert = imageModeCorner;\n        break;\n      case PConstants.CORNERS:\n        imageModeConvert = imageModeCorners;\n        break;\n      case PConstants.CENTER:\n        imageModeConvert = imageModeCenter;\n        break;\n      default:\n        throw \"Invalid imageMode\";\n      }\n    };\n\n    /**\n    * The origin of the ellipse is modified by the ellipseMode() function. The default configuration is\n    * ellipseMode(CENTER), which specifies the location of the ellipse as the center of the shape. The RADIUS\n    * mode is the same, but the width and height parameters to ellipse()  specify the radius of the ellipse,\n    * rather than the diameter. The CORNER mode draws the shape from the upper-left corner of its bounding box.\n    * The CORNERS mode uses the four parameters to ellipse() to set two opposing corners of the ellipse's bounding\n    * box. The parameter must be written in \"ALL CAPS\" because Processing is a case sensitive language.\n    *\n    * @param {MODE} MODE      Either CENTER, RADIUS, CORNER, or CORNERS.\n    *\n    * @see ellipse\n    */\n    p.ellipseMode = function(aEllipseMode) {\n      curEllipseMode = aEllipseMode;\n    };\n\n    /**\n     * The arc() function draws an arc in the display window.\n     * Arcs are drawn along the outer edge of an ellipse defined by the\n     * <b>x</b>, <b>y</b>, <b>width</b> and <b>height</b> parameters.\n     * The origin or the arc's ellipse may be changed with the\n     * <b>ellipseMode()</b> function.\n     * The <b>start</b> and <b>stop</b> parameters specify the angles\n     * at which to draw the arc.\n     *\n     * @param {float} a       x-coordinate of the arc's ellipse\n     * @param {float} b       y-coordinate of the arc's ellipse\n     * @param {float} c       width of the arc's ellipse\n     * @param {float} d       height of the arc's ellipse\n     * @param {float} start   angle to start the arc, specified in radians\n     * @param {float} stop    angle to stop the arc, specified in radians\n     *\n     * @see #ellipseMode()\n     * @see #ellipse()\n     */\n    p.arc = function(x, y, width, height, start, stop) {\n      if (width <= 0 || stop < start) { return; }\n\n      if (curEllipseMode === PConstants.CORNERS) {\n        width = width - x;\n        height = height - y;\n      } else if (curEllipseMode === PConstants.RADIUS) {\n        x = x - width;\n        y = y - height;\n        width = width * 2;\n        height = height * 2;\n      } else if (curEllipseMode === PConstants.CENTER) {\n        x = x - width/2;\n        y = y - height/2;\n      }\n      // make sure that we're starting at a useful point\n      while (start < 0) {\n        start += PConstants.TWO_PI;\n        stop += PConstants.TWO_PI;\n      }\n      if (stop - start > PConstants.TWO_PI) {\n        start = 0;\n        stop = PConstants.TWO_PI;\n      }\n      var hr = width / 2,\n          vr = height / 2,\n          centerX = x + hr,\n          centerY = y + vr,\n          startLUT = 0 | (0.5 + start * p.RAD_TO_DEG * 2),\n          stopLUT  = 0 | (0.5 + stop * p.RAD_TO_DEG * 2),\n          i, j;\n      if (doFill) {\n        // shut off stroke for a minute\n        var savedStroke = doStroke;\n        doStroke = false;\n        p.beginShape();\n        p.vertex(centerX, centerY);\n        for (i = startLUT; i <= stopLUT; i++) {\n          j = i % PConstants.SINCOS_LENGTH;\n          p.vertex(centerX + cosLUT[j] * hr, centerY + sinLUT[j] * vr);\n        }\n        p.endShape(PConstants.CLOSE);\n        doStroke = savedStroke;\n      }\n\n      if (doStroke) {\n        // and doesn't include the first (center) vertex.\n        var savedFill = doFill;\n        doFill = false;\n        p.beginShape();\n        for (i = startLUT; i <= stopLUT; i++) {\n          j = i % PConstants.SINCOS_LENGTH;\n          p.vertex(centerX + cosLUT[j] * hr, centerY + sinLUT[j] * vr);\n        }\n        p.endShape();\n        doFill = savedFill;\n      }\n    };\n\n    /**\n    * Draws a line (a direct path between two points) to the screen. The version of line() with four parameters\n    * draws the line in 2D. To color a line, use the stroke() function. A line cannot be filled, therefore the\n    * fill()  method will not affect the color of a line. 2D lines are drawn with a width of one pixel by default,\n    * but this can be changed with the strokeWeight()  function. The version with six parameters allows the line\n    * to be placed anywhere within XYZ space. Drawing this shape in 3D using the z parameter requires the P3D or\n    * OPENGL parameter in combination with size.\n    *\n    * @param {int|float} x1       x-coordinate of the first point\n    * @param {int|float} y1       y-coordinate of the first point\n    * @param {int|float} z1       z-coordinate of the first point\n    * @param {int|float} x2       x-coordinate of the second point\n    * @param {int|float} y2       y-coordinate of the second point\n    * @param {int|float} z2       z-coordinate of the second point\n    *\n    * @see strokeWeight\n    * @see strokeJoin\n    * @see strokeCap\n    * @see beginShape\n    */\n    Drawing2D.prototype.line = function(x1, y1, x2, y2) {\n      if (!doStroke) {\n        return;\n      }\n      x1 = Math.round(x1);\n      x2 = Math.round(x2);\n      y1 = Math.round(y1);\n      y2 = Math.round(y2);\n      // A line is only defined if it has different start and end coordinates.\n      // If they are the same, we call point instead.\n      if (x1 === x2 && y1 === y2) {\n        p.point(x1, y1);\n        return;\n      }\n\n      var swap = undef,\n          lineCap = undef,\n          drawCrisp = true,\n          currentModelView = modelView.array(),\n          identityMatrix = [1, 0, 0, 0, 1, 0];\n      // Test if any transformations have been applied to the sketch\n      for (var i = 0; i < 6 && drawCrisp; i++) {\n        drawCrisp = currentModelView[i] === identityMatrix[i];\n      }\n      /* Draw crisp lines if the line is vertical or horizontal with the following method\n       * If any transformations have been applied to the sketch, don't make the line crisp\n       * If the line is directed up or to the left, reverse it by swapping x1/x2 or y1/y2\n       * Make the line 1 pixel longer to work around cross-platform canvas implementations\n       * If the lineWidth is odd, translate the line by 0.5 in the perpendicular direction\n       * Even lineWidths do not need to be translated because the canvas will draw them on pixel boundaries\n       * Change the cap to butt-end to work around cross-platform canvas implementations\n       * Reverse the translate and lineCap canvas state changes after drawing the line\n       */\n      if (drawCrisp) {\n        if (x1 === x2) {\n          if (y1 > y2) {\n            swap = y1;\n            y1 = y2;\n            y2 = swap;\n          }\n          y2++;\n          if (lineWidth % 2 === 1) {\n            curContext.translate(0.5, 0.0);\n          }\n        } else if (y1 === y2) {\n          if (x1 > x2) {\n            swap = x1;\n            x1 = x2;\n            x2 = swap;\n          }\n          x2++;\n          if (lineWidth % 2 === 1) {\n            curContext.translate(0.0, 0.5);\n          }\n        }\n        if (lineWidth === 1) {\n          lineCap = curContext.lineCap;\n          curContext.lineCap = 'butt';\n        }\n      }\n      curContext.beginPath();\n      curContext.moveTo(x1 || 0, y1 || 0);\n      curContext.lineTo(x2 || 0, y2 || 0);\n      executeContextStroke();\n      if (drawCrisp) {\n        if (x1 === x2 && lineWidth % 2 === 1) {\n          curContext.translate(-0.5, 0.0);\n        } else if (y1 === y2 && lineWidth % 2 === 1) {\n          curContext.translate(0.0, -0.5);\n        }\n        if (lineWidth === 1) {\n          curContext.lineCap = lineCap;\n        }\n      }\n    };\n\n    Drawing3D.prototype.line = function(x1, y1, z1, x2, y2, z2) {\n      if (y2 === undef || z2 === undef) { // 2D line called in 3D context\n        z2 = 0;\n        y2 = x2;\n        x2 = z1;\n        z1 = 0;\n      }\n\n      // a line is only defined if it has different start and end coordinates.\n      // If they are the same, we call point instead.\n      if (x1===x2 && y1===y2 && z1===z2) {\n        p.point(x1,y1,z1);\n        return;\n      }\n\n      var lineVerts = [x1, y1, z1, x2, y2, z2];\n\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      if (lineWidth > 0 && doStroke) {\n        curContext.useProgram(programObject2D);\n\n        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, [1,0,0,0,  0,1,0,0,  0,0,1,0,  0,0,0,1]);\n        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText\", programObject2D, \"uIsDrawingText\", false);\n\n        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, lineBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n\n        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(lineVerts), curContext.STREAM_DRAW);\n        curContext.drawArrays(curContext.LINES, 0, 2);\n      }\n    };\n\n    /**\n     * Draws a Bezier curve on the screen. These curves are defined by a series of anchor and control points. The first\n     * two parameters specify the first anchor point and the last two parameters specify the other anchor point. The\n     * middle parameters specify the control points which define the shape of the curve. Bezier curves were developed\n     * by French engineer Pierre Bezier. Using the 3D version of requires rendering with P3D or OPENGL (see the\n     * Environment reference for more information).\n     *\n     * @param {int | float} x1,y1,z1    coordinates for the first anchor point\n     * @param {int | float} cx1,cy1,cz1 coordinates for the first control point\n     * @param {int | float} cx2,cy2,cz2 coordinates for the second control point\n     * @param {int | float} x2,y2,z2    coordinates for the second anchor point\n     *\n     * @see bezierVertex\n     * @see curve\n     */\n    Drawing2D.prototype.bezier = function() {\n      if (arguments.length !== 8) {\n        throw(\"You must use 8 parameters for bezier() in 2D mode\");\n      }\n\n      p.beginShape();\n      p.vertex( arguments[0], arguments[1] );\n      p.bezierVertex( arguments[2], arguments[3],\n                      arguments[4], arguments[5],\n                      arguments[6], arguments[7] );\n      p.endShape();\n    };\n\n    Drawing3D.prototype.bezier = function() {\n      if (arguments.length !== 12) {\n        throw(\"You must use 12 parameters for bezier() in 3D mode\");\n      }\n\n      p.beginShape();\n      p.vertex( arguments[0], arguments[1], arguments[2] );\n      p.bezierVertex( arguments[3], arguments[4], arguments[5],\n                      arguments[6], arguments[7], arguments[8],\n                      arguments[9], arguments[10], arguments[11] );\n      p.endShape();\n    };\n\n    /**\n     * Sets the resolution at which Beziers display. The default value is 20. This function is only useful when using the P3D\n     * or OPENGL renderer as the default (JAVA2D) renderer does not use this information.\n     *\n     * @param {int} detail resolution of the curves\n     *\n     * @see curve\n     * @see curveVertex\n     * @see curveTightness\n     */\n    p.bezierDetail = function( detail ){\n      bezDetail = detail;\n    };\n\n    /**\n     * The bezierPoint() function evalutes quadratic bezier at point t for points a, b, c, d.\n     * The parameter t varies between 0 and 1. The a and d parameters are the\n     * on-curve points, b and c are the control points. To make a two-dimensional\n     * curve, call this function once with the x coordinates and a second time\n     * with the y coordinates to get the location of a bezier curve at t.\n     *\n     * @param {float} a   coordinate of first point on the curve\n     * @param {float} b   coordinate of first control point\n     * @param {float} c   coordinate of second control point\n     * @param {float} d   coordinate of second point on the curve\n     * @param {float} t   value between 0 and 1\n     *\n     * @see #bezier()\n     * @see #bezierVertex()\n     * @see #curvePoint()\n     */\n    p.bezierPoint = function(a, b, c, d, t) {\n      return (1 - t) * (1 - t) * (1 - t) * a + 3 * (1 - t) * (1 - t) * t * b + 3 * (1 - t) * t * t * c + t * t * t * d;\n    };\n\n    /**\n     * The bezierTangent() function calculates the tangent of a point on a Bezier curve. There is a good\n     * definition of \"tangent\" at Wikipedia: <a href=\"http://en.wikipedia.org/wiki/Tangent\" target=\"new\">http://en.wikipedia.org/wiki/Tangent</a>\n     *\n     * @param {float} a   coordinate of first point on the curve\n     * @param {float} b   coordinate of first control point\n     * @param {float} c   coordinate of second control point\n     * @param {float} d   coordinate of second point on the curve\n     * @param {float} t   value between 0 and 1\n     *\n     * @see #bezier()\n     * @see #bezierVertex()\n     * @see #curvePoint()\n     */\n    p.bezierTangent = function(a, b, c, d, t) {\n      return (3 * t * t * (-a + 3 * b - 3 * c + d) + 6 * t * (a - 2 * b + c) + 3 * (-a + b));\n    };\n\n    /**\n     * The curvePoint() function evalutes the Catmull-Rom curve at point t for points a, b, c, d. The\n     * parameter t varies between 0 and 1, a and d are points on the curve,\n     * and b and c are the control points. This can be done once with the x\n     * coordinates and a second time with the y coordinates to get the\n     * location of a curve at t.\n     *\n     * @param {int|float} a   coordinate of first point on the curve\n     * @param {int|float} b   coordinate of second point on the curve\n     * @param {int|float} c   coordinate of third point on the curve\n     * @param {int|float} d   coordinate of fourth point on the curve\n     * @param {float} t       value between 0 and 1\n     *\n     * @see #curve()\n     * @see #curveVertex()\n     * @see #bezierPoint()\n     */\n    p.curvePoint = function(a, b, c, d, t) {\n      return 0.5 * ((2 * b) + (-a + c) * t + (2 * a - 5 * b + 4 * c - d) * t * t + (-a + 3 * b - 3 * c + d) * t * t * t);\n    };\n\n    /**\n     * The curveTangent() function calculates the tangent of a point on a Catmull-Rom curve.\n     * There is a good definition of \"tangent\" at Wikipedia: <a href=\"http://en.wikipedia.org/wiki/Tangent\" target=\"new\">http://en.wikipedia.org/wiki/Tangent</a>.\n     *\n     * @param {int|float} a   coordinate of first point on the curve\n     * @param {int|float} b   coordinate of first control point\n     * @param {int|float} c   coordinate of second control point\n     * @param {int|float} d   coordinate of second point on the curve\n     * @param {float} t       value between 0 and 1\n     *\n     * @see #curve()\n     * @see #curveVertex()\n     * @see #curvePoint()\n     * @see #bezierTangent()\n     */\n    p.curveTangent = function(a, b, c, d, t) {\n      return 0.5 * ((-a + c) + 2 * (2 * a - 5 * b + 4 * c - d) * t + 3 * (-a + 3 * b - 3 * c + d) * t * t);\n    };\n\n    /**\n     * A triangle is a plane created by connecting three points. The first two arguments specify the first point,\n     * the middle two arguments specify the second point, and the last two arguments specify the third point.\n     *\n     * @param {int | float} x1 x-coordinate of the first point\n     * @param {int | float} y1 y-coordinate of the first point\n     * @param {int | float} x2 x-coordinate of the second point\n     * @param {int | float} y2 y-coordinate of the second point\n     * @param {int | float} x3 x-coordinate of the third point\n     * @param {int | float} y3 y-coordinate of the third point\n     */\n    p.triangle = function(x1, y1, x2, y2, x3, y3) {\n      p.beginShape(PConstants.TRIANGLES);\n      p.vertex(x1, y1, 0);\n      p.vertex(x2, y2, 0);\n      p.vertex(x3, y3, 0);\n      p.endShape();\n    };\n\n    /**\n     * A quad is a quadrilateral, a four sided polygon. It is similar to a rectangle, but the angles between its\n     * edges are not constrained to ninety degrees. The first pair of parameters (x1,y1) sets the first vertex\n     * and the subsequent pairs should proceed clockwise or counter-clockwise around the defined shape.\n     *\n     * @param {float | int} x1 x-coordinate of the first corner\n     * @param {float | int} y1 y-coordinate of the first corner\n     * @param {float | int} x2 x-coordinate of the second corner\n     * @param {float | int} y2 y-coordinate of the second corner\n     * @param {float | int} x3 x-coordinate of the third corner\n     * @param {float | int} y3 y-coordinate of the third corner\n     * @param {float | int} x4 x-coordinate of the fourth corner\n     * @param {float | int} y4 y-coordinate of the fourth corner\n     */\n    p.quad = function(x1, y1, x2, y2, x3, y3, x4, y4) {\n      p.beginShape(PConstants.QUADS);\n      p.vertex(x1, y1, 0);\n      p.vertex(x2, y2, 0);\n      p.vertex(x3, y3, 0);\n      p.vertex(x4, y4, 0);\n      p.endShape();\n    };\n\n    var roundedRect$2d = function(x, y, width, height, tl, tr, br, bl) {\n      if (bl === undef) {\n        tr = tl;\n        br = tl;\n        bl = tl;\n      }\n      var halfWidth = width / 2,\n          halfHeight = height / 2;\n      if (tl > halfWidth || tl > halfHeight) {\n        tl = Math.min(halfWidth, halfHeight);\n      }\n      if (tr > halfWidth || tr > halfHeight) {\n        tr = Math.min(halfWidth, halfHeight);\n      }\n      if (br > halfWidth || br > halfHeight) {\n        br = Math.min(halfWidth, halfHeight);\n      }\n      if (bl > halfWidth || bl > halfHeight) {\n        bl = Math.min(halfWidth, halfHeight);\n      }\n      // Translate the stroke by (0.5, 0.5) to draw a crisp border\n      if (!doFill || doStroke) {\n        curContext.translate(0.5, 0.5);\n      }\n      curContext.beginPath();\n      curContext.moveTo(x + tl, y);\n      curContext.lineTo(x + width - tr, y);\n      curContext.quadraticCurveTo(x + width, y, x + width, y + tr);\n      curContext.lineTo(x + width, y + height - br);\n      curContext.quadraticCurveTo(x + width, y + height, x + width - br, y + height);\n      curContext.lineTo(x + bl, y + height);\n      curContext.quadraticCurveTo(x, y + height, x, y + height - bl);\n      curContext.lineTo(x, y + tl);\n      curContext.quadraticCurveTo(x, y, x + tl, y);\n      if (!doFill || doStroke) {\n        curContext.translate(-0.5, -0.5);\n      }\n      executeContextFill();\n      executeContextStroke();\n    };\n\n    /**\n    * Draws a rectangle to the screen. A rectangle is a four-sided shape with every angle at ninety\n    * degrees. The first two parameters set the location, the third sets the width, and the fourth\n    * sets the height. The origin is changed with the rectMode() function.\n    *\n    * @param {int|float} x        x-coordinate of the rectangle\n    * @param {int|float} y        y-coordinate of the rectangle\n    * @param {int|float} width    width of the rectangle\n    * @param {int|float} height   height of the rectangle\n    *\n    * @see rectMode\n    * @see quad\n    */\n    Drawing2D.prototype.rect = function(x, y, width, height, tl, tr, br, bl) {\n      if (!width && !height) {\n        return;\n      }\n\n      if (curRectMode === PConstants.CORNERS) {\n        width -= x;\n        height -= y;\n      } else if (curRectMode === PConstants.RADIUS) {\n        width *= 2;\n        height *= 2;\n        x -= width / 2;\n        y -= height / 2;\n      } else if (curRectMode === PConstants.CENTER) {\n        x -= width / 2;\n        y -= height / 2;\n      }\n\n      x = Math.round(x);\n      y = Math.round(y);\n      width = Math.round(width);\n      height = Math.round(height);\n      if (tl !== undef) {\n        roundedRect$2d(x, y, width, height, tl, tr, br, bl);\n        return;\n      }\n\n      // Translate the line by (0.5, 0.5) to draw a crisp rectangle border\n      if (doStroke && lineWidth % 2 === 1) {\n        curContext.translate(0.5, 0.5);\n      }\n      curContext.beginPath();\n      curContext.rect(x, y, width, height);\n      executeContextFill();\n      executeContextStroke();\n      if (doStroke && lineWidth % 2 === 1) {\n        curContext.translate(-0.5, -0.5);\n      }\n    };\n\n    Drawing3D.prototype.rect = function(x, y, width, height, tl, tr, br, bl) {\n      if (tl !== undef) {\n        throw \"rect() with rounded corners is not supported in 3D mode\";\n      }\n\n      if (curRectMode === PConstants.CORNERS) {\n        width -= x;\n        height -= y;\n      } else if (curRectMode === PConstants.RADIUS) {\n        width *= 2;\n        height *= 2;\n        x -= width / 2;\n        y -= height / 2;\n      } else if (curRectMode === PConstants.CENTER) {\n        x -= width / 2;\n        y -= height / 2;\n      }\n\n      // Modeling transformation\n      var model = new PMatrix3D();\n      model.translate(x, y, 0);\n      model.scale(width, height, 1);\n      model.transpose();\n\n      // viewing transformation needs to have Y flipped\n      // becuase that's what Processing does.\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      if (lineWidth > 0 && doStroke) {\n        curContext.useProgram(programObject2D);\n        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", false);\n        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, rectBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n        curContext.drawArrays(curContext.LINE_LOOP, 0, rectVerts.length / 3);\n      }\n\n      if (doFill) {\n        curContext.useProgram(programObject3D);\n        uniformMatrix(\"uModel3d\", programObject3D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView3d\", programObject3D, \"uView\", false, view.array());\n\n        // fix stitching problems. (lines get occluded by triangles\n        // since they share the same depth values). This is not entirely\n        // working, but it's a start for drawing the outline. So\n        // developers can start playing around with styles.\n        curContext.enable(curContext.POLYGON_OFFSET_FILL);\n        curContext.polygonOffset(1, 1);\n\n        uniformf(\"color3d\", programObject3D, \"uColor\", fillStyle);\n\n        if(lightCount > 0){\n          var v = new PMatrix3D();\n          v.set(view);\n\n          var m = new PMatrix3D();\n          m.set(model);\n\n          v.mult(m);\n\n          var normalMatrix = new PMatrix3D();\n          normalMatrix.set(v);\n          normalMatrix.invert();\n          normalMatrix.transpose();\n\n          uniformMatrix(\"uNormalTransform3d\", programObject3D, \"uNormalTransform\", false, normalMatrix.array());\n          vertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\", 3, rectNormBuffer);\n        }\n        else{\n          disableVertexAttribPointer(\"normal3d\", programObject3D, \"aNormal\");\n        }\n\n        vertexAttribPointer(\"vertex3d\", programObject3D, \"aVertex\", 3, rectBuffer);\n\n        curContext.drawArrays(curContext.TRIANGLE_FAN, 0, rectVerts.length / 3);\n        curContext.disable(curContext.POLYGON_OFFSET_FILL);\n      }\n    };\n\n    /**\n     * Draws an ellipse (oval) in the display window. An ellipse with an equal <b>width</b> and <b>height</b> is a circle.\n     * The first two parameters set the location, the third sets the width, and the fourth sets the height. The origin may be\n     * changed with the <b>ellipseMode()</b> function.\n     *\n     * @param {float|int} x      x-coordinate of the ellipse\n     * @param {float|int} y      y-coordinate of the ellipse\n     * @param {float|int} width  width of the ellipse\n     * @param {float|int} height height of the ellipse\n     *\n     * @see ellipseMode\n     */\n    Drawing2D.prototype.ellipse = function(x, y, width, height) {\n      x = x || 0;\n      y = y || 0;\n\n      if (width <= 0 && height <= 0) {\n        return;\n      }\n\n      if (curEllipseMode === PConstants.RADIUS) {\n        width *= 2;\n        height *= 2;\n      } else if (curEllipseMode === PConstants.CORNERS) {\n        width = width - x;\n        height = height - y;\n        x += width / 2;\n        y += height / 2;\n      } else if (curEllipseMode === PConstants.CORNER) {\n        x += width / 2;\n        y += height / 2;\n      }\n\n      // Shortcut for drawing a 2D circle\n      if (width === height) {\n        curContext.beginPath();\n        curContext.arc(x, y, width / 2, 0, PConstants.TWO_PI, false);\n        executeContextFill();\n        executeContextStroke();\n      } else {\n        var w = width / 2,\n            h = height / 2,\n            C = 0.5522847498307933,\n            c_x = C * w,\n            c_y = C * h;\n\n        p.beginShape();\n        p.vertex(x + w, y);\n        p.bezierVertex(x + w, y - c_y, x + c_x, y - h, x, y - h);\n        p.bezierVertex(x - c_x, y - h, x - w, y - c_y, x - w, y);\n        p.bezierVertex(x - w, y + c_y, x - c_x, y + h, x, y + h);\n        p.bezierVertex(x + c_x, y + h, x + w, y + c_y, x + w, y);\n        p.endShape();\n      }\n    };\n\n    Drawing3D.prototype.ellipse = function(x, y, width, height) {\n      x = x || 0;\n      y = y || 0;\n\n      if (width <= 0 && height <= 0) {\n        return;\n      }\n\n      if (curEllipseMode === PConstants.RADIUS) {\n        width *= 2;\n        height *= 2;\n      } else if (curEllipseMode === PConstants.CORNERS) {\n        width = width - x;\n        height = height - y;\n        x += width / 2;\n        y += height / 2;\n      } else if (curEllipseMode === PConstants.CORNER) {\n        x += width / 2;\n        y += height / 2;\n      }\n\n      var w = width / 2,\n          h = height / 2,\n          C = 0.5522847498307933,\n          c_x = C * w,\n          c_y = C * h;\n\n      p.beginShape();\n      p.vertex(x + w, y);\n      p.bezierVertex(x + w, y - c_y, 0, x + c_x, y - h, 0, x, y - h, 0);\n      p.bezierVertex(x - c_x, y - h, 0, x - w, y - c_y, 0, x - w, y, 0);\n      p.bezierVertex(x - w, y + c_y, 0, x - c_x, y + h, 0, x, y + h, 0);\n      p.bezierVertex(x + c_x, y + h, 0, x + w, y + c_y, 0, x + w, y, 0);\n      p.endShape();\n\n      if (doFill) {\n        //temporary workaround to not working fills for bezier -- will fix later\n        var xAv = 0, yAv = 0, i, j;\n        for (i = 0; i < vertArray.length; i++) {\n          xAv += vertArray[i][0];\n          yAv += vertArray[i][1];\n        }\n        xAv /= vertArray.length;\n        yAv /= vertArray.length;\n        var vert = [],\n            fillVertArray = [],\n            colorVertArray = [];\n        vert[0] = xAv;\n        vert[1] = yAv;\n        vert[2] = 0;\n        vert[3] = 0;\n        vert[4] = 0;\n        vert[5] = fillStyle[0];\n        vert[6] = fillStyle[1];\n        vert[7] = fillStyle[2];\n        vert[8] = fillStyle[3];\n        vert[9] = strokeStyle[0];\n        vert[10] = strokeStyle[1];\n        vert[11] = strokeStyle[2];\n        vert[12] = strokeStyle[3];\n        vert[13] = normalX;\n        vert[14] = normalY;\n        vert[15] = normalZ;\n        vertArray.unshift(vert);\n        for (i = 0; i < vertArray.length; i++) {\n          for (j = 0; j < 3; j++) {\n            fillVertArray.push(vertArray[i][j]);\n          }\n          for (j = 5; j < 9; j++) {\n            colorVertArray.push(vertArray[i][j]);\n          }\n        }\n        fill3D(fillVertArray, \"TRIANGLE_FAN\", colorVertArray);\n      }\n    };\n\n    /**\n    * Sets the current normal vector. This is for drawing three dimensional shapes and surfaces and\n    * specifies a vector perpendicular to the surface of the shape which determines how lighting affects\n    * it. Processing attempts to automatically assign normals to shapes, but since that's imperfect,\n    * this is a better option when you want more control. This function is identical to glNormal3f() in OpenGL.\n    *\n    * @param {float} nx       x direction\n    * @param {float} ny       y direction\n    * @param {float} nz       z direction\n    *\n    * @see beginShape\n    * @see endShape\n    * @see lights\n    */\n    p.normal = function(nx, ny, nz) {\n      if (arguments.length !== 3 || !(typeof nx === \"number\" && typeof ny === \"number\" && typeof nz === \"number\")) {\n        throw \"normal() requires three numeric arguments.\";\n      }\n\n      normalX = nx;\n      normalY = ny;\n      normalZ = nz;\n\n      if (curShape !== 0) {\n        if (normalMode === PConstants.NORMAL_MODE_AUTO) {\n          normalMode = PConstants.NORMAL_MODE_SHAPE;\n        } else if (normalMode === PConstants.NORMAL_MODE_SHAPE) {\n          normalMode = PConstants.NORMAL_MODE_VERTEX;\n        }\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Raster drawing functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * Saves an image from the display window. Images are saved in TIFF, TARGA, JPEG, and PNG format\n    * depending on the extension within the filename  parameter. For example, \"image.tif\" will have\n    * a TIFF image and \"image.png\" will save a PNG image. If no extension is included in the filename,\n    * the image will save in TIFF format and .tif will be added to the name. These files are saved to\n    * the sketch's folder, which may be opened by selecting \"Show sketch folder\" from the \"Sketch\" menu.\n    * It is not possible to use save() while running the program in a web browser.  All images saved\n    * from the main drawing window will be opaque. To save images without a background, use createGraphics().\n    *\n    * @param {String} filename      any sequence of letters and numbers\n    *\n    * @see saveFrame\n    * @see createGraphics\n    */\n    p.save = function(file, img) {\n      // file is unused at the moment\n      // may implement this differently in later release\n      if (img !== undef) {\n        return window.open(img.toDataURL(),\"_blank\");\n      }\n      return window.open(p.externals.canvas.toDataURL(),\"_blank\");\n    };\n\n    var saveNumber = 0;\n\n    p.saveFrame = function(file) {\n      if(file === undef) {\n        // use default name template if parameter is not specified\n        file = \"screen-####.png\";\n      }\n      // Increment changeable part: screen-0000.png, screen-0001.png, ...\n      var frameFilename = file.replace(/#+/, function(all) {\n        var s = \"\" + (saveNumber++);\n        while(s.length < all.length) {\n          s = \"0\" + s;\n        }\n        return s;\n      });\n      p.save(frameFilename);\n    };\n\n    var utilityContext2d = document.createElement(\"canvas\").getContext(\"2d\");\n\n    var canvasDataCache = [undef, undef, undef]; // we need three for now\n\n    function getCanvasData(obj, w, h) {\n      var canvasData = canvasDataCache.shift();\n\n      if (canvasData === undef) {\n        canvasData = {};\n        canvasData.canvas = document.createElement(\"canvas\");\n        canvasData.context = canvasData.canvas.getContext('2d');\n      }\n\n      canvasDataCache.push(canvasData);\n\n      var canvas = canvasData.canvas, context = canvasData.context,\n          width = w || obj.width, height = h || obj.height;\n\n      canvas.width = width;\n      canvas.height = height;\n\n      if (!obj) {\n        context.clearRect(0, 0, width, height);\n      } else if (\"data\" in obj) { // ImageData\n        context.putImageData(obj, 0, 0);\n      } else {\n        context.clearRect(0, 0, width, height);\n        context.drawImage(obj, 0, 0, width, height);\n      }\n      return canvasData;\n    }\n\n    /**\n     * Handle the sketch code for pixels[] and pixels.length\n     * parser code converts pixels[] to getPixels()\n     * or setPixels(), .length becomes getLength()\n     */\n    function buildPixelsObject(pImage) {\n      return {\n\n        getLength: (function(aImg) {\n          return function() {\n            if (aImg.isRemote) {\n              throw \"Image is loaded remotely. Cannot get length.\";\n            } else {\n              return aImg.imageData.data.length ? aImg.imageData.data.length/4 : 0;\n            }\n          };\n        }(pImage)),\n\n        getPixel: (function(aImg) {\n          return function(i) {\n            var offset = i*4,\n              data = aImg.imageData.data;\n\n            if (aImg.isRemote) {\n              throw \"Image is loaded remotely. Cannot get pixels.\";\n            }\n\n            return (data[offset+3] << 24) & PConstants.ALPHA_MASK |\n                   (data[offset] << 16) & PConstants.RED_MASK |\n                   (data[offset+1] << 8) & PConstants.GREEN_MASK |\n                   data[offset+2] & PConstants.BLUE_MASK;\n          };\n        }(pImage)),\n\n        setPixel: (function(aImg) {\n          return function(i, c) {\n            var offset = i*4,\n              data = aImg.imageData.data;\n\n            if (aImg.isRemote) {\n              throw \"Image is loaded remotely. Cannot set pixel.\";\n            }\n\n            data[offset+0] = (c & PConstants.RED_MASK) >>> 16;\n            data[offset+1] = (c & PConstants.GREEN_MASK) >>> 8;\n            data[offset+2] = (c & PConstants.BLUE_MASK);\n            data[offset+3] = (c & PConstants.ALPHA_MASK) >>> 24;\n            aImg.__isDirty = true;\n          };\n        }(pImage)),\n\n        toArray: (function(aImg) {\n          return function() {\n            var arr = [],\n              data = aImg.imageData.data,\n              length = aImg.width * aImg.height;\n\n            if (aImg.isRemote) {\n              throw \"Image is loaded remotely. Cannot get pixels.\";\n            }\n\n            for (var i = 0, offset = 0; i < length; i++, offset += 4) {\n              arr.push( (data[offset+3] << 24) & PConstants.ALPHA_MASK |\n                        (data[offset] << 16) & PConstants.RED_MASK |\n                        (data[offset+1] << 8) & PConstants.GREEN_MASK |\n                        data[offset+2] & PConstants.BLUE_MASK );\n            }\n            return arr;\n          };\n        }(pImage)),\n\n        set: (function(aImg) {\n          return function(arr) {\n            var offset,\n              data,\n              c;\n            if (this.isRemote) {\n              throw \"Image is loaded remotely. Cannot set pixels.\";\n            }\n\n            data = aImg.imageData.data;\n            for (var i = 0, aL = arr.length; i < aL; i++) {\n              c = arr[i];\n              offset = i*4;\n\n              data[offset+0] = (c & PConstants.RED_MASK) >>> 16;\n              data[offset+1] = (c & PConstants.GREEN_MASK) >>> 8;\n              data[offset+2] = (c & PConstants.BLUE_MASK);\n              data[offset+3] = (c & PConstants.ALPHA_MASK) >>> 24;\n            }\n            aImg.__isDirty = true;\n          };\n        }(pImage))\n\n      };\n    }\n\n    /**\n    * Datatype for storing images. Processing can display .gif, .jpg, .tga, and .png images. Images may be\n    * displayed in 2D and 3D space. Before an image is used, it must be loaded with the loadImage() function.\n    * The PImage object contains fields for the width and height of the image, as well as an array called\n    * pixels[]  which contains the values for every pixel in the image. A group of methods, described below,\n    * allow easy access to the image's pixels and alpha channel and simplify the process of compositing.\n    * Before using the pixels[] array, be sure to use the loadPixels() method on the image to make sure that the\n    * pixel data is properly loaded. To create a new image, use the createImage() function (do not use new PImage()).\n    *\n    * @param {int} width                image width\n    * @param {int} height               image height\n    * @param {MODE} format              Either RGB, ARGB, ALPHA (grayscale alpha channel)\n    *\n    * @returns {PImage}\n    *\n    * @see loadImage\n    * @see imageMode\n    * @see createImage\n    */\n    var PImage = function(aWidth, aHeight, aFormat) {\n\n      // Keep track of whether or not the cached imageData has been touched.\n      this.__isDirty = false;\n\n      if (aWidth instanceof HTMLImageElement) {\n        // convert an <img> to a PImage\n        this.fromHTMLImageData(aWidth);\n      } else if (aHeight || aFormat) {\n        this.width = aWidth || 1;\n        this.height = aHeight || 1;\n\n        // Stuff a canvas into sourceImg so image() calls can use drawImage like an <img>\n        var canvas = this.sourceImg = document.createElement(\"canvas\");\n        canvas.width = this.width;\n        canvas.height = this.height;\n\n        var imageData = this.imageData = canvas.getContext('2d').createImageData(this.width, this.height);\n        this.format = (aFormat === PConstants.ARGB || aFormat === PConstants.ALPHA) ? aFormat : PConstants.RGB;\n        if (this.format === PConstants.RGB) {\n          // Set the alpha channel of an RGB image to opaque.\n          for (var i = 3, data = this.imageData.data, len = data.length; i < len; i += 4) {\n            data[i] = 255;\n          }\n        }\n\n        this.__isDirty = true;\n        this.updatePixels();\n      } else {\n        this.width = 0;\n        this.height = 0;\n        this.imageData = utilityContext2d.createImageData(1, 1);\n        this.format = PConstants.ARGB;\n      }\n\n      this.pixels = buildPixelsObject(this);\n    };\n    PImage.prototype = {\n\n      /**\n       * Temporary hack to deal with cross-Processing-instance created PImage.  See\n       * tickets #1623 and #1644.\n       */\n      __isPImage: true,\n\n      /**\n      * @member PImage\n      * Updates the image with the data in its pixels[] array. Use in conjunction with loadPixels(). If\n      * you're only reading pixels from the array, there's no need to call updatePixels().\n      * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule\n      * is that any time you want to manipulate the pixels[] array, you must first call loadPixels(), and\n      * after changes have been made, call updatePixels(). Even if the renderer may not seem to use this\n      * function in the current Processing release, this will always be subject to change.\n      * Currently, none of the renderers use the additional parameters to updatePixels().\n      */\n      updatePixels: function() {\n        var canvas = this.sourceImg;\n        if (canvas && canvas instanceof HTMLCanvasElement && this.__isDirty) {\n          canvas.getContext('2d').putImageData(this.imageData, 0, 0);\n        }\n        this.__isDirty = false;\n      },\n\n      fromHTMLImageData: function(htmlImg) {\n        // convert an <img> to a PImage\n        var canvasData = getCanvasData(htmlImg);\n        try {\n          var imageData = canvasData.context.getImageData(0, 0, htmlImg.width, htmlImg.height);\n          this.fromImageData(imageData);\n        } catch(e) {\n          if (htmlImg.width && htmlImg.height) {\n            this.isRemote = true;\n            this.width = htmlImg.width;\n            this.height = htmlImg.height;\n          }\n        }\n        this.sourceImg = htmlImg;\n      },\n\n      'get': function(x, y, w, h) {\n        if (!arguments.length) {\n          return p.get(this);\n        }\n        if (arguments.length === 2) {\n          return p.get(x, y, this);\n        }\n        if (arguments.length === 4) {\n          return p.get(x, y, w, h, this);\n        }\n      },\n\n      /**\n      * @member PImage\n      * Changes the color of any pixel or writes an image directly into the image. The x and y parameter\n      * specify the pixel or the upper-left corner of the image. The color parameter specifies the color value.\n      * Setting the color of a single pixel with set(x, y) is easy, but not as fast as putting the data\n      * directly into pixels[]. The equivalent statement to \"set(x, y, #000000)\" using pixels[] is\n      * \"pixels[y*width+x] = #000000\". Processing requires calling loadPixels() to load the display window\n      * data into the pixels[] array before getting the values and calling updatePixels() to update the window.\n      *\n      * @param {int} x        x-coordinate of the pixel or upper-left corner of the image\n      * @param {int} y        y-coordinate of the pixel or upper-left corner of the image\n      * @param {color} color  any value of the color datatype\n      *\n      * @see get\n      * @see pixels[]\n      * @see copy\n      */\n      'set': function(x, y, c) {\n        p.set(x, y, c, this);\n        this.__isDirty = true;\n      },\n\n      /**\n      * @member PImage\n      * Blends a region of pixels into the image specified by the img parameter. These copies utilize full\n      * alpha channel support and a choice of the following modes to blend the colors of source pixels (A)\n      * with the ones of pixels in the destination image (B):\n      * BLEND - linear interpolation of colours: C = A*factor + B\n      * ADD - additive blending with white clip: C = min(A*factor + B, 255)\n      * SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n      * DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n      * LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n      * DIFFERENCE - subtract colors from underlying image.\n      * EXCLUSION - similar to DIFFERENCE, but less extreme.\n      * MULTIPLY - Multiply the colors, result will always be darker.\n      * SCREEN - Opposite multiply, uses inverse values of the colors.\n      * OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values, and screens light values.\n      * HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n      * SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.\n      * DODGE - Lightens light tones and increases contrast, ignores darks. Called \"Color Dodge\" in Illustrator and Photoshop.\n      * BURN - Darker areas are applied, increasing contrast, ignores lights. Called \"Color Burn\" in Illustrator and Photoshop.\n      * All modes use the alpha information (highest byte) of source image pixels as the blending factor.\n      * If the source and destination regions are different sizes, the image will be automatically resized to\n      * match the destination size. If the srcImg parameter is not used, the display window is used as the source image.\n      * This function ignores imageMode().\n      *\n      * @param {int} x              X coordinate of the source's upper left corner\n      * @param {int} y              Y coordinate of the source's upper left corner\n      * @param {int} width          source image width\n      * @param {int} height         source image height\n      * @param {int} dx             X coordinate of the destinations's upper left corner\n      * @param {int} dy             Y coordinate of the destinations's upper left corner\n      * @param {int} dwidth         destination image width\n      * @param {int} dheight        destination image height\n      * @param {PImage} srcImg      an image variable referring to the source image\n      * @param {MODE} MODE          Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION,\n      * MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN\n      *\n      * @see alpha\n      * @see copy\n      */\n      blend: function(srcImg, x, y, width, height, dx, dy, dwidth, dheight, MODE) {\n        if (arguments.length === 9) {\n          p.blend(this, srcImg, x, y, width, height, dx, dy, dwidth, dheight, this);\n        } else if (arguments.length === 10) {\n          p.blend(srcImg, x, y, width, height, dx, dy, dwidth, dheight, MODE, this);\n        }\n        delete this.sourceImg;\n      },\n\n      /**\n      * @member PImage\n      * Copies a region of pixels from one image into another. If the source and destination regions\n      * aren't the same size, it will automatically resize source pixels to fit the specified target region.\n      * No alpha information is used in the process, however if the source image has an alpha channel set,\n      * it will be copied as well. This function ignores imageMode().\n      *\n      * @param {int} sx             X coordinate of the source's upper left corner\n      * @param {int} sy             Y coordinate of the source's upper left corner\n      * @param {int} swidth         source image width\n      * @param {int} sheight        source image height\n      * @param {int} dx             X coordinate of the destinations's upper left corner\n      * @param {int} dy             Y coordinate of the destinations's upper left corner\n      * @param {int} dwidth         destination image width\n      * @param {int} dheight        destination image height\n      * @param {PImage} srcImg      an image variable referring to the source image\n      *\n      * @see alpha\n      * @see blend\n      */\n      copy: function(srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {\n        if (arguments.length === 8) {\n          p.blend(this, srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, PConstants.REPLACE, this);\n        } else if (arguments.length === 9) {\n          p.blend(srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, dheight, PConstants.REPLACE, this);\n        }\n        delete this.sourceImg;\n      },\n\n      /**\n      * @member PImage\n      * Filters an image as defined by one of the following modes:\n      * THRESHOLD - converts the image to black and white pixels depending if they are above or below\n      * the threshold defined by the level parameter. The level must be between 0.0 (black) and 1.0(white).\n      * If no level is specified, 0.5 is used.\n      * GRAY - converts any colors in the image to grayscale equivalents\n      * INVERT - sets each pixel to its inverse value\n      * POSTERIZE - limits each channel of the image to the number of colors specified as the level parameter\n      * BLUR - executes a Guassian blur with the level parameter specifying the extent of the blurring.\n      * If no level parameter is used, the blur is equivalent to Guassian blur of radius 1.\n      * OPAQUE - sets the alpha channel to entirely opaque.\n      * ERODE - reduces the light areas with the amount defined by the level parameter.\n      * DILATE - increases the light areas with the amount defined by the level parameter\n      *\n      * @param {MODE} MODE        Either THRESHOLD, GRAY, INVERT, POSTERIZE, BLUR, OPAQUE, ERODE, or DILATE\n      * @param {int|float} param  in the range from 0 to 1\n      */\n      filter: function(mode, param) {\n        if (arguments.length === 2) {\n          p.filter(mode, param, this);\n        } else if (arguments.length === 1) {\n          // no param specified, send null to show its invalid\n          p.filter(mode, null, this);\n        }\n        delete this.sourceImg;\n      },\n\n      /**\n      * @member PImage\n      * Saves the image into a file. Images are saved in TIFF, TARGA, JPEG, and PNG format depending on\n      * the extension within the filename  parameter. For example, \"image.tif\" will have a TIFF image and\n      * \"image.png\" will save a PNG image. If no extension is included in the filename, the image will save\n      * in TIFF format and .tif will be added to the name. These files are saved to the sketch's folder,\n      * which may be opened by selecting \"Show sketch folder\" from the \"Sketch\" menu. It is not possible to\n      * use save() while running the program in a web browser.\n      * To save an image created within the code, rather than through loading, it's necessary to make the\n      * image with the createImage() function so it is aware of the location of the program and can therefore\n      * save the file to the right place. See the createImage() reference for more information.\n      *\n      * @param {String} filename        a sequence of letters and numbers\n      */\n      save: function(file){\n        p.save(file,this);\n      },\n\n      /**\n      * @member PImage\n      * Resize the image to a new width and height. To make the image scale proportionally, use 0 as the\n      * value for the wide or high parameter.\n      *\n      * @param {int} wide         the resized image width\n      * @param {int} high         the resized image height\n      *\n      * @see get\n      */\n      resize: function(w, h) {\n        if (this.isRemote) { // Remote images cannot access imageData\n          throw \"Image is loaded remotely. Cannot resize.\";\n        }\n        if (this.width !== 0 || this.height !== 0) {\n          // make aspect ratio if w or h is 0\n          if (w === 0 && h !== 0) {\n            w = Math.floor(this.width / this.height * h);\n          } else if (h === 0 && w !== 0) {\n            h = Math.floor(this.height / this.width * w);\n          }\n          // put 'this.imageData' into a new canvas\n          var canvas = getCanvasData(this.imageData).canvas;\n          // pull imageData object out of canvas into ImageData object\n          var imageData = getCanvasData(canvas, w, h).context.getImageData(0, 0, w, h);\n          // set this as new pimage\n          this.fromImageData(imageData);\n        }\n      },\n\n      /**\n      * @member PImage\n      * Masks part of an image from displaying by loading another image and using it as an alpha channel.\n      * This mask image should only contain grayscale data, but only the blue color channel is used. The\n      * mask image needs to be the same size as the image to which it is applied.\n      * In addition to using a mask image, an integer array containing the alpha channel data can be\n      * specified directly. This method is useful for creating dynamically generated alpha masks. This\n      * array must be of the same length as the target image's pixels array and should contain only grayscale\n      * data of values between 0-255.\n      *\n      * @param {PImage} maskImg         any PImage object used as the alpha channel for \"img\", needs to be same\n      *                                 size as \"img\"\n      * @param {int[]} maskArray        any array of Integer numbers used as the alpha channel, needs to be same\n      *                                 length as the image's pixel array\n      */\n      mask: function(mask) {\n        var obj = this.toImageData(),\n            i,\n            size;\n\n        if (mask instanceof PImage || mask.__isPImage) {\n          if (mask.width === this.width && mask.height === this.height) {\n            mask = mask.toImageData();\n\n            for (i = 2, size = this.width * this.height * 4; i < size; i += 4) {\n              // using it as an alpha channel\n              obj.data[i + 1] = mask.data[i];\n              // but only the blue color channel\n            }\n          } else {\n            throw \"mask must have the same dimensions as PImage.\";\n          }\n        } else if (mask instanceof Array) {\n          if (this.width * this.height === mask.length) {\n            for (i = 0, size = mask.length; i < size; ++i) {\n              obj.data[i * 4 + 3] = mask[i];\n            }\n          } else {\n            throw \"mask array must be the same length as PImage pixels array.\";\n          }\n        }\n\n        this.fromImageData(obj);\n      },\n\n      // These are intentionally left blank for PImages, we work live with pixels and draw as necessary\n      /**\n      * @member PImage\n      * Loads the pixel data for the image into its pixels[] array. This function must always be called\n      * before reading from or writing to pixels[].\n      * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the\n      * rule is that any time you want to manipulate the pixels[] array, you must first call loadPixels(),\n      * and after changes have been made, call updatePixels(). Even if the renderer may not seem to use\n      * this function in the current Processing release, this will always be subject to change.\n      */\n      loadPixels: nop,\n\n      toImageData: function() {\n        if (this.isRemote) {\n          return this.sourceImg;\n        }\n\n        if (!this.__isDirty) {\n          return this.imageData;\n        }\n\n        var canvasData = getCanvasData(this.sourceImg);\n        return canvasData.context.getImageData(0, 0, this.width, this.height);\n      },\n\n      toDataURL: function() {\n        if (this.isRemote) { // Remote images cannot access imageData\n          throw \"Image is loaded remotely. Cannot create dataURI.\";\n        }\n        var canvasData = getCanvasData(this.imageData);\n        return canvasData.canvas.toDataURL();\n      },\n\n      fromImageData: function(canvasImg) {\n        var w = canvasImg.width,\n          h = canvasImg.height,\n          canvas = document.createElement('canvas'),\n          ctx = canvas.getContext('2d');\n\n        this.width = canvas.width = w;\n        this.height = canvas.height = h;\n\n        ctx.putImageData(canvasImg, 0, 0);\n\n        // changed for 0.9\n        this.format = PConstants.ARGB;\n\n        this.imageData = canvasImg;\n        this.sourceImg = canvas;\n      }\n    };\n\n    p.PImage = PImage;\n\n    /**\n    * Creates a new PImage (the datatype for storing images). This provides a fresh buffer of pixels to play\n    * with. Set the size of the buffer with the width and height parameters. The format parameter defines how\n    * the pixels are stored. See the PImage reference for more information.\n    * Be sure to include all three parameters, specifying only the width and height (but no format) will\n    * produce a strange error.\n    * Advanced users please note that createImage() should be used instead of the syntax new PImage().\n    *\n    * @param {int} width                image width\n    * @param {int} height               image height\n    * @param {MODE} format              Either RGB, ARGB, ALPHA (grayscale alpha channel)\n    *\n    * @returns {PImage}\n    *\n    * @see PImage\n    * @see PGraphics\n    */\n    p.createImage = function(w, h, mode) {\n      return new PImage(w,h,mode);\n    };\n\n    // Loads an image for display. Type is an extension. Callback is fired on load.\n    /**\n    * Loads an image into a variable of type PImage. Four types of images ( .gif, .jpg, .tga, .png) images may\n    * be loaded. To load correctly, images must be located in the data directory of the current sketch. In most\n    * cases, load all images in setup() to preload them at the start of the program. Loading images inside draw()\n    * will reduce the speed of a program.\n    * The filename parameter can also be a URL to a file found online. For security reasons, a Processing sketch\n    * found online can only download files from the same server from which it came. Getting around this restriction\n    * requires a signed applet.\n    * The extension parameter is used to determine the image type in cases where the image filename does not end\n    * with a proper extension. Specify the extension as the second parameter to loadImage(), as shown in the\n    * third example on this page.\n    * If an image is not loaded successfully, the null value is returned and an error message will be printed to\n    * the console. The error message does not halt the program, however the null value may cause a NullPointerException\n    * if your code does not check whether the value returned from loadImage() is null.\n    * Depending on the type of error, a PImage object may still be returned, but the width and height of the image\n    * will be set to -1. This happens if bad image data is returned or cannot be decoded properly. Sometimes this happens\n    * with image URLs that produce a 403 error or that redirect to a password prompt, because loadImage() will attempt\n    * to interpret the HTML as image data.\n    *\n    * @param {String} filename        name of file to load, can be .gif, .jpg, .tga, or a handful of other image\n    *                                 types depending on your platform.\n    * @param {String} extension       the type of image to load, for example \"png\", \"gif\", \"jpg\"\n    *\n    * @returns {PImage}\n    *\n    * @see PImage\n    * @see image\n    * @see imageMode\n    * @see background\n    */\n    p.loadImage = function(file, type, callback) {\n      // if type is specified add it with a . to file to make the filename\n      if (type) {\n        file = file + \".\" + type;\n      }\n      var pimg;\n      // if image is in the preloader cache return a new PImage\n      if (curSketch.imageCache.images[file]) {\n        pimg = new PImage(curSketch.imageCache.images[file]);\n        pimg.loaded = true;\n        return pimg;\n      }\n      // else async load it\n      pimg = new PImage();\n      var img = document.createElement('img');\n\n      pimg.sourceImg = img;\n\n      img.onload = (function(aImage, aPImage, aCallback) {\n        var image = aImage;\n        var pimg = aPImage;\n        var callback = aCallback;\n        return function() {\n          // change the <img> object into a PImage now that its loaded\n          pimg.fromHTMLImageData(image);\n          pimg.loaded = true;\n          if (callback) {\n            callback();\n          }\n        };\n      }(img, pimg, callback));\n\n      img.src = file; // needs to be called after the img.onload function is declared or it wont work in opera\n      return pimg;\n    };\n\n    // async loading of large images, same functionality as loadImage above\n    /**\n    * This function load images on a separate thread so that your sketch does not freeze while images load during\n    * setup(). While the image is loading, its width and height will be 0. If an error occurs while loading the image,\n    * its width and height will be set to -1. You'll know when the image has loaded properly because its width and\n    * height will be greater than 0. Asynchronous image loading (particularly when downloading from a server) can\n    * dramatically improve performance.\n    * The extension parameter is used to determine the image type in cases where the image filename does not end\n    * with a proper extension. Specify the extension as the second parameter to requestImage().\n    *\n    * @param {String} filename        name of file to load, can be .gif, .jpg, .tga, or a handful of other image\n    *                                 types depending on your platform.\n    * @param {String} extension       the type of image to load, for example \"png\", \"gif\", \"jpg\"\n    *\n    * @returns {PImage}\n    *\n    * @see PImage\n    * @see loadImage\n    */\n    p.requestImage = p.loadImage;\n\n    function get$2(x,y) {\n      var data;\n      // return the color at x,y (int) of curContext\n      if (x >= p.width || x < 0 || y < 0 || y >= p.height) {\n        // x,y is outside image return transparent black\n        return 0;\n      }\n\n      // loadPixels() has been called\n      if (isContextReplaced) {\n        var offset = ((0|x) + p.width * (0|y)) * 4;\n        data = p.imageData.data;\n        return (data[offset + 3] << 24) & PConstants.ALPHA_MASK |\n               (data[offset] << 16) & PConstants.RED_MASK |\n               (data[offset + 1] << 8) & PConstants.GREEN_MASK |\n               data[offset + 2] & PConstants.BLUE_MASK;\n      }\n\n      // x,y is inside canvas space\n      data = p.toImageData(0|x, 0|y, 1, 1).data;\n      return (data[3] << 24) & PConstants.ALPHA_MASK |\n             (data[0] << 16) & PConstants.RED_MASK |\n             (data[1] << 8) & PConstants.GREEN_MASK |\n             data[2] & PConstants.BLUE_MASK;\n    }\n    function get$3(x,y,img) {\n      if (img.isRemote) { // Remote images cannot access imageData\n        throw \"Image is loaded remotely. Cannot get x,y.\";\n      }\n      // PImage.get(x,y) was called, return the color (int) at x,y of img\n      var offset = y * img.width * 4 + (x * 4),\n          data = img.imageData.data;\n      return (data[offset + 3] << 24) & PConstants.ALPHA_MASK |\n             (data[offset] << 16) & PConstants.RED_MASK |\n             (data[offset + 1] << 8) & PConstants.GREEN_MASK |\n             data[offset + 2] & PConstants.BLUE_MASK;\n    }\n    function get$4(x, y, w, h) {\n      // return a PImage of w and h from cood x,y of curContext\n      var c = new PImage(w, h, PConstants.ARGB);\n      c.fromImageData(p.toImageData(x, y, w, h));\n      return c;\n    }\n    function get$5(x, y, w, h, img) {\n      if (img.isRemote) { // Remote images cannot access imageData\n        throw \"Image is loaded remotely. Cannot get x,y,w,h.\";\n      }\n      // PImage.get(x,y,w,h) was called, return x,y,w,h PImage of img\n      // offset start point needs to be *4\n      var c = new PImage(w, h, PConstants.ARGB), cData = c.imageData.data,\n        imgWidth = img.width, imgHeight = img.height, imgData = img.imageData.data;\n      // Don't need to copy pixels from the image outside ranges.\n      var startRow = Math.max(0, -y), startColumn = Math.max(0, -x),\n        stopRow = Math.min(h, imgHeight - y), stopColumn = Math.min(w, imgWidth - x);\n      for (var i = startRow; i < stopRow; ++i) {\n        var sourceOffset = ((y + i) * imgWidth + (x + startColumn)) * 4;\n        var targetOffset = (i * w + startColumn) * 4;\n        for (var j = startColumn; j < stopColumn; ++j) {\n          cData[targetOffset++] = imgData[sourceOffset++];\n          cData[targetOffset++] = imgData[sourceOffset++];\n          cData[targetOffset++] = imgData[sourceOffset++];\n          cData[targetOffset++] = imgData[sourceOffset++];\n        }\n      }\n      c.__isDirty = true;\n      return c;\n    }\n\n    // Gets a single pixel or block of pixels from the current Canvas Context or a PImage\n    /**\n    * Reads the color of any pixel or grabs a section of an image. If no parameters are specified, the entire\n    * image is returned. Get the value of one pixel by specifying an x,y coordinate. Get a section of the display\n    * window by specifying an additional width and height parameter. If the pixel requested is outside of the image\n    * window, black is returned. The numbers returned are scaled according to the current color ranges, but only RGB\n    * values are returned by this function. For example, even though you may have drawn a shape with colorMode(HSB),\n    * the numbers returned will be in RGB.\n    * Getting the color of a single pixel with get(x, y) is easy, but not as fast as grabbing the data directly\n    * from pixels[]. The equivalent statement to \"get(x, y)\" using pixels[] is \"pixels[y*width+x]\". Processing\n    * requires calling loadPixels() to load the display window data into the pixels[] array before getting the values.\n    * This function ignores imageMode().\n    *\n    * @param {int} x            x-coordinate of the pixel\n    * @param {int} y            y-coordinate of the pixel\n    * @param {int} width        width of pixel rectangle to get\n    * @param {int} height       height of pixel rectangle to get\n    *\n    * @returns {Color|PImage}\n    *\n    * @see set\n    * @see pixels[]\n    * @see imageMode\n    */\n    p.get = function(x, y, w, h, img) {\n      // for 0 2 and 4 arguments use curContext, otherwise PImage.get was called\n      if (img !== undefined) {\n        return get$5(x, y, w, h, img);\n      }\n      if (h !== undefined) {\n        return get$4(x, y, w, h);\n      }\n      if (w !== undefined) {\n        return get$3(x, y, w);\n      }\n      if (y !== undefined) {\n        return get$2(x, y);\n      }\n      if (x !== undefined) {\n        // PImage.get() was called, return a new PImage\n        return get$5(0, 0, x.width, x.height, x);\n      }\n\n      return get$4(0, 0, p.width, p.height);\n    };\n\n    /**\n     * Creates and returns a new <b>PGraphics</b> object of the types P2D, P3D, and JAVA2D. Use this class if you need to draw\n     * into an off-screen graphics buffer. It's not possible to use <b>createGraphics()</b> with OPENGL, because it doesn't\n     * allow offscreen use. The DXF and PDF renderers require the filename parameter. <br /><br /> It's important to call\n     * any drawing commands between beginDraw() and endDraw() statements. This is also true for any commands that affect\n     * drawing, such as smooth() or colorMode().<br /><br /> Unlike the main drawing surface which is completely opaque,\n     * surfaces created with createGraphics() can have transparency. This makes it possible to draw into a graphics and\n     * maintain the alpha channel.\n     *\n     * @param {int} width       width in pixels\n     * @param {int} height      height in pixels\n     * @param {int} renderer    Either P2D, P3D, JAVA2D, PDF, DXF\n     * @param {String} filename the name of the file (not supported yet)\n     */\n    p.createGraphics = function(w, h, render) {\n      var pg = new Processing();\n      pg.size(w, h, render);\n      pg.background(0,0);\n      return pg;\n    };\n\n    // pixels caching\n    function resetContext() {\n      if(isContextReplaced) {\n        curContext = originalContext;\n        isContextReplaced = false;\n\n        p.updatePixels();\n      }\n    }\n    function SetPixelContextWrapper() {\n      function wrapFunction(newContext, name) {\n        function wrapper() {\n          resetContext();\n          curContext[name].apply(curContext, arguments);\n        }\n        newContext[name] = wrapper;\n      }\n      function wrapProperty(newContext, name) {\n        function getter() {\n          resetContext();\n          return curContext[name];\n        }\n        function setter(value) {\n          resetContext();\n          curContext[name] = value;\n        }\n        p.defineProperty(newContext, name, { get: getter, set: setter });\n      }\n      for(var n in curContext) {\n        if(typeof curContext[n] === 'function') {\n          wrapFunction(this, n);\n        } else {\n          wrapProperty(this, n);\n        }\n      }\n    }\n    function replaceContext() {\n      if(isContextReplaced) {\n        return;\n      }\n      p.loadPixels();\n      if(proxyContext === null) {\n        originalContext = curContext;\n        proxyContext = new SetPixelContextWrapper();\n      }\n      isContextReplaced = true;\n      curContext = proxyContext;\n      setPixelsCached = 0;\n    }\n\n    function set$3(x, y, c) {\n      if (x < p.width && x >= 0 && y >= 0 && y < p.height) {\n        replaceContext();\n        p.pixels.setPixel((0|x)+p.width*(0|y), c);\n        if(++setPixelsCached > maxPixelsCached) {\n          resetContext();\n        }\n      }\n    }\n    function set$4(x, y, obj, img) {\n      if (img.isRemote) { // Remote images cannot access imageData\n        throw \"Image is loaded remotely. Cannot set x,y.\";\n      }\n      var c = p.color.toArray(obj);\n      var offset = y * img.width * 4 + (x*4);\n      var data = img.imageData.data;\n      data[offset] = c[0];\n      data[offset+1] = c[1];\n      data[offset+2] = c[2];\n      data[offset+3] = c[3];\n    }\n\n    // Paints a pixel array into the canvas\n    /**\n    * Changes the color of any pixel or writes an image directly into the display window. The x and y parameters\n    * specify the pixel to change and the color  parameter specifies the color value. The color parameter is affected\n    * by the current color mode (the default is RGB values from 0 to 255). When setting an image, the x and y\n    * parameters define the coordinates for the upper-left corner of the image.\n    * Setting the color of a single pixel with set(x, y) is easy, but not as fast as putting the data directly\n    * into pixels[]. The equivalent statement to \"set(x, y, #000000)\" using pixels[] is \"pixels[y*width+x] = #000000\".\n    * You must call loadPixels() to load the display window data into the pixels[] array before setting the values\n    * and calling updatePixels() to update the window with any changes. This function ignores imageMode().\n    *\n    * @param {int} x            x-coordinate of the pixel\n    * @param {int} y            y-coordinate of the pixel\n    * @param {Color} obj        any value of the color datatype\n    * @param {PImage} img       any valid variable of type PImage\n    *\n    * @see get\n    * @see pixels[]\n    * @see imageMode\n    */\n    p.set = function(x, y, obj, img) {\n      var color, oldFill;\n      if (arguments.length === 3) {\n        // called p.set(), was it with a color or a img ?\n        if (typeof obj === \"number\") {\n          set$3(x, y, obj);\n        } else if (obj instanceof PImage || obj.__isPImage) {\n          p.image(obj, x, y);\n        }\n      } else if (arguments.length === 4) {\n        // PImage.set(x,y,c) was called, set coordinate x,y color to c of img\n        set$4(x, y, obj, img);\n      }\n    };\n    p.imageData = {};\n\n    // handle the sketch code for pixels[]\n    // parser code converts pixels[] to getPixels() or setPixels(),\n    // .length becomes getLength()\n    /**\n    * Array containing the values for all the pixels in the display window. These values are of the color datatype.\n    * This array is the size of the display window. For example, if the image is 100x100 pixels, there will be 10000\n    * values and if the window is 200x300 pixels, there will be 60000 values. The index value defines the position\n    * of a value within the array. For example, the statment color b = pixels[230] will set the variable b to be\n    * equal to the value at that location in the array.\n    * Before accessing this array, the data must loaded with the loadPixels() function. After the array data has\n    * been modified, the updatePixels() function must be run to update the changes.\n    *\n    * @param {int} index      must not exceed the size of the array\n    *\n    * @see loadPixels\n    * @see updatePixels\n    * @see get\n    * @see set\n    * @see PImage\n    */\n    p.pixels = {\n      getLength: function() { return p.imageData.data.length ? p.imageData.data.length/4 : 0; },\n      getPixel: function(i) {\n        var offset = i*4, data = p.imageData.data;\n        return (data[offset+3] << 24) & 0xff000000 |\n               (data[offset+0] << 16) & 0x00ff0000 |\n               (data[offset+1] << 8) & 0x0000ff00 |\n               data[offset+2] & 0x000000ff;\n      },\n      setPixel: function(i,c) {\n        var offset = i*4, data = p.imageData.data;\n        data[offset+0] = (c & 0x00ff0000) >>> 16; // RED_MASK\n        data[offset+1] = (c & 0x0000ff00) >>> 8;  // GREEN_MASK\n        data[offset+2] = (c & 0x000000ff);        // BLUE_MASK\n        data[offset+3] = (c & 0xff000000) >>> 24; // ALPHA_MASK\n      },\n      toArray: function() {\n        var arr = [], length = p.imageData.width * p.imageData.height, data = p.imageData.data;\n        for (var i = 0, offset = 0; i < length; i++, offset += 4) {\n          arr.push((data[offset+3] << 24) & 0xff000000 |\n                   (data[offset+0] << 16) & 0x00ff0000 |\n                   (data[offset+1] << 8) & 0x0000ff00 |\n                   data[offset+2] & 0x000000ff);\n        }\n        return arr;\n      },\n      set: function(arr) {\n        for (var i = 0, aL = arr.length; i < aL; i++) {\n          this.setPixel(i, arr[i]);\n        }\n      }\n    };\n\n    // Gets a 1-Dimensional pixel array from Canvas\n    /**\n    * Loads the pixel data for the display window into the pixels[] array. This function must always be called\n    * before reading from or writing to pixels[].\n    * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule is that\n    * any time you want to manipulate the pixels[] array, you must first call loadPixels(), and after changes\n    * have been made, call updatePixels(). Even if the renderer may not seem to use this function in the current\n    * Processing release, this will always be subject to change.\n    *\n    * @see pixels[]\n    * @see updatePixels\n    */\n    p.loadPixels = function() {\n      p.imageData = drawing.$ensureContext().getImageData(0, 0, p.width, p.height);\n    };\n\n    // Draws a 1-Dimensional pixel array to Canvas\n    /**\n    * Updates the display window with the data in the pixels[] array. Use in conjunction with loadPixels(). If\n    * you're only reading pixels from the array, there's no need to call updatePixels() unless there are changes.\n    * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule is that\n    * any time you want to manipulate the pixels[] array, you must first call loadPixels(), and after changes\n    * have been made, call updatePixels(). Even if the renderer may not seem to use this function in the current\n    * Processing release, this will always be subject to change.\n    * Currently, none of the renderers use the additional parameters to updatePixels(), however this may be\n    * implemented in the future.\n    *\n    * @see loadPixels\n    * @see pixels[]\n    */\n    p.updatePixels = function() {\n      if (p.imageData) {\n        drawing.$ensureContext().putImageData(p.imageData, 0, 0);\n      }\n    };\n\n    /**\n    * Set various hints and hacks for the renderer. This is used to handle obscure rendering features that cannot be\n    * implemented in a consistent manner across renderers. Many options will often graduate to standard features\n    * instead of hints over time.\n    * hint(ENABLE_OPENGL_4X_SMOOTH) - Enable 4x anti-aliasing for OpenGL. This can help force anti-aliasing if\n    * it has not been enabled by the user. On some graphics cards, this can also be set by the graphics driver's\n    * control panel, however not all cards make this available. This hint must be called immediately after the\n    * size() command because it resets the renderer, obliterating any settings and anything drawn (and like size(),\n    * re-running the code that came before it again).\n    * hint(DISABLE_OPENGL_2X_SMOOTH) - In Processing 1.0, Processing always enables 2x smoothing when the OpenGL\n    * renderer is used. This hint disables the default 2x smoothing and returns the smoothing behavior found in\n    * earlier releases, where smooth() and noSmooth() could be used to enable and disable smoothing, though the\n    * quality was inferior.\n    * hint(ENABLE_NATIVE_FONTS) - Use the native version fonts when they are installed, rather than the bitmapped\n    * version from a .vlw file. This is useful with the JAVA2D renderer setting, as it will improve font rendering\n    * speed. This is not enabled by default, because it can be misleading while testing because the type will look\n    * great on your machine (because you have the font installed) but lousy on others' machines if the identical\n    * font is unavailable. This option can only be set per-sketch, and must be called before any use of textFont().\n    * hint(DISABLE_DEPTH_TEST) - Disable the zbuffer, allowing you to draw on top of everything at will. When depth\n    * testing is disabled, items will be drawn to the screen sequentially, like a painting. This hint is most often\n    * used to draw in 3D, then draw in 2D on top of it (for instance, to draw GUI controls in 2D on top of a 3D\n    * interface). Starting in release 0149, this will also clear the depth buffer. Restore the default with\n    * hint(ENABLE_DEPTH_TEST), but note that with the depth buffer cleared, any 3D drawing that happens later in\n    * draw() will ignore existing shapes on the screen.\n    * hint(ENABLE_DEPTH_SORT) - Enable primitive z-sorting of triangles and lines in P3D and OPENGL. This can slow\n    * performance considerably, and the algorithm is not yet perfect. Restore the default with hint(DISABLE_DEPTH_SORT).\n    * hint(DISABLE_OPENGL_ERROR_REPORT) - Speeds up the OPENGL renderer setting by not checking for errors while\n    * running. Undo with hint(ENABLE_OPENGL_ERROR_REPORT).\n    * As of release 0149, unhint() has been removed in favor of adding additional ENABLE/DISABLE constants to reset\n    * the default behavior. This prevents the double negatives, and also reinforces which hints can be enabled or disabled.\n    *\n    * @param {MODE} item          constant: name of the hint to be enabled or disabled\n    *\n    * @see PGraphics\n    * @see createGraphics\n    * @see size\n    */\n    p.hint = function(which) {\n      var curContext = drawing.$ensureContext();\n      if (which === PConstants.DISABLE_DEPTH_TEST) {\n         curContext.disable(curContext.DEPTH_TEST);\n         curContext.depthMask(false);\n         curContext.clear(curContext.DEPTH_BUFFER_BIT);\n      }\n      else if (which === PConstants.ENABLE_DEPTH_TEST) {\n         curContext.enable(curContext.DEPTH_TEST);\n         curContext.depthMask(true);\n      }\n      else if (which === PConstants.ENABLE_OPENGL_2X_SMOOTH ||\n               which === PConstants.ENABLE_OPENGL_4X_SMOOTH){\n        renderSmooth = true;\n      }\n      else if (which === PConstants.DISABLE_OPENGL_2X_SMOOTH){\n        renderSmooth = false;\n      }\n    };\n\n    /**\n     * The background() function sets the color used for the background of the Processing window.\n     * The default background is light gray. In the <b>draw()</b> function, the background color is used to clear the display window at the beginning of each frame.\n     * An image can also be used as the background for a sketch, however its width and height must be the same size as the sketch window.\n     * To resize an image 'b' to the size of the sketch window, use b.resize(width, height).\n     * Images used as background will ignore the current <b>tint()</b> setting.\n     * For the main drawing surface, the alpha value will be ignored. However,\n     * alpha can be used on PGraphics objects from <b>createGraphics()</b>. This is\n     * the only way to set all the pixels partially transparent, for instance.\n     * If the 'gray' parameter is passed in the function sets the background to a grayscale value, based on the\n     * current colorMode.\n     * <p>\n     * Note that background() should be called before any transformations occur,\n     * because some implementations may require the current transformation matrix\n     * to be identity before drawing.\n     *\n     * @param {int|float} gray    specifies a value between white and black\n     * @param {int|float} value1  red or hue value (depending on the current color mode)\n     * @param {int|float} value2  green or saturation value (depending on the current color mode)\n     * @param {int|float} value3  blue or brightness value (depending on the current color mode)\n     * @param {int|float} alpha   opacity of the background\n     * @param {Color} color       any value of the color datatype\n     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     * @param {PImage} image      an instance of a PImage to use as a background\n     *\n     * @see #stroke()\n     * @see #fill()\n     * @see #tint()\n     * @see #colorMode()\n     */\n    var backgroundHelper = function(arg1, arg2, arg3, arg4) {\n      var obj;\n\n      if (arg1 instanceof PImage || arg1.__isPImage) {\n        obj = arg1;\n\n        if (!obj.loaded) {\n          throw \"Error using image in background(): PImage not loaded.\";\n        }\n        if(obj.width !== p.width || obj.height !== p.height){\n          throw \"Background image must be the same dimensions as the canvas.\";\n        }\n      } else {\n        obj = p.color(arg1, arg2, arg3, arg4);\n      }\n\n      backgroundObj = obj;\n    };\n\n    Drawing2D.prototype.background = function(arg1, arg2, arg3, arg4) {\n      if (arg1 !== undef) {\n        backgroundHelper(arg1, arg2, arg3, arg4);\n      }\n\n      if (backgroundObj instanceof PImage || backgroundObj.__isPImage) {\n        saveContext();\n        curContext.setTransform(1, 0, 0, 1, 0, 0);\n        p.image(backgroundObj, 0, 0);\n        restoreContext();\n      } else {\n        saveContext();\n        curContext.setTransform(1, 0, 0, 1, 0, 0);\n\n        // If the background is transparent\n        if (p.alpha(backgroundObj) !== colorModeA) {\n          curContext.clearRect(0,0, p.width, p.height);\n        }\n        curContext.fillStyle = p.color.toString(backgroundObj);\n        curContext.fillRect(0, 0, p.width, p.height);\n        isFillDirty = true;\n        restoreContext();\n      }\n    };\n\n    Drawing3D.prototype.background = function(arg1, arg2, arg3, arg4) {\n      if (arguments.length > 0) {\n        backgroundHelper(arg1, arg2, arg3, arg4);\n      }\n\n      var c = p.color.toGLArray(backgroundObj);\n      curContext.clearColor(c[0], c[1], c[2], c[3]);\n      curContext.clear(curContext.COLOR_BUFFER_BIT | curContext.DEPTH_BUFFER_BIT);\n\n      // An image as a background in 3D is not implemented yet\n    };\n\n    // Draws an image to the Canvas\n    /**\n    * Displays images to the screen. The images must be in the sketch's \"data\" directory to load correctly. Select \"Add\n    * file...\" from the \"Sketch\" menu to add the image. Processing currently works with GIF, JPEG, and Targa images. The\n    * color of an image may be modified with the tint() function and if a GIF has transparency, it will maintain its\n    * transparency. The img parameter specifies the image to display and the x and y parameters define the location of\n    * the image from its upper-left corner. The image is displayed at its original size unless the width and height\n    * parameters specify a different size. The imageMode() function changes the way the parameters work. A call to\n    * imageMode(CORNERS) will change the width and height parameters to define the x and y values of the opposite\n    * corner of the image.\n    *\n    * @param {PImage} img            the image to display\n    * @param {int|float} x           x-coordinate of the image\n    * @param {int|float} y           y-coordinate of the image\n    * @param {int|float} width       width to display the image\n    * @param {int|float} height      height to display the image\n    *\n    * @see loadImage\n    * @see PImage\n    * @see imageMode\n    * @see tint\n    * @see background\n    * @see alpha\n    */\n    Drawing2D.prototype.image = function(img, x, y, w, h) {\n      // Fix fractional positions\n      x = Math.round(x);\n      y = Math.round(y);\n\n      if (img.width > 0) {\n        var wid = w || img.width;\n        var hgt = h || img.height;\n\n        var bounds = imageModeConvert(x || 0, y || 0, w || img.width, h || img.height, arguments.length < 4);\n        var fastImage = !!img.sourceImg && curTint === null;\n        if (fastImage) {\n          var htmlElement = img.sourceImg;\n          if (img.__isDirty) {\n            img.updatePixels();\n          }\n          // Using HTML element's width and height in case if the image was resized.\n          curContext.drawImage(htmlElement, 0, 0,\n            htmlElement.width, htmlElement.height, bounds.x, bounds.y, bounds.w, bounds.h);\n        } else {\n          var obj = img.toImageData();\n\n          // Tint the image\n          if (curTint !== null) {\n            curTint(obj);\n            img.__isDirty = true;\n          }\n\n          curContext.drawImage(getCanvasData(obj).canvas, 0, 0,\n            img.width, img.height, bounds.x, bounds.y, bounds.w, bounds.h);\n        }\n      }\n    };\n\n    Drawing3D.prototype.image = function(img, x, y, w, h) {\n      if (img.width > 0) {\n        // Fix fractional positions\n        x = Math.round(x);\n        y = Math.round(y);\n        w = w || img.width;\n        h = h || img.height;\n\n        p.beginShape(p.QUADS);\n        p.texture(img);\n        p.vertex(x, y, 0, 0, 0);\n        p.vertex(x, y+h, 0, 0, h);\n        p.vertex(x+w, y+h, 0, w, h);\n        p.vertex(x+w, y, 0, w, 0);\n        p.endShape();\n      }\n    };\n\n    /**\n     * The tint() function sets the fill value for displaying images. Images can be tinted to\n     * specified colors or made transparent by setting the alpha.\n     * <br><br>To make an image transparent, but not change it's color,\n     * use white as the tint color and specify an alpha value. For instance,\n     * tint(255, 128) will make an image 50% transparent (unless\n     * <b>colorMode()</b> has been used).\n     *\n     * <br><br>When using hexadecimal notation to specify a color, use \"#\" or\n     * \"0x\" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six\n     * digits to specify a color (the way colors are specified in HTML and CSS).\n     * When using the hexadecimal notation starting with \"0x\", the hexadecimal\n     * value must be specified with eight characters; the first two characters\n     * define the alpha component and the remainder the red, green, and blue\n     * components.\n     * <br><br>The value for the parameter \"gray\" must be less than or equal\n     * to the current maximum value as specified by <b>colorMode()</b>.\n     * The default maximum value is 255.\n     * <br><br>The tint() method is also used to control the coloring of\n     * textures in 3D.\n     *\n     * @param {int|float} gray    any valid number\n     * @param {int|float} alpha    opacity of the image\n     * @param {int|float} value1  red or hue value\n     * @param {int|float} value2  green or saturation value\n     * @param {int|float} value3  blue or brightness value\n     * @param {int|float} color    any value of the color datatype\n     * @param {int} hex            color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     *\n     * @see #noTint()\n     * @see #image()\n     */\n    p.tint = function(a1, a2, a3, a4) {\n      var tintColor = p.color(a1, a2, a3, a4);\n      var r = p.red(tintColor) / colorModeX;\n      var g = p.green(tintColor) / colorModeY;\n      var b = p.blue(tintColor) / colorModeZ;\n      var a = p.alpha(tintColor) / colorModeA;\n      curTint = function(obj) {\n        var data = obj.data,\n            length = 4 * obj.width * obj.height;\n        for (var i = 0; i < length;) {\n          data[i++] *= r;\n          data[i++] *= g;\n          data[i++] *= b;\n          data[i++] *= a;\n        }\n      };\n      // for overriding the color buffer when 3d rendering\n      curTint3d = function(data){\n        for (var i = 0; i < data.length;) {\n          data[i++] = r;\n          data[i++] = g;\n          data[i++] = b;\n          data[i++] = a;\n        }\n      };\n    };\n\n    /**\n     * The noTint() function removes the current fill value for displaying images and reverts to displaying images with their original hues.\n     *\n     * @see #tint()\n     * @see #image()\n     */\n    p.noTint = function() {\n      curTint = null;\n      curTint3d = null;\n    };\n\n    /**\n    * Copies a region of pixels from the display window to another area of the display window and copies a region of pixels from an\n    * image used as the srcImg  parameter into the display window. If the source and destination regions aren't the same size, it will\n    * automatically resize the source pixels to fit the specified target region. No alpha information is used in the process, however\n    * if the source image has an alpha channel set, it will be copied as well. This function ignores imageMode().\n    *\n    * @param {int} x            X coordinate of the source's upper left corner\n    * @param {int} y            Y coordinate of the source's upper left corner\n    * @param {int} width        source image width\n    * @param {int} height       source image height\n    * @param {int} dx           X coordinate of the destination's upper left corner\n    * @param {int} dy           Y coordinate of the destination's upper left corner\n    * @param {int} dwidth       destination image width\n    * @param {int} dheight      destination image height\n    * @param {PImage} srcImg    image variable referring to the source image\n    *\n    * @see blend\n    * @see get\n    */\n    p.copy = function(src, sx, sy, sw, sh, dx, dy, dw, dh) {\n      if (dh === undef) {\n        // shift everything, and introduce p\n        dh = dw;\n        dw = dy;\n        dy = dx;\n        dx = sh;\n        sh = sw;\n        sw = sy;\n        sy = sx;\n        sx = src;\n        src = p;\n      }\n      p.blend(src, sx, sy, sw, sh, dx, dy, dw, dh, PConstants.REPLACE);\n    };\n\n    /**\n    * Blends a region of pixels from one image into another (or in itself again) with full alpha channel support. There\n    * is a choice of the following modes to blend the source pixels (A) with the ones of pixels in the destination image (B):\n    * BLEND - linear interpolation of colours: C = A*factor + B\n    * ADD - additive blending with white clip: C = min(A*factor + B, 255)\n    * SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n    * DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n    * LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n    * DIFFERENCE - subtract colors from underlying image.\n    * EXCLUSION - similar to DIFFERENCE, but less extreme.\n    * MULTIPLY - Multiply the colors, result will always be darker.\n    * SCREEN - Opposite multiply, uses inverse values of the colors.\n    * OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values, and screens light values.\n    * HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n    * SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.\n    * DODGE - Lightens light tones and increases contrast, ignores darks. Called \"Color Dodge\" in Illustrator and Photoshop.\n    * BURN - Darker areas are applied, increasing contrast, ignores lights. Called \"Color Burn\" in Illustrator and Photoshop.\n    * All modes use the alpha information (highest byte) of source image pixels as the blending factor. If the source and\n    * destination regions are different sizes, the image will be automatically resized to match the destination size. If the\n    * srcImg parameter is not used, the display window is used as the source image.  This function ignores imageMode().\n    *\n    * @param {int} x            X coordinate of the source's upper left corner\n    * @param {int} y            Y coordinate of the source's upper left corner\n    * @param {int} width        source image width\n    * @param {int} height       source image height\n    * @param {int} dx           X coordinate of the destination's upper left corner\n    * @param {int} dy           Y coordinate of the destination's upper left corner\n    * @param {int} dwidth       destination image width\n    * @param {int} dheight      destination image height\n    * @param {PImage} srcImg    image variable referring to the source image\n    * @param {PImage} MODE      Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION, MULTIPLY, SCREEN,\n    *                           OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN\n    * @see filter\n    */\n    p.blend = function(src, sx, sy, sw, sh, dx, dy, dw, dh, mode, pimgdest) {\n      if (src.isRemote) {\n        throw \"Image is loaded remotely. Cannot blend image.\";\n      }\n\n      if (mode === undef) {\n        // shift everything, and introduce p\n        mode = dh;\n        dh = dw;\n        dw = dy;\n        dy = dx;\n        dx = sh;\n        sh = sw;\n        sw = sy;\n        sy = sx;\n        sx = src;\n        src = p;\n      }\n\n      var sx2 = sx + sw,\n        sy2 = sy + sh,\n        dx2 = dx + dw,\n        dy2 = dy + dh,\n        dest = pimgdest || p;\n\n      // check if pimgdest is there and pixels, if so this was a call from pimg.blend\n      if (pimgdest === undef || mode === undef) {\n        p.loadPixels();\n      }\n\n      src.loadPixels();\n\n      if (src === p && p.intersect(sx, sy, sx2, sy2, dx, dy, dx2, dy2)) {\n        p.blit_resize(p.get(sx, sy, sx2 - sx, sy2 - sy), 0, 0, sx2 - sx - 1, sy2 - sy - 1,\n                      dest.imageData.data, dest.width, dest.height, dx, dy, dx2, dy2, mode);\n      } else {\n        p.blit_resize(src, sx, sy, sx2, sy2, dest.imageData.data, dest.width, dest.height, dx, dy, dx2, dy2, mode);\n      }\n\n      if (pimgdest === undef) {\n        p.updatePixels();\n      }\n    };\n\n    // helper function for filter()\n    var buildBlurKernel = function(r) {\n      var radius = p.floor(r * 3.5), i, radiusi;\n      radius = (radius < 1) ? 1 : ((radius < 248) ? radius : 248);\n      if (p.shared.blurRadius !== radius) {\n        p.shared.blurRadius = radius;\n        p.shared.blurKernelSize = 1 + (p.shared.blurRadius<<1);\n        p.shared.blurKernel = new Float32Array(p.shared.blurKernelSize);\n        var sharedBlurKernal = p.shared.blurKernel;\n        var sharedBlurKernelSize = p.shared.blurKernelSize;\n        var sharedBlurRadius = p.shared.blurRadius;\n        // init blurKernel\n        for (i = 0; i < sharedBlurKernelSize; i++) {\n          sharedBlurKernal[i] = 0;\n        }\n        var radiusiSquared = (radius - 1) * (radius - 1);\n        for (i = 1; i < radius; i++) {\n          sharedBlurKernal[radius + i] = sharedBlurKernal[radiusi] = radiusiSquared;\n        }\n        sharedBlurKernal[radius] = radius * radius;\n      }\n    };\n\n    var blurARGB = function(r, aImg) {\n      var sum, cr, cg, cb, ca, c, m;\n      var read, ri, ym, ymi, bk0;\n      var wh = aImg.pixels.getLength();\n      var r2 = new Float32Array(wh);\n      var g2 = new Float32Array(wh);\n      var b2 = new Float32Array(wh);\n      var a2 = new Float32Array(wh);\n      var yi = 0;\n      var x, y, i, offset;\n\n      buildBlurKernel(r);\n\n      var aImgHeight = aImg.height;\n      var aImgWidth = aImg.width;\n      var sharedBlurKernelSize = p.shared.blurKernelSize;\n      var sharedBlurRadius = p.shared.blurRadius;\n      var sharedBlurKernal = p.shared.blurKernel;\n      var pix = aImg.imageData.data;\n\n      for (y = 0; y < aImgHeight; y++) {\n        for (x = 0; x < aImgWidth; x++) {\n          cb = cg = cr = ca = sum = 0;\n          read = x - sharedBlurRadius;\n          if (read<0) {\n            bk0 = -read;\n            read = 0;\n          } else {\n            if (read >= aImgWidth) {\n              break;\n            }\n            bk0=0;\n          }\n          for (i = bk0; i < sharedBlurKernelSize; i++) {\n            if (read >= aImgWidth) {\n              break;\n            }\n            offset = (read + yi) *4;\n            m = sharedBlurKernal[i];\n            ca += m * pix[offset + 3];\n            cr += m * pix[offset];\n            cg += m * pix[offset + 1];\n            cb += m * pix[offset + 2];\n            sum += m;\n            read++;\n          }\n          ri = yi + x;\n          a2[ri] = ca / sum;\n          r2[ri] = cr / sum;\n          g2[ri] = cg / sum;\n          b2[ri] = cb / sum;\n        }\n        yi += aImgWidth;\n      }\n\n      yi = 0;\n      ym = -sharedBlurRadius;\n      ymi = ym*aImgWidth;\n\n      for (y = 0; y < aImgHeight; y++) {\n        for (x = 0; x < aImgWidth; x++) {\n          cb = cg = cr = ca = sum = 0;\n          if (ym<0) {\n            bk0 = ri = -ym;\n            read = x;\n          } else {\n            if (ym >= aImgHeight) {\n              break;\n            }\n            bk0 = 0;\n            ri = ym;\n            read = x + ymi;\n          }\n          for (i = bk0; i < sharedBlurKernelSize; i++) {\n            if (ri >= aImgHeight) {\n              break;\n            }\n            m = sharedBlurKernal[i];\n            ca += m * a2[read];\n            cr += m * r2[read];\n            cg += m * g2[read];\n            cb += m * b2[read];\n            sum += m;\n            ri++;\n            read += aImgWidth;\n          }\n          offset = (x + yi) *4;\n          pix[offset] = cr / sum;\n          pix[offset + 1] = cg / sum;\n          pix[offset + 2] = cb / sum;\n          pix[offset + 3] = ca / sum;\n        }\n        yi += aImgWidth;\n        ymi += aImgWidth;\n        ym++;\n      }\n    };\n\n    // helper funtion for ERODE and DILATE modes of filter()\n    var dilate = function(isInverted, aImg) {\n      var currIdx = 0;\n      var maxIdx = aImg.pixels.getLength();\n      var out = new Int32Array(maxIdx);\n      var currRowIdx, maxRowIdx, colOrig, colOut, currLum;\n      var idxRight, idxLeft, idxUp, idxDown,\n          colRight, colLeft, colUp, colDown,\n          lumRight, lumLeft, lumUp, lumDown;\n\n      if (!isInverted) {\n        // erosion (grow light areas)\n        while (currIdx<maxIdx) {\n          currRowIdx = currIdx;\n          maxRowIdx = currIdx + aImg.width;\n          while (currIdx < maxRowIdx) {\n            colOrig = colOut = aImg.pixels.getPixel(currIdx);\n            idxLeft = currIdx - 1;\n            idxRight = currIdx + 1;\n            idxUp = currIdx - aImg.width;\n            idxDown = currIdx + aImg.width;\n            if (idxLeft < currRowIdx) {\n              idxLeft = currIdx;\n            }\n            if (idxRight >= maxRowIdx) {\n              idxRight = currIdx;\n            }\n            if (idxUp < 0) {\n              idxUp = 0;\n            }\n            if (idxDown >= maxIdx) {\n              idxDown = currIdx;\n            }\n            colUp = aImg.pixels.getPixel(idxUp);\n            colLeft = aImg.pixels.getPixel(idxLeft);\n            colDown = aImg.pixels.getPixel(idxDown);\n            colRight = aImg.pixels.getPixel(idxRight);\n\n            // compute luminance\n            currLum = 77*(colOrig>>16&0xff) + 151*(colOrig>>8&0xff) + 28*(colOrig&0xff);\n            lumLeft = 77*(colLeft>>16&0xff) + 151*(colLeft>>8&0xff) + 28*(colLeft&0xff);\n            lumRight = 77*(colRight>>16&0xff) + 151*(colRight>>8&0xff) + 28*(colRight&0xff);\n            lumUp = 77*(colUp>>16&0xff) + 151*(colUp>>8&0xff) + 28*(colUp&0xff);\n            lumDown = 77*(colDown>>16&0xff) + 151*(colDown>>8&0xff) + 28*(colDown&0xff);\n\n            if (lumLeft > currLum) {\n              colOut = colLeft;\n              currLum = lumLeft;\n            }\n            if (lumRight > currLum) {\n              colOut = colRight;\n              currLum = lumRight;\n            }\n            if (lumUp > currLum) {\n              colOut = colUp;\n              currLum = lumUp;\n            }\n            if (lumDown > currLum) {\n              colOut = colDown;\n              currLum = lumDown;\n            }\n            out[currIdx++] = colOut;\n          }\n        }\n      } else {\n        // dilate (grow dark areas)\n        while (currIdx < maxIdx) {\n          currRowIdx = currIdx;\n          maxRowIdx = currIdx + aImg.width;\n          while (currIdx < maxRowIdx) {\n            colOrig = colOut = aImg.pixels.getPixel(currIdx);\n            idxLeft = currIdx - 1;\n            idxRight = currIdx + 1;\n            idxUp = currIdx - aImg.width;\n            idxDown = currIdx + aImg.width;\n            if (idxLeft < currRowIdx) {\n              idxLeft = currIdx;\n            }\n            if (idxRight >= maxRowIdx) {\n              idxRight = currIdx;\n            }\n            if (idxUp < 0) {\n              idxUp = 0;\n            }\n            if (idxDown >= maxIdx) {\n              idxDown = currIdx;\n            }\n            colUp = aImg.pixels.getPixel(idxUp);\n            colLeft = aImg.pixels.getPixel(idxLeft);\n            colDown = aImg.pixels.getPixel(idxDown);\n            colRight = aImg.pixels.getPixel(idxRight);\n\n            // compute luminance\n            currLum = 77*(colOrig>>16&0xff) + 151*(colOrig>>8&0xff) + 28*(colOrig&0xff);\n            lumLeft = 77*(colLeft>>16&0xff) + 151*(colLeft>>8&0xff) + 28*(colLeft&0xff);\n            lumRight = 77*(colRight>>16&0xff) + 151*(colRight>>8&0xff) + 28*(colRight&0xff);\n            lumUp = 77*(colUp>>16&0xff) + 151*(colUp>>8&0xff) + 28*(colUp&0xff);\n            lumDown = 77*(colDown>>16&0xff) + 151*(colDown>>8&0xff) + 28*(colDown&0xff);\n\n            if (lumLeft < currLum) {\n              colOut = colLeft;\n              currLum = lumLeft;\n            }\n            if (lumRight < currLum) {\n              colOut = colRight;\n              currLum = lumRight;\n            }\n            if (lumUp < currLum) {\n              colOut = colUp;\n              currLum = lumUp;\n            }\n            if (lumDown < currLum) {\n              colOut = colDown;\n              currLum = lumDown;\n            }\n            out[currIdx++]=colOut;\n          }\n        }\n      }\n      aImg.pixels.set(out);\n      //p.arraycopy(out,0,pixels,0,maxIdx);\n    };\n\n    /**\n    * Filters the display window as defined by one of the following modes:\n    * THRESHOLD - converts the image to black and white pixels depending if they are above or below the threshold\n    * defined by the level parameter. The level must be between 0.0 (black) and 1.0(white). If no level is specified, 0.5 is used.\n    * GRAY - converts any colors in the image to grayscale equivalents\n    * INVERT - sets each pixel to its inverse value\n    * POSTERIZE - limits each channel of the image to the number of colors specified as the level parameter\n    * BLUR - executes a Guassian blur with the level parameter specifying the extent of the blurring. If no level parameter is\n    * used, the blur is equivalent to Guassian blur of radius 1.\n    * OPAQUE - sets the alpha channel to entirely opaque.\n    * ERODE - reduces the light areas with the amount defined by the level parameter.\n    * DILATE - increases the light areas with the amount defined by the level parameter.\n    *\n    * @param {MODE} MODE          Either THRESHOLD, GRAY, INVERT, POSTERIZE, BLUR, OPAQUE, ERODE, or DILATE\n    * @param {int|float} level    defines the quality of the filter\n    *\n    * @see blend\n    */\n    p.filter = function(kind, param, aImg){\n      var img, col, lum, i;\n\n      if (arguments.length === 3) {\n        aImg.loadPixels();\n        img = aImg;\n      } else {\n        p.loadPixels();\n        img = p;\n      }\n\n      if (param === undef) {\n        param = null;\n      }\n      if (img.isRemote) { // Remote images cannot access imageData\n        throw \"Image is loaded remotely. Cannot filter image.\";\n      }\n      // begin filter process\n      var imglen = img.pixels.getLength();\n      switch (kind) {\n        case PConstants.BLUR:\n          var radius = param || 1; // if no param specified, use 1 (default for p5)\n          blurARGB(radius, img);\n          break;\n\n        case PConstants.GRAY:\n          if (img.format === PConstants.ALPHA) { //trouble\n            // for an alpha image, convert it to an opaque grayscale\n            for (i = 0; i < imglen; i++) {\n              col = 255 - img.pixels.getPixel(i);\n              img.pixels.setPixel(i,(0xff000000 | (col << 16) | (col << 8) | col));\n            }\n            img.format = PConstants.RGB; //trouble\n          } else {\n            for (i = 0; i < imglen; i++) {\n              col = img.pixels.getPixel(i);\n              lum = (77*(col>>16&0xff) + 151*(col>>8&0xff) + 28*(col&0xff))>>8;\n              img.pixels.setPixel(i,((col & PConstants.ALPHA_MASK) | lum<<16 | lum<<8 | lum));\n            }\n          }\n          break;\n\n        case PConstants.INVERT:\n          for (i = 0; i < imglen; i++) {\n            img.pixels.setPixel(i, (img.pixels.getPixel(i) ^ 0xffffff));\n          }\n          break;\n\n        case PConstants.POSTERIZE:\n          if (param === null) {\n            throw \"Use filter(POSTERIZE, int levels) instead of filter(POSTERIZE)\";\n          }\n          var levels = p.floor(param);\n          if ((levels < 2) || (levels > 255)) {\n            throw \"Levels must be between 2 and 255 for filter(POSTERIZE, levels)\";\n          }\n          var levels1 = levels - 1;\n          for (i = 0; i < imglen; i++) {\n            var rlevel = (img.pixels.getPixel(i) >> 16) & 0xff;\n            var glevel = (img.pixels.getPixel(i) >> 8) & 0xff;\n            var blevel = img.pixels.getPixel(i) & 0xff;\n            rlevel = (((rlevel * levels) >> 8) * 255) / levels1;\n            glevel = (((glevel * levels) >> 8) * 255) / levels1;\n            blevel = (((blevel * levels) >> 8) * 255) / levels1;\n            img.pixels.setPixel(i, ((0xff000000 & img.pixels.getPixel(i)) | (rlevel << 16) | (glevel << 8) | blevel));\n          }\n          break;\n\n        case PConstants.OPAQUE:\n          for (i = 0; i < imglen; i++) {\n            img.pixels.setPixel(i, (img.pixels.getPixel(i) | 0xff000000));\n          }\n          img.format = PConstants.RGB; //trouble\n          break;\n\n        case PConstants.THRESHOLD:\n          if (param === null) {\n            param = 0.5;\n          }\n          if ((param < 0) || (param > 1)) {\n            throw \"Level must be between 0 and 1 for filter(THRESHOLD, level)\";\n          }\n          var thresh = p.floor(param * 255);\n          for (i = 0; i < imglen; i++) {\n            var max = p.max((img.pixels.getPixel(i) & PConstants.RED_MASK) >> 16, p.max((img.pixels.getPixel(i) & PConstants.GREEN_MASK) >> 8, (img.pixels.getPixel(i) & PConstants.BLUE_MASK)));\n            img.pixels.setPixel(i, ((img.pixels.getPixel(i) & PConstants.ALPHA_MASK) | ((max < thresh) ? 0x000000 : 0xffffff)));\n          }\n          break;\n\n        case PConstants.ERODE:\n          dilate(true, img);\n          break;\n\n        case PConstants.DILATE:\n          dilate(false, img);\n          break;\n      }\n      img.updatePixels();\n    };\n\n\n    // shared variables for blit_resize(), filter_new_scanline(), filter_bilinear(), filter()\n    // change this in the future to not be exposed to p\n    p.shared = {\n      fracU: 0,\n      ifU: 0,\n      fracV: 0,\n      ifV: 0,\n      u1: 0,\n      u2: 0,\n      v1: 0,\n      v2: 0,\n      sX: 0,\n      sY: 0,\n      iw: 0,\n      iw1: 0,\n      ih1: 0,\n      ul: 0,\n      ll: 0,\n      ur: 0,\n      lr: 0,\n      cUL: 0,\n      cLL: 0,\n      cUR: 0,\n      cLR: 0,\n      srcXOffset: 0,\n      srcYOffset: 0,\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 0,\n      srcBuffer: null,\n      blurRadius: 0,\n      blurKernelSize: 0,\n      blurKernel: null\n    };\n\n    p.intersect = function(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2) {\n      var sw = sx2 - sx1 + 1;\n      var sh = sy2 - sy1 + 1;\n      var dw = dx2 - dx1 + 1;\n      var dh = dy2 - dy1 + 1;\n      if (dx1 < sx1) {\n        dw += dx1 - sx1;\n        if (dw > sw) {\n          dw = sw;\n        }\n      } else {\n        var w = sw + sx1 - dx1;\n        if (dw > w) {\n          dw = w;\n        }\n      }\n      if (dy1 < sy1) {\n        dh += dy1 - sy1;\n        if (dh > sh) {\n          dh = sh;\n        }\n      } else {\n        var h = sh + sy1 - dy1;\n        if (dh > h) {\n          dh = h;\n        }\n      }\n      return ! (dw <= 0 || dh <= 0);\n    };\n\n    var blendFuncs = {};\n    blendFuncs[PConstants.BLEND] = p.modes.blend;\n    blendFuncs[PConstants.ADD] = p.modes.add;\n    blendFuncs[PConstants.SUBTRACT] = p.modes.subtract;\n    blendFuncs[PConstants.LIGHTEST] = p.modes.lightest;\n    blendFuncs[PConstants.DARKEST] = p.modes.darkest;\n    blendFuncs[PConstants.REPLACE] = p.modes.replace;\n    blendFuncs[PConstants.DIFFERENCE] = p.modes.difference;\n    blendFuncs[PConstants.EXCLUSION] = p.modes.exclusion;\n    blendFuncs[PConstants.MULTIPLY] = p.modes.multiply;\n    blendFuncs[PConstants.SCREEN] = p.modes.screen;\n    blendFuncs[PConstants.OVERLAY] = p.modes.overlay;\n    blendFuncs[PConstants.HARD_LIGHT] = p.modes.hard_light;\n    blendFuncs[PConstants.SOFT_LIGHT] = p.modes.soft_light;\n    blendFuncs[PConstants.DODGE] = p.modes.dodge;\n    blendFuncs[PConstants.BURN] = p.modes.burn;\n\n    p.blit_resize = function(img, srcX1, srcY1, srcX2, srcY2, destPixels,\n                             screenW, screenH, destX1, destY1, destX2, destY2, mode) {\n      var x, y;\n      if (srcX1 < 0) {\n        srcX1 = 0;\n      }\n      if (srcY1 < 0) {\n        srcY1 = 0;\n      }\n      if (srcX2 >= img.width) {\n        srcX2 = img.width - 1;\n      }\n      if (srcY2 >= img.height) {\n        srcY2 = img.height - 1;\n      }\n      var srcW = srcX2 - srcX1;\n      var srcH = srcY2 - srcY1;\n      var destW = destX2 - destX1;\n      var destH = destY2 - destY1;\n\n      if (destW <= 0 || destH <= 0 || srcW <= 0 || srcH <= 0 || destX1 >= screenW ||\n          destY1 >= screenH || srcX1 >= img.width || srcY1 >= img.height) {\n        return;\n      }\n\n      var dx = Math.floor(srcW / destW * PConstants.PRECISIONF);\n      var dy = Math.floor(srcH / destH * PConstants.PRECISIONF);\n\n      var pshared = p.shared;\n\n      pshared.srcXOffset = Math.floor(destX1 < 0 ? -destX1 * dx : srcX1 * PConstants.PRECISIONF);\n      pshared.srcYOffset = Math.floor(destY1 < 0 ? -destY1 * dy : srcY1 * PConstants.PRECISIONF);\n      if (destX1 < 0) {\n        destW += destX1;\n        destX1 = 0;\n      }\n      if (destY1 < 0) {\n        destH += destY1;\n        destY1 = 0;\n      }\n      destW = Math.min(destW, screenW - destX1);\n      destH = Math.min(destH, screenH - destY1);\n\n      var destOffset = destY1 * screenW + destX1;\n      var destColor;\n\n      pshared.srcBuffer = img.imageData.data;\n      pshared.iw = img.width;\n      pshared.iw1 = img.width - 1;\n      pshared.ih1 = img.height - 1;\n\n      // cache for speed\n      var filterBilinear = p.filter_bilinear,\n        filterNewScanline = p.filter_new_scanline,\n        blendFunc = blendFuncs[mode],\n        blendedColor,\n        idx,\n        cULoffset,\n        cURoffset,\n        cLLoffset,\n        cLRoffset,\n        ALPHA_MASK = PConstants.ALPHA_MASK,\n        RED_MASK = PConstants.RED_MASK,\n        GREEN_MASK = PConstants.GREEN_MASK,\n        BLUE_MASK = PConstants.BLUE_MASK,\n        PREC_MAXVAL = PConstants.PREC_MAXVAL,\n        PRECISIONB = PConstants.PRECISIONB,\n        PREC_RED_SHIFT = PConstants.PREC_RED_SHIFT,\n        PREC_ALPHA_SHIFT = PConstants.PREC_ALPHA_SHIFT,\n        srcBuffer = pshared.srcBuffer,\n        min = Math.min;\n\n      for (y = 0; y < destH; y++) {\n\n        pshared.sX = pshared.srcXOffset;\n        pshared.fracV = pshared.srcYOffset & PREC_MAXVAL;\n        pshared.ifV = PREC_MAXVAL - pshared.fracV;\n        pshared.v1 = (pshared.srcYOffset >> PRECISIONB) * pshared.iw;\n        pshared.v2 = min((pshared.srcYOffset >> PRECISIONB) + 1, pshared.ih1) * pshared.iw;\n\n        for (x = 0; x < destW; x++) {\n          idx = (destOffset + x) * 4;\n\n          destColor = (destPixels[idx + 3] << 24) &\n                      ALPHA_MASK | (destPixels[idx] << 16) &\n                      RED_MASK   | (destPixels[idx + 1] << 8) &\n                      GREEN_MASK |  destPixels[idx + 2] & BLUE_MASK;\n\n          pshared.fracU = pshared.sX & PREC_MAXVAL;\n          pshared.ifU = PREC_MAXVAL - pshared.fracU;\n          pshared.ul = (pshared.ifU * pshared.ifV) >> PRECISIONB;\n          pshared.ll = (pshared.ifU * pshared.fracV) >> PRECISIONB;\n          pshared.ur = (pshared.fracU * pshared.ifV) >> PRECISIONB;\n          pshared.lr = (pshared.fracU * pshared.fracV) >> PRECISIONB;\n          pshared.u1 = (pshared.sX >> PRECISIONB);\n          pshared.u2 = min(pshared.u1 + 1, pshared.iw1);\n\n          cULoffset = (pshared.v1 + pshared.u1) * 4;\n          cURoffset = (pshared.v1 + pshared.u2) * 4;\n          cLLoffset = (pshared.v2 + pshared.u1) * 4;\n          cLRoffset = (pshared.v2 + pshared.u2) * 4;\n\n          pshared.cUL = (srcBuffer[cULoffset + 3] << 24) &\n                        ALPHA_MASK | (srcBuffer[cULoffset] << 16) &\n                        RED_MASK   | (srcBuffer[cULoffset + 1] << 8) &\n                        GREEN_MASK |  srcBuffer[cULoffset + 2] & BLUE_MASK;\n\n          pshared.cUR = (srcBuffer[cURoffset + 3] << 24) &\n                        ALPHA_MASK | (srcBuffer[cURoffset] << 16) &\n                        RED_MASK   | (srcBuffer[cURoffset + 1] << 8) &\n                        GREEN_MASK |  srcBuffer[cURoffset + 2] & BLUE_MASK;\n\n          pshared.cLL = (srcBuffer[cLLoffset + 3] << 24) &\n                        ALPHA_MASK | (srcBuffer[cLLoffset] << 16) &\n                        RED_MASK   | (srcBuffer[cLLoffset + 1] << 8) &\n                        GREEN_MASK |  srcBuffer[cLLoffset + 2] & BLUE_MASK;\n\n          pshared.cLR = (srcBuffer[cLRoffset + 3] << 24) &\n                        ALPHA_MASK | (srcBuffer[cLRoffset] << 16) &\n                        RED_MASK   | (srcBuffer[cLRoffset + 1] << 8) &\n                        GREEN_MASK |  srcBuffer[cLRoffset + 2] & BLUE_MASK;\n\n          pshared.r = ((pshared.ul * ((pshared.cUL & RED_MASK) >> 16) +\n                       pshared.ll * ((pshared.cLL & RED_MASK) >> 16) +\n                       pshared.ur * ((pshared.cUR & RED_MASK) >> 16) +\n                       pshared.lr * ((pshared.cLR & RED_MASK) >> 16)) << PREC_RED_SHIFT) & RED_MASK;\n          pshared.g = ((pshared.ul * (pshared.cUL & GREEN_MASK) +\n                       pshared.ll * (pshared.cLL & GREEN_MASK) +\n                       pshared.ur * (pshared.cUR & GREEN_MASK) +\n                       pshared.lr * (pshared.cLR & GREEN_MASK)) >>> PRECISIONB) & GREEN_MASK;\n          pshared.b = (pshared.ul * (pshared.cUL & BLUE_MASK) +\n                       pshared.ll * (pshared.cLL & BLUE_MASK) +\n                       pshared.ur * (pshared.cUR & BLUE_MASK) +\n                       pshared.lr * (pshared.cLR & BLUE_MASK)) >>> PRECISIONB;\n          pshared.a = ((pshared.ul * ((pshared.cUL & ALPHA_MASK) >>> 24) +\n                       pshared.ll * ((pshared.cLL & ALPHA_MASK) >>> 24) +\n                       pshared.ur * ((pshared.cUR & ALPHA_MASK) >>> 24) +\n                       pshared.lr * ((pshared.cLR & ALPHA_MASK) >>> 24)) << PREC_ALPHA_SHIFT) & ALPHA_MASK;\n\n          blendedColor = blendFunc(destColor, (pshared.a | pshared.r | pshared.g | pshared.b));\n\n          destPixels[idx]     = (blendedColor & RED_MASK) >>> 16;\n          destPixels[idx + 1] = (blendedColor & GREEN_MASK) >>> 8;\n          destPixels[idx + 2] = (blendedColor & BLUE_MASK);\n          destPixels[idx + 3] = (blendedColor & ALPHA_MASK) >>> 24;\n\n          pshared.sX += dx;\n        }\n        destOffset += screenW;\n        pshared.srcYOffset += dy;\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Font handling\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * loadFont() Loads a font into a variable of type PFont.\n     *\n     * @param {String} name filename of the font to load\n     * @param {int|float} size option font size (used internally)\n     *\n     * @returns {PFont} new PFont object\n     *\n     * @see #PFont\n     * @see #textFont\n     * @see #text\n     * @see #createFont\n     */\n    p.loadFont = function(name, size) {\n      if (name === undef) {\n        throw(\"font name required in loadFont.\");\n      }\n      if (name.indexOf(\".svg\") === -1) {\n        if (size === undef) {\n          size = curTextFont.size;\n        }\n        return PFont.get(name, size);\n      }\n      // If the font is a glyph, calculate by SVG table\n      var font = p.loadGlyphs(name);\n\n      return {\n        name: name,\n        css: '12px sans-serif',\n        glyph: true,\n        units_per_em: font.units_per_em,\n        horiz_adv_x: 1 / font.units_per_em * font.horiz_adv_x,\n        ascent: font.ascent,\n        descent: font.descent,\n        width: function(str) {\n          var width = 0;\n          var len = str.length;\n          for (var i = 0; i < len; i++) {\n            try {\n              width += parseFloat(p.glyphLook(p.glyphTable[name], str[i]).horiz_adv_x);\n            }\n            catch(e) {\n              Processing.debug(e);\n            }\n          }\n          return width / p.glyphTable[name].units_per_em;\n        }\n      };\n    };\n\n    /**\n     * createFont() Loads a font into a variable of type PFont.\n     * Smooth and charset are ignored in Processing.js.\n     *\n     * @param {String}    name    filename of the font to load\n     * @param {int|float} size    font size in pixels\n     * @param {boolean}   smooth  not used in Processing.js\n     * @param {char[]}    charset not used in Processing.js\n     *\n     * @returns {PFont} new PFont object\n     *\n     * @see #PFont\n     * @see #textFont\n     * @see #text\n     * @see #loadFont\n     */\n    p.createFont = function(name, size) {\n      // because Processing.js only deals with real fonts,\n      // createFont is simply a wrapper for loadFont/2\n      return p.loadFont(name, size);\n    };\n\n    /**\n     * textFont() Sets the current font.\n     *\n     * @param {PFont}     pfont the PFont to load as current text font\n     * @param {int|float} size optional font size in pixels\n     *\n     * @see #createFont\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     */\n    p.textFont = function(pfont, size) {\n      if (size !== undef) {\n        // If we're using an SVG glyph font, don't load from cache\n        if (!pfont.glyph) {\n          pfont = PFont.get(pfont.name, size);\n        }\n        curTextSize = size;\n      }\n      curTextFont = pfont;\n      curFontName = curTextFont.name;\n      curTextAscent = curTextFont.ascent;\n      curTextDescent = curTextFont.descent;\n      curTextLeading = curTextFont.leading;\n      var curContext = drawing.$ensureContext();\n      curContext.font = curTextFont.css;\n    };\n\n    /**\n     * textSize() Sets the current font size in pixels.\n     *\n     * @param {int|float} size font size in pixels\n     *\n     * @see #textFont\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     */\n    p.textSize = function(size) {\n      curTextFont = PFont.get(curFontName, size);\n      curTextSize = size;\n      // recache metrics\n      curTextAscent = curTextFont.ascent;\n      curTextDescent = curTextFont.descent;\n      curTextLeading = curTextFont.leading;\n      var curContext = drawing.$ensureContext();\n      curContext.font = curTextFont.css;\n    };\n\n    /**\n     * textAscent() returns the maximum height a character extends above the baseline of the\n     * current font at its current size, in pixels.\n     *\n     * @returns {float} height of the current font above the baseline, at its current size, in pixels\n     *\n     * @see #textDescent\n     */\n    p.textAscent = function() {\n      return curTextAscent;\n    };\n\n    /**\n     * textDescent() returns the maximum depth a character will protrude below the baseline of\n     * the current font at its current size, in pixels.\n     *\n     * @returns {float} depth of the current font below the baseline, at its current size, in pixels\n     *\n     * @see #textAscent\n     */\n    p.textDescent = function() {\n      return curTextDescent;\n    };\n\n    /**\n     * textLeading() Sets the current font's leading, which is the distance\n     * from baseline to baseline over consecutive lines, with additional vertical\n     * spacing taking into account. Usually this value is 1.2 or 1.25 times the\n     * textsize, but this value can be changed to effect vertically compressed\n     * or stretched text.\n     *\n     * @param {int|float} the desired baseline-to-baseline size in pixels\n     */\n    p.textLeading = function(leading) {\n      curTextLeading = leading;\n    };\n\n    /**\n     * textAlign() Sets the current alignment for drawing text.\n     *\n     * @param {int} ALIGN  Horizontal alignment, either LEFT, CENTER, or RIGHT\n     * @param {int} YALIGN optional vertical alignment, either TOP, BOTTOM, CENTER, or BASELINE\n     *\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     */\n    p.textAlign = function(xalign, yalign) {\n      horizontalTextAlignment = xalign;\n      verticalTextAlignment = yalign || PConstants.BASELINE;\n    };\n\n    /**\n     * toP5String converts things with arbitrary data type into\n     * string values, for text rendering.\n     *\n     * @param {any} any object that can be converted into a string\n     *\n     * @return {String} the string representation of the input\n     */\n    function toP5String(obj) {\n      if(obj instanceof String) {\n        return obj;\n      }\n      if(typeof obj === 'number') {\n        // check if an int\n        if(obj === (0 | obj)) {\n          return obj.toString();\n        }\n        return p.nf(obj, 0, 3);\n      }\n      if(obj === null || obj === undef) {\n        return \"\";\n      }\n      return obj.toString();\n    }\n\n    /**\n     * textWidth() Calculates and returns the width of any character or text string in pixels.\n     *\n     * @param {char|String} str char or String to be measured\n     *\n     * @return {float} width of char or String in pixels\n     *\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     * @see #textFont\n     */\n    Drawing2D.prototype.textWidth = function(str) {\n      var lines = toP5String(str).split(/\\r?\\n/g), width = 0;\n      var i, linesCount = lines.length;\n\n      curContext.font = curTextFont.css;\n      for (i = 0; i < linesCount; ++i) {\n        width = Math.max(width, curTextFont.measureTextWidth(lines[i]));\n      }\n      return width | 0;\n    };\n\n    Drawing3D.prototype.textWidth = function(str) {\n      var lines = toP5String(str).split(/\\r?\\n/g), width = 0;\n      var i, linesCount = lines.length;\n      if (textcanvas === undef) {\n        textcanvas = document.createElement(\"canvas\");\n      }\n\n      var textContext = textcanvas.getContext(\"2d\");\n      textContext.font = curTextFont.css;\n\n      for (i = 0; i < linesCount; ++i) {\n        width = Math.max(width, textContext.measureText(lines[i]).width);\n      }\n      return width | 0;\n    };\n\n    // A lookup table for characters that can not be referenced by Object\n    p.glyphLook = function(font, chr) {\n      try {\n        switch (chr) {\n        case \"1\":\n          return font.one;\n        case \"2\":\n          return font.two;\n        case \"3\":\n          return font.three;\n        case \"4\":\n          return font.four;\n        case \"5\":\n          return font.five;\n        case \"6\":\n          return font.six;\n        case \"7\":\n          return font.seven;\n        case \"8\":\n          return font.eight;\n        case \"9\":\n          return font.nine;\n        case \"0\":\n          return font.zero;\n        case \" \":\n          return font.space;\n        case \"$\":\n          return font.dollar;\n        case \"!\":\n          return font.exclam;\n        case '\"':\n          return font.quotedbl;\n        case \"#\":\n          return font.numbersign;\n        case \"%\":\n          return font.percent;\n        case \"&\":\n          return font.ampersand;\n        case \"'\":\n          return font.quotesingle;\n        case \"(\":\n          return font.parenleft;\n        case \")\":\n          return font.parenright;\n        case \"*\":\n          return font.asterisk;\n        case \"+\":\n          return font.plus;\n        case \",\":\n          return font.comma;\n        case \"-\":\n          return font.hyphen;\n        case \".\":\n          return font.period;\n        case \"/\":\n          return font.slash;\n        case \"_\":\n          return font.underscore;\n        case \":\":\n          return font.colon;\n        case \";\":\n          return font.semicolon;\n        case \"<\":\n          return font.less;\n        case \"=\":\n          return font.equal;\n        case \">\":\n          return font.greater;\n        case \"?\":\n          return font.question;\n        case \"@\":\n          return font.at;\n        case \"[\":\n          return font.bracketleft;\n        case \"\\\\\":\n          return font.backslash;\n        case \"]\":\n          return font.bracketright;\n        case \"^\":\n          return font.asciicircum;\n        case \"`\":\n          return font.grave;\n        case \"{\":\n          return font.braceleft;\n        case \"|\":\n          return font.bar;\n        case \"}\":\n          return font.braceright;\n        case \"~\":\n          return font.asciitilde;\n          // If the character is not 'special', access it by object reference\n        default:\n          return font[chr];\n        }\n      } catch(e) {\n        Processing.debug(e);\n      }\n    };\n\n    // Print some text to the Canvas\n    Drawing2D.prototype.text$line = function(str, x, y, z, align) {\n      var textWidth = 0, xOffset = 0;\n      // If the font is a standard Canvas font...\n      if (!curTextFont.glyph) {\n        if (str && (\"fillText\" in curContext)) {\n          if (isFillDirty) {\n            curContext.fillStyle = p.color.toString(currentFillColor);\n            isFillDirty = false;\n          }\n\n          // horizontal offset/alignment\n          if(align === PConstants.RIGHT || align === PConstants.CENTER) {\n            textWidth = curTextFont.measureTextWidth(str);\n\n            if(align === PConstants.RIGHT) {\n              xOffset = -textWidth;\n            } else { // if(align === PConstants.CENTER)\n              xOffset = -textWidth/2;\n            }\n          }\n\n          curContext.fillText(str, x+xOffset, y);\n        }\n      } else {\n        // If the font is a Batik SVG font...\n        var font = p.glyphTable[curFontName];\n        saveContext();\n        curContext.translate(x, y + curTextSize);\n\n        // horizontal offset/alignment\n        if(align === PConstants.RIGHT || align === PConstants.CENTER) {\n          textWidth = font.width(str);\n\n          if(align === PConstants.RIGHT) {\n            xOffset = -textWidth;\n          } else { // if(align === PConstants.CENTER)\n            xOffset = -textWidth/2;\n          }\n        }\n\n        var upem   = font.units_per_em,\n          newScale = 1 / upem * curTextSize;\n\n        curContext.scale(newScale, newScale);\n\n        for (var i=0, len=str.length; i < len; i++) {\n          // Test character against glyph table\n          try {\n            p.glyphLook(font, str[i]).draw();\n          } catch(e) {\n            Processing.debug(e);\n          }\n        }\n        restoreContext();\n      }\n    };\n\n    Drawing3D.prototype.text$line = function(str, x, y, z, align) {\n      // handle case for 3d text\n      if (textcanvas === undef) {\n        textcanvas = document.createElement(\"canvas\");\n      }\n      var oldContext = curContext;\n      curContext = textcanvas.getContext(\"2d\");\n      curContext.font = curTextFont.css;\n      var textWidth = curTextFont.measureTextWidth(str);\n      textcanvas.width = textWidth;\n      textcanvas.height = curTextSize;\n      curContext = textcanvas.getContext(\"2d\"); // refreshes curContext\n      curContext.font = curTextFont.css;\n      curContext.textBaseline=\"top\";\n\n      // paint on 2D canvas\n      Drawing2D.prototype.text$line(str,0,0,0,PConstants.LEFT);\n\n      // use it as a texture\n      var aspect = textcanvas.width/textcanvas.height;\n      curContext = oldContext;\n\n      curContext.bindTexture(curContext.TEXTURE_2D, textTex);\n      curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, textcanvas);\n      curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);\n      curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR);\n      curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_T, curContext.CLAMP_TO_EDGE);\n      curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_S, curContext.CLAMP_TO_EDGE);\n      // If we don't have a power of two texture, we can't mipmap it.\n      // curContext.generateMipmap(curContext.TEXTURE_2D);\n\n      // horizontal offset/alignment\n      var xOffset = 0;\n      if (align === PConstants.RIGHT) {\n        xOffset = -textWidth;\n      } else if(align === PConstants.CENTER) {\n        xOffset = -textWidth/2;\n      }\n      var model = new PMatrix3D();\n      var scalefactor = curTextSize * 0.5;\n      model.translate(x+xOffset-scalefactor/2, y-scalefactor, z);\n      model.scale(-aspect*scalefactor, -scalefactor, scalefactor);\n      model.translate(-1, -1, -1);\n      model.transpose();\n\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      curContext.useProgram(programObject2D);\n      vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, textBuffer);\n      vertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\", 2, textureBuffer);\n      uniformi(\"uSampler2d\", programObject2D, \"uSampler\", [0]);\n\n      uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", true);\n\n      uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false,  model.array());\n      uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n      uniformf(\"uColor2d\", programObject2D, \"uColor\", fillStyle);\n      curContext.bindBuffer(curContext.ELEMENT_ARRAY_BUFFER, indexBuffer);\n      curContext.drawElements(curContext.TRIANGLES, 6, curContext.UNSIGNED_SHORT, 0);\n    };\n\n\n    /**\n    * unbounded text function (z is an optional argument)\n    */\n    function text$4(str, x, y, z) {\n      var lines, linesCount;\n      if(str.indexOf('\\n') < 0) {\n        lines = [str];\n        linesCount = 1;\n      } else {\n        lines = str.split(/\\r?\\n/g);\n        linesCount = lines.length;\n      }\n      // handle text line-by-line\n\n      var yOffset = 0;\n      if(verticalTextAlignment === PConstants.TOP) {\n        yOffset = curTextAscent + curTextDescent;\n      } else if(verticalTextAlignment === PConstants.CENTER) {\n        yOffset = curTextAscent/2 - (linesCount-1)*curTextLeading/2;\n      } else if(verticalTextAlignment === PConstants.BOTTOM) {\n        yOffset = -(curTextDescent + (linesCount-1)*curTextLeading);\n      }\n\n      for(var i=0;i<linesCount;++i) {\n        var line = lines[i];\n        drawing.text$line(line, x, y + yOffset, z, horizontalTextAlignment);\n        yOffset += curTextLeading;\n      }\n    }\n\n\n    /**\n    * box-bounded text function (z is an optional argument)\n    */\n    function text$6(str, x, y, width, height, z) {\n      // 'fail' on 0-valued dimensions\n      if (str.length === 0 || width === 0 || height === 0) {\n        return;\n      }\n      // also 'fail' if the text height is larger than the bounding height\n      if(curTextSize > height) {\n        return;\n      }\n\n      var spaceMark = -1;\n      var start = 0;\n      var lineWidth = 0;\n      var drawCommands = [];\n\n      // run through text, character-by-character\n      for (var charPos=0, len=str.length; charPos < len; charPos++)\n      {\n        var currentChar = str[charPos];\n        var spaceChar = (currentChar === \" \");\n        var letterWidth = curTextFont.measureTextWidth(currentChar);\n\n        // if we aren't looking at a newline, and the text still fits, keep processing\n        if (currentChar !== \"\\n\" && (lineWidth + letterWidth <= width)) {\n          if (spaceChar) { spaceMark = charPos; }\n          lineWidth += letterWidth;\n        }\n\n        // if we're looking at a newline, or the text no longer fits, push the section that fit into the drawcommand list\n        else\n        {\n          if (spaceMark + 1 === start) {\n            if(charPos>0) {\n              // Whole line without spaces so far.\n              spaceMark = charPos;\n            } else {\n              // 'fail', because the line can't even fit the first character\n              return;\n            }\n          }\n\n          if (currentChar === \"\\n\") {\n            drawCommands.push({text:str.substring(start, charPos), width: lineWidth});\n            start = charPos + 1;\n          } else {\n            // current is not a newline, which means the line doesn't fit in box. push text.\n            // In Processing 1.5.1, the space is also pushed, so we push up to spaceMark+1,\n            // rather than up to spaceMark, as was the case for Processing 1.5 and earlier.\n            drawCommands.push({text:str.substring(start, spaceMark+1), width: lineWidth});\n            start = spaceMark + 1;\n          }\n\n          // newline + return\n          lineWidth = 0;\n          charPos = start - 1;\n        }\n      }\n\n      // push the remaining text\n      if (start < len) {\n        drawCommands.push({text:str.substring(start), width: lineWidth});\n      }\n\n      // resolve horizontal alignment\n      var xOffset = 1,\n          yOffset = curTextAscent;\n      if (horizontalTextAlignment === PConstants.CENTER) {\n        xOffset = width/2;\n      } else if (horizontalTextAlignment === PConstants.RIGHT) {\n        xOffset = width;\n      }\n\n      // resolve vertical alignment\n      var linesCount = drawCommands.length,\n          visibleLines = Math.min(linesCount, Math.floor(height/curTextLeading));\n      if(verticalTextAlignment === PConstants.TOP) {\n        yOffset = curTextAscent + curTextDescent;\n      } else if(verticalTextAlignment === PConstants.CENTER) {\n        yOffset = (height/2) - curTextLeading * (visibleLines/2 - 1);\n      } else if(verticalTextAlignment === PConstants.BOTTOM) {\n        yOffset = curTextDescent + curTextLeading;\n      }\n\n      var command,\n          drawCommand,\n          leading;\n      for (command = 0; command < linesCount; command++) {\n        leading = command * curTextLeading;\n        // stop if not enough space for one more line draw\n        if (yOffset + leading > height - curTextDescent) {\n          break;\n        }\n        drawCommand = drawCommands[command];\n        drawing.text$line(drawCommand.text, x + xOffset, y + yOffset + leading, z, horizontalTextAlignment);\n      }\n    }\n\n    /**\n     * text() Draws text to the screen.\n     *\n     * @param {String|char|int|float} data       the alphanumeric symbols to be displayed\n     * @param {int|float}             x          x-coordinate of text\n     * @param {int|float}             y          y-coordinate of text\n     * @param {int|float}             z          optional z-coordinate of text\n     * @param {String}                stringdata optional letters to be displayed\n     * @param {int|float}             width      optional width of text box\n     * @param {int|float}             height     optional height of text box\n     *\n     * @see #textAlign\n     * @see #textMode\n     * @see #loadFont\n     * @see #PFont\n     * @see #textFont\n     */\n    p.text = function() {\n      if (textMode === PConstants.SHAPE) {\n        // TODO: requires beginRaw function\n        return;\n      }\n      if (arguments.length === 3) { // for text( str, x, y)\n        text$4(toP5String(arguments[0]), arguments[1], arguments[2], 0);\n      } else if (arguments.length === 4) { // for text( str, x, y, z)\n        text$4(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3]);\n      } else if (arguments.length === 5) { // for text( str, x, y , width, height)\n        text$6(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3], arguments[4], 0);\n      } else if (arguments.length === 6) { // for text( stringdata, x, y , width, height, z)\n        text$6(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n      }\n    };\n\n    /**\n     * Sets the way text draws to the screen. In the default configuration (the MODEL mode), it's possible to rotate,\n     * scale, and place letters in two and three dimensional space. <br /><br /> Changing to SCREEN mode draws letters\n     * directly to the front of the window and greatly increases rendering quality and speed when used with the P2D and\n     * P3D renderers. textMode(SCREEN) with OPENGL and JAVA2D (the default) renderers will generally be slower, though\n     * pixel accurate with P2D and P3D. With textMode(SCREEN), the letters draw at the actual size of the font (in pixels)\n     * and therefore calls to <b>textSize()</b> will not affect the size of the letters. To create a font at the size you\n     * desire, use the \"Create font...\" option in the Tools menu, or use the createFont() function. When using textMode(SCREEN),\n     * any z-coordinate passed to a text() command will be ignored, because your computer screen is...flat!\n     *\n     * @param {int} MODE Either MODEL, SCREEN or SHAPE (not yet supported)\n     *\n     * @see loadFont\n     * @see PFont\n     * @see text\n     * @see textFont\n     * @see createFont\n     */\n    p.textMode = function(mode){\n      textMode = mode;\n    };\n\n    // Load Batik SVG Fonts and parse to pre-def objects for quick rendering\n    p.loadGlyphs = function(url) {\n      var x, y, cx, cy, nx, ny, d, a, lastCom, lenC, horiz_adv_x, getXY = '[0-9\\\\-]+', path;\n\n      // Return arrays of SVG commands and coords\n      // get this to use p.matchAll() - will need to work around the lack of null return\n      var regex = function(needle, hay) {\n        var i = 0,\n          results = [],\n          latest, regexp = new RegExp(needle, \"g\");\n        latest = results[i] = regexp.exec(hay);\n        while (latest) {\n          i++;\n          latest = results[i] = regexp.exec(hay);\n        }\n        return results;\n      };\n\n      var buildPath = function(d) {\n        var c = regex(\"[A-Za-z][0-9\\\\- ]+|Z\", d);\n        var beforePathDraw = function() {\n          saveContext();\n          return drawing.$ensureContext();\n        };\n        var afterPathDraw = function() {\n          executeContextFill();\n          executeContextStroke();\n          restoreContext();\n        };\n\n        // Begin storing path object\n        path = \"return {draw:function(){var curContext=beforePathDraw();curContext.beginPath();\";\n\n        x = 0;\n        y = 0;\n        cx = 0;\n        cy = 0;\n        nx = 0;\n        ny = 0;\n        d = 0;\n        a = 0;\n        lastCom = \"\";\n        lenC = c.length - 1;\n\n        // Loop through SVG commands translating to canvas eqivs functions in path object\n        for (var j = 0; j < lenC; j++) {\n          var com = c[j][0], xy = regex(getXY, com);\n\n          switch (com[0]) {\n            case \"M\":\n              //curContext.moveTo(x,-y);\n              x = parseFloat(xy[0][0]);\n              y = parseFloat(xy[1][0]);\n              path += \"curContext.moveTo(\" + x + \",\" + (-y) + \");\";\n              break;\n\n            case \"L\":\n              //curContext.lineTo(x,-y);\n              x = parseFloat(xy[0][0]);\n              y = parseFloat(xy[1][0]);\n              path += \"curContext.lineTo(\" + x + \",\" + (-y) + \");\";\n              break;\n\n            case \"H\":\n              //curContext.lineTo(x,-y)\n              x = parseFloat(xy[0][0]);\n              path += \"curContext.lineTo(\" + x + \",\" + (-y) + \");\";\n              break;\n\n            case \"V\":\n              //curContext.lineTo(x,-y);\n              y = parseFloat(xy[0][0]);\n              path += \"curContext.lineTo(\" + x + \",\" + (-y) + \");\";\n              break;\n\n            case \"T\":\n              //curContext.quadraticCurveTo(cx,-cy,nx,-ny);\n              nx = parseFloat(xy[0][0]);\n              ny = parseFloat(xy[1][0]);\n\n              if (lastCom === \"Q\" || lastCom === \"T\") {\n                d = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(cy - y, 2));\n                a = Math.PI + Math.atan2(cx - x, cy - y);\n                cx = x + (Math.sin(a) * (d));\n                cy = y + (Math.cos(a) * (d));\n              } else {\n                cx = x;\n                cy = y;\n              }\n\n              path += \"curContext.quadraticCurveTo(\" + cx + \",\" + (-cy) + \",\" + nx + \",\" + (-ny) + \");\";\n              x = nx;\n              y = ny;\n              break;\n\n            case \"Q\":\n              //curContext.quadraticCurveTo(cx,-cy,nx,-ny);\n              cx = parseFloat(xy[0][0]);\n              cy = parseFloat(xy[1][0]);\n              nx = parseFloat(xy[2][0]);\n              ny = parseFloat(xy[3][0]);\n              path += \"curContext.quadraticCurveTo(\" + cx + \",\" + (-cy) + \",\" + nx + \",\" + (-ny) + \");\";\n              x = nx;\n              y = ny;\n              break;\n\n            case \"Z\":\n              //curContext.closePath();\n              path += \"curContext.closePath();\";\n              break;\n          }\n          lastCom = com[0];\n        }\n\n        path += \"afterPathDraw();\";\n        path += \"curContext.translate(\" + horiz_adv_x + \",0);\";\n        path += \"}}\";\n\n        return ((new Function(\"beforePathDraw\", \"afterPathDraw\", path))(beforePathDraw, afterPathDraw));\n      };\n\n      // Parse SVG font-file into block of Canvas commands\n      var parseSVGFont = function(svg) {\n        // Store font attributes\n        var font = svg.getElementsByTagName(\"font\");\n        p.glyphTable[url].horiz_adv_x = font[0].getAttribute(\"horiz-adv-x\");\n\n        var font_face = svg.getElementsByTagName(\"font-face\")[0];\n        p.glyphTable[url].units_per_em = parseFloat(font_face.getAttribute(\"units-per-em\"));\n        p.glyphTable[url].ascent = parseFloat(font_face.getAttribute(\"ascent\"));\n        p.glyphTable[url].descent = parseFloat(font_face.getAttribute(\"descent\"));\n\n        var glyph = svg.getElementsByTagName(\"glyph\"),\n          len = glyph.length;\n\n        // Loop through each glyph in the SVG\n        for (var i = 0; i < len; i++) {\n          // Store attributes for this glyph\n          var unicode = glyph[i].getAttribute(\"unicode\");\n          var name = glyph[i].getAttribute(\"glyph-name\");\n          horiz_adv_x = glyph[i].getAttribute(\"horiz-adv-x\");\n          if (horiz_adv_x === null) {\n            horiz_adv_x = p.glyphTable[url].horiz_adv_x;\n          }\n          d = glyph[i].getAttribute(\"d\");\n          // Split path commands in glpyh\n          if (d !== undef) {\n            path = buildPath(d);\n            // Store glyph data to table object\n            p.glyphTable[url][name] = {\n              name: name,\n              unicode: unicode,\n              horiz_adv_x: horiz_adv_x,\n              draw: path.draw\n            };\n          }\n        } // finished adding glyphs to table\n      };\n\n      // Load and parse Batik SVG font as XML into a Processing Glyph object\n      var loadXML = function() {\n        var xmlDoc;\n\n        try {\n          xmlDoc = document.implementation.createDocument(\"\", \"\", null);\n        }\n        catch(e_fx_op) {\n          Processing.debug(e_fx_op.message);\n          return;\n        }\n\n        try {\n          xmlDoc.async = false;\n          xmlDoc.load(url);\n          parseSVGFont(xmlDoc.getElementsByTagName(\"svg\")[0]);\n        }\n        catch(e_sf_ch) {\n          // Google Chrome, Safari etc.\n          Processing.debug(e_sf_ch);\n          try {\n            var xmlhttp = new window.XMLHttpRequest();\n            xmlhttp.open(\"GET\", url, false);\n            xmlhttp.send(null);\n            parseSVGFont(xmlhttp.responseXML.documentElement);\n          }\n          catch(e) {\n            Processing.debug(e_sf_ch);\n          }\n        }\n      };\n\n      // Create a new object in glyphTable to store this font\n      p.glyphTable[url] = {};\n\n      // Begin loading the Batik SVG font...\n      loadXML(url);\n\n      // Return the loaded font for attribute grabbing\n      return p.glyphTable[url];\n    };\n\n    /**\n     * Gets the sketch parameter value. The parameter can be defined as the canvas attribute with\n     * the \"data-processing-\" prefix or provided in the pjs directive (e.g. param-test=\"52\").\n     * The function tries the canvas attributes, then the pjs directive content.\n     *\n     * @param   {String}    name          The name of the param to read.\n     *\n     * @returns {String}    The parameter value, or null if parameter is not defined.\n     */\n    p.param = function(name) {\n      // trying attribute that was specified in CANVAS\n      var attributeName = \"data-processing-\" + name;\n      if (curElement.hasAttribute(attributeName)) {\n        return curElement.getAttribute(attributeName);\n      }\n      // trying child PARAM elements of the CANVAS\n      for (var i = 0, len = curElement.childNodes.length; i < len; ++i) {\n        var item = curElement.childNodes.item(i);\n        if (item.nodeType !== 1 || item.tagName.toLowerCase() !== \"param\") {\n          continue;\n        }\n        if (item.getAttribute(\"name\") === name) {\n          return item.getAttribute(\"value\");\n        }\n      }\n      // fallback to default params\n      if (curSketch.params.hasOwnProperty(name)) {\n        return curSketch.params[name];\n      }\n      return null;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 2D/3D methods wiring utils\n    ////////////////////////////////////////////////////////////////////////////\n    function wireDimensionalFunctions(mode) {\n      // Drawing2D/Drawing3D\n      if (mode === '3D') {\n        drawing = new Drawing3D();\n      } else if (mode === '2D') {\n        drawing = new Drawing2D();\n      } else {\n        drawing = new DrawingPre();\n      }\n\n      // Wire up functions (Use DrawingPre properties names)\n      for (var i in DrawingPre.prototype) {\n        if (DrawingPre.prototype.hasOwnProperty(i) && i.indexOf(\"$\") < 0) {\n          p[i] = drawing[i];\n        }\n      }\n\n      // Run initialization\n      drawing.$init();\n    }\n\n    function createDrawingPreFunction(name) {\n      return function() {\n        wireDimensionalFunctions(\"2D\");\n        return drawing[name].apply(this, arguments);\n      };\n    }\n    DrawingPre.prototype.translate = createDrawingPreFunction(\"translate\");\n    DrawingPre.prototype.transform = createDrawingPreFunction(\"transform\");\n    DrawingPre.prototype.scale = createDrawingPreFunction(\"scale\");\n    DrawingPre.prototype.pushMatrix = createDrawingPreFunction(\"pushMatrix\");\n    DrawingPre.prototype.popMatrix = createDrawingPreFunction(\"popMatrix\");\n    DrawingPre.prototype.resetMatrix = createDrawingPreFunction(\"resetMatrix\");\n    DrawingPre.prototype.applyMatrix = createDrawingPreFunction(\"applyMatrix\");\n    DrawingPre.prototype.rotate = createDrawingPreFunction(\"rotate\");\n    DrawingPre.prototype.rotateZ = createDrawingPreFunction(\"rotateZ\");\n    DrawingPre.prototype.shearX = createDrawingPreFunction(\"shearX\");\n    DrawingPre.prototype.shearY = createDrawingPreFunction(\"shearY\");\n    DrawingPre.prototype.redraw = createDrawingPreFunction(\"redraw\");\n    DrawingPre.prototype.toImageData = createDrawingPreFunction(\"toImageData\");\n    DrawingPre.prototype.ambientLight = createDrawingPreFunction(\"ambientLight\");\n    DrawingPre.prototype.directionalLight = createDrawingPreFunction(\"directionalLight\");\n    DrawingPre.prototype.lightFalloff = createDrawingPreFunction(\"lightFalloff\");\n    DrawingPre.prototype.lightSpecular = createDrawingPreFunction(\"lightSpecular\");\n    DrawingPre.prototype.pointLight = createDrawingPreFunction(\"pointLight\");\n    DrawingPre.prototype.noLights = createDrawingPreFunction(\"noLights\");\n    DrawingPre.prototype.spotLight = createDrawingPreFunction(\"spotLight\");\n    DrawingPre.prototype.beginCamera = createDrawingPreFunction(\"beginCamera\");\n    DrawingPre.prototype.endCamera = createDrawingPreFunction(\"endCamera\");\n    DrawingPre.prototype.frustum = createDrawingPreFunction(\"frustum\");\n    DrawingPre.prototype.box = createDrawingPreFunction(\"box\");\n    DrawingPre.prototype.sphere = createDrawingPreFunction(\"sphere\");\n    DrawingPre.prototype.ambient = createDrawingPreFunction(\"ambient\");\n    DrawingPre.prototype.emissive = createDrawingPreFunction(\"emissive\");\n    DrawingPre.prototype.shininess = createDrawingPreFunction(\"shininess\");\n    DrawingPre.prototype.specular = createDrawingPreFunction(\"specular\");\n    DrawingPre.prototype.fill = createDrawingPreFunction(\"fill\");\n    DrawingPre.prototype.stroke = createDrawingPreFunction(\"stroke\");\n    DrawingPre.prototype.strokeWeight = createDrawingPreFunction(\"strokeWeight\");\n    DrawingPre.prototype.smooth = createDrawingPreFunction(\"smooth\");\n    DrawingPre.prototype.noSmooth = createDrawingPreFunction(\"noSmooth\");\n    DrawingPre.prototype.point = createDrawingPreFunction(\"point\");\n    DrawingPre.prototype.vertex = createDrawingPreFunction(\"vertex\");\n    DrawingPre.prototype.endShape = createDrawingPreFunction(\"endShape\");\n    DrawingPre.prototype.bezierVertex = createDrawingPreFunction(\"bezierVertex\");\n    DrawingPre.prototype.curveVertex = createDrawingPreFunction(\"curveVertex\");\n    DrawingPre.prototype.curve = createDrawingPreFunction(\"curve\");\n    DrawingPre.prototype.line = createDrawingPreFunction(\"line\");\n    DrawingPre.prototype.bezier = createDrawingPreFunction(\"bezier\");\n    DrawingPre.prototype.rect = createDrawingPreFunction(\"rect\");\n    DrawingPre.prototype.ellipse = createDrawingPreFunction(\"ellipse\");\n    DrawingPre.prototype.background = createDrawingPreFunction(\"background\");\n    DrawingPre.prototype.image = createDrawingPreFunction(\"image\");\n    DrawingPre.prototype.textWidth = createDrawingPreFunction(\"textWidth\");\n    DrawingPre.prototype.text$line = createDrawingPreFunction(\"text$line\");\n    DrawingPre.prototype.$ensureContext = createDrawingPreFunction(\"$ensureContext\");\n    DrawingPre.prototype.$newPMatrix = createDrawingPreFunction(\"$newPMatrix\");\n\n    DrawingPre.prototype.size = function(aWidth, aHeight, aMode) {\n      wireDimensionalFunctions(aMode === PConstants.WEBGL ? \"3D\" : \"2D\");\n      p.size(aWidth, aHeight, aMode);\n    };\n\n    DrawingPre.prototype.$init = nop;\n\n    Drawing2D.prototype.$init = function() {\n      // Setup default 2d canvas context.\n      // Moving this here removes the number of times we need to check the 3D variable\n      p.size(p.width, p.height);\n\n      curContext.lineCap = 'round';\n\n      // Set default stroke and fill color\n      p.noSmooth();\n      p.disableContextMenu();\n    };\n    Drawing3D.prototype.$init = function() {\n      // For ref/perf test compatibility until those are fixed\n      p.use3DContext = true;\n      p.disableContextMenu();\n    };\n\n    DrawingShared.prototype.$ensureContext = function() {\n      return curContext;\n    };\n\n    //////////////////////////////////////////////////////////////////////////\n    // Touch and Mouse event handling\n    //////////////////////////////////////////////////////////////////////////\n\n    function calculateOffset(curElement, event) {\n      var element = curElement,\n        offsetX = 0,\n        offsetY = 0;\n\n      p.pmouseX = p.mouseX;\n      p.pmouseY = p.mouseY;\n\n      // Find element offset\n      if (element.offsetParent) {\n        do {\n          offsetX += element.offsetLeft;\n          offsetY += element.offsetTop;\n        } while (!!(element = element.offsetParent));\n      }\n\n      // Find Scroll offset\n      element = curElement;\n      do {\n        offsetX -= element.scrollLeft || 0;\n        offsetY -= element.scrollTop || 0;\n      } while (!!(element = element.parentNode));\n\n      // Add padding and border style widths to offset\n      offsetX += stylePaddingLeft;\n      offsetY += stylePaddingTop;\n\n      offsetX += styleBorderLeft;\n      offsetY += styleBorderTop;\n\n      // Take into account any scrolling done\n      offsetX += window.pageXOffset;\n      offsetY += window.pageYOffset;\n\n      return {'X':offsetX,'Y':offsetY};\n    }\n\n    function updateMousePosition(curElement, event) {\n      var offset = calculateOffset(curElement, event);\n\n      // Dropping support for IE clientX and clientY, switching to pageX and pageY so we don't have to calculate scroll offset.\n      // Removed in ticket #184. See rev: 2f106d1c7017fed92d045ba918db47d28e5c16f4\n      p.mouseX = event.pageX - offset.X;\n      p.mouseY = event.pageY - offset.Y;\n    }\n\n    // Return a TouchEvent with canvas-specific x/y co-ordinates\n    function addTouchEventOffset(t) {\n      var offset = calculateOffset(t.changedTouches[0].target, t.changedTouches[0]),\n          i;\n\n      for (i = 0; i < t.touches.length; i++) {\n        var touch = t.touches[i];\n        touch.offsetX = touch.pageX - offset.X;\n        touch.offsetY = touch.pageY - offset.Y;\n      }\n      for (i = 0; i < t.targetTouches.length; i++) {\n        var targetTouch = t.targetTouches[i];\n        targetTouch.offsetX = targetTouch.pageX - offset.X;\n        targetTouch.offsetY = targetTouch.pageY - offset.Y;\n      }\n      for (i = 0; i < t.changedTouches.length; i++) {\n        var changedTouch = t.changedTouches[i];\n        changedTouch.offsetX = changedTouch.pageX - offset.X;\n        changedTouch.offsetY = changedTouch.pageY - offset.Y;\n      }\n\n      return t;\n    }\n\n    attachEventHandler(curElement, \"touchstart\", function (t) {\n      // Removes unwanted behaviour of the canvas when touching canvas\n      curElement.setAttribute(\"style\",\"-webkit-user-select: none\");\n      curElement.setAttribute(\"onclick\",\"void(0)\");\n      curElement.setAttribute(\"style\",\"-webkit-tap-highlight-color:rgba(0,0,0,0)\");\n      // Loop though eventHandlers and remove mouse listeners\n      for (var i=0, ehl=eventHandlers.length; i<ehl; i++) {\n        var type = eventHandlers[i].type;\n        // Have this function remove itself from the eventHandlers list too\n        if (type === \"mouseout\" ||  type === \"mousemove\" ||\n            type === \"mousedown\" || type === \"mouseup\" ||\n            type === \"DOMMouseScroll\" || type === \"mousewheel\" || type === \"touchstart\") {\n          detachEventHandler(eventHandlers[i]);\n        }\n      }\n\n      // If there are any native touch events defined in the sketch, connect all of them\n      // Otherwise, connect all of the emulated mouse events\n      if (p.touchStart !== undef || p.touchMove !== undef ||\n          p.touchEnd !== undef || p.touchCancel !== undef) {\n        attachEventHandler(curElement, \"touchstart\", function(t) {\n          if (p.touchStart !== undef) {\n            t = addTouchEventOffset(t);\n            p.touchStart(t);\n          }\n        });\n\n        attachEventHandler(curElement, \"touchmove\", function(t) {\n          if (p.touchMove !== undef) {\n            t.preventDefault(); // Stop the viewport from scrolling\n            t = addTouchEventOffset(t);\n            p.touchMove(t);\n          }\n        });\n\n        attachEventHandler(curElement, \"touchend\", function(t) {\n          if (p.touchEnd !== undef) {\n            t = addTouchEventOffset(t);\n            p.touchEnd(t);\n          }\n        });\n\n        attachEventHandler(curElement, \"touchcancel\", function(t) {\n          if (p.touchCancel !== undef) {\n            t = addTouchEventOffset(t);\n            p.touchCancel(t);\n          }\n        });\n\n      } else {\n        // Emulated touch start/mouse down event\n        attachEventHandler(curElement, \"touchstart\", function(e) {\n          updateMousePosition(curElement, e.touches[0]);\n\n          p.__mousePressed = true;\n          p.mouseDragging = false;\n          p.mouseButton = PConstants.LEFT;\n\n          if (typeof p.mousePressed === \"function\") {\n            p.mousePressed();\n          }\n        });\n\n        // Emulated touch move/mouse move event\n        attachEventHandler(curElement, \"touchmove\", function(e) {\n          e.preventDefault();\n          updateMousePosition(curElement, e.touches[0]);\n\n          if (typeof p.mouseMoved === \"function\" && !p.__mousePressed) {\n            p.mouseMoved();\n          }\n          if (typeof p.mouseDragged === \"function\" && p.__mousePressed) {\n            p.mouseDragged();\n            p.mouseDragging = true;\n          }\n        });\n\n        // Emulated touch up/mouse up event\n        attachEventHandler(curElement, \"touchend\", function(e) {\n          p.__mousePressed = false;\n\n          if (typeof p.mouseClicked === \"function\" && !p.mouseDragging) {\n            p.mouseClicked();\n          }\n\n          if (typeof p.mouseReleased === \"function\") {\n            p.mouseReleased();\n          }\n        });\n      }\n\n      // Refire the touch start event we consumed in this function\n      curElement.dispatchEvent(t);\n    });\n\n    (function() {\n      var enabled = true,\n          contextMenu = function(e) {\n            e.preventDefault();\n            e.stopPropagation();\n          };\n\n      p.disableContextMenu = function() {\n        if (!enabled) {\n          return;\n        }\n        attachEventHandler(curElement, 'contextmenu', contextMenu);\n        enabled = false;\n      };\n\n      p.enableContextMenu = function() {\n        if (enabled) {\n          return;\n        }\n        detachEventHandler({elem: curElement, type: 'contextmenu', fn: contextMenu});\n        enabled = true;\n      };\n    }());\n\n    attachEventHandler(curElement, \"mousemove\", function(e) {\n      updateMousePosition(curElement, e);\n      if (typeof p.mouseMoved === \"function\" && !p.__mousePressed) {\n        p.mouseMoved();\n      }\n      if (typeof p.mouseDragged === \"function\" && p.__mousePressed) {\n        p.mouseDragged();\n        p.mouseDragging = true;\n      }\n    });\n\n    attachEventHandler(curElement, \"mouseout\", function(e) {\n      if (typeof p.mouseOut === \"function\") {\n        p.mouseOut();\n      }\n    });\n\n    attachEventHandler(curElement, \"mouseover\", function(e) {\n      updateMousePosition(curElement, e);\n      if (typeof p.mouseOver === \"function\") {\n        p.mouseOver();\n      }\n    });\n\n    // Disable browser's default handling for click-drag of a canvas.\n    curElement.onmousedown = function () { return false; };\n\n    attachEventHandler(curElement, \"mousedown\", function(e) {\n      p.__mousePressed = true;\n      p.mouseDragging = false;\n      switch (e.which) {\n      case 1:\n        p.mouseButton = PConstants.LEFT;\n        break;\n      case 2:\n        p.mouseButton = PConstants.CENTER;\n        break;\n      case 3:\n        p.mouseButton = PConstants.RIGHT;\n        break;\n      }\n\n      if (typeof p.mousePressed === \"function\") {\n        p.mousePressed();\n      }\n    });\n\n    attachEventHandler(curElement, \"mouseup\", function(e) {\n      p.__mousePressed = false;\n\n      if (typeof p.mouseClicked === \"function\" && !p.mouseDragging) {\n        p.mouseClicked();\n      }\n\n      if (typeof p.mouseReleased === \"function\") {\n        p.mouseReleased();\n      }\n    });\n\n    var mouseWheelHandler = function(e) {\n      var delta = 0;\n\n      if (e.wheelDelta) {\n        delta = e.wheelDelta / 120;\n        if (window.opera) {\n          delta = -delta;\n        }\n      } else if (e.detail) {\n        delta = -e.detail / 3;\n      }\n\n      p.mouseScroll = delta;\n\n      if (delta && typeof p.mouseScrolled === 'function') {\n        p.mouseScrolled();\n      }\n    };\n\n    // Support Gecko and non-Gecko scroll events\n    attachEventHandler(document, 'DOMMouseScroll', mouseWheelHandler);\n    attachEventHandler(document, 'mousewheel', mouseWheelHandler);\n\n    //////////////////////////////////////////////////////////////////////////\n    // Keyboard Events\n    //////////////////////////////////////////////////////////////////////////\n\n    // In order to catch key events in a canvas, it needs to be \"specially focusable\",\n    // by assigning it a tabindex. If no tabindex is specified on-page, set this to 0.\n    if (!curElement.getAttribute(\"tabindex\")) {\n      curElement.setAttribute(\"tabindex\", 0);\n    }\n\n    function getKeyCode(e) {\n      var code = e.which || e.keyCode;\n      switch (code) {\n        case 13: // ENTER\n          return 10;\n        case 91: // META L (Saf/Mac)\n        case 93: // META R (Saf/Mac)\n        case 224: // META (FF/Mac)\n          return 157;\n        case 57392: // CONTROL (Op/Mac)\n          return 17;\n        case 46: // DELETE\n          return 127;\n        case 45: // INSERT\n          return 155;\n      }\n      return code;\n    }\n\n    function getKeyChar(e) {\n      var c = e.which || e.keyCode;\n      var anyShiftPressed = e.shiftKey || e.ctrlKey || e.altKey || e.metaKey;\n      switch (c) {\n        case 13:\n          c = anyShiftPressed ? 13 : 10; // RETURN vs ENTER (Mac)\n          break;\n        case 8:\n          c = anyShiftPressed ? 127 : 8; // DELETE vs BACKSPACE (Mac)\n          break;\n      }\n      return new Char(c);\n    }\n\n    function suppressKeyEvent(e) {\n      if (typeof e.preventDefault === \"function\") {\n        e.preventDefault();\n      } else if (typeof e.stopPropagation === \"function\") {\n        e.stopPropagation();\n      }\n      return false;\n    }\n\n    function updateKeyPressed() {\n      var ch;\n      for (ch in pressedKeysMap) {\n        if (pressedKeysMap.hasOwnProperty(ch)) {\n          p.__keyPressed = true;\n          return;\n        }\n      }\n      p.__keyPressed = false;\n    }\n\n    function resetKeyPressed() {\n      p.__keyPressed = false;\n      pressedKeysMap = [];\n      lastPressedKeyCode = null;\n    }\n\n    function simulateKeyTyped(code, c) {\n      pressedKeysMap[code] = c;\n      lastPressedKeyCode = null;\n      p.key = c;\n      p.keyCode = code;\n      p.keyPressed();\n      p.keyCode = 0;\n      p.keyTyped();\n      updateKeyPressed();\n    }\n\n    function handleKeydown(e) {\n      var code = getKeyCode(e);\n      if (code === PConstants.DELETE) {\n        simulateKeyTyped(code, new Char(127));\n        return;\n      }\n      if (codedKeys.indexOf(code) < 0) {\n        lastPressedKeyCode = code;\n        return;\n      }\n      var c = new Char(PConstants.CODED);\n      p.key = c;\n      p.keyCode = code;\n      pressedKeysMap[code] = c;\n      p.keyPressed();\n      lastPressedKeyCode = null;\n      updateKeyPressed();\n      return suppressKeyEvent(e);\n    }\n\n    function handleKeypress(e) {\n      if (lastPressedKeyCode === null) {\n        return; // processed in handleKeydown\n      }\n      var code = lastPressedKeyCode, c = getKeyChar(e);\n      simulateKeyTyped(code, c);\n      return suppressKeyEvent(e);\n    }\n\n    function handleKeyup(e) {\n      var code = getKeyCode(e), c = pressedKeysMap[code];\n      if (c === undef) {\n        return; // no keyPressed event was generated.\n      }\n      p.key = c;\n      p.keyCode = code;\n      p.keyReleased();\n      delete pressedKeysMap[code];\n      updateKeyPressed();\n    }\n\n    // Send aCode Processing syntax to be converted to JavaScript\n    if (!pgraphicsMode) {\n      if (aCode instanceof Processing.Sketch) {\n        // Use sketch as is\n        curSketch = aCode;\n      } else if (typeof aCode === \"function\") {\n        // Wrap function with default sketch parameters\n        curSketch = new Processing.Sketch(aCode);\n      } else if (!aCode) {\n        // Empty sketch\n        curSketch = new Processing.Sketch(function (){});\n      } else {\n//#if PARSER\n        // Compile the code\n        curSketch = Processing.compile(aCode);\n//#else\n//      throw \"PJS compile is not supported\";\n//#endif\n      }\n\n      // Expose internal field for diagnostics and testing\n      p.externals.sketch = curSketch;\n\n      wireDimensionalFunctions();\n\n      // the onfocus and onblur events are handled in two parts.\n      // 1) the p.focused property is handled per sketch\n      curElement.onfocus = function() {\n        p.focused = true;\n      };\n\n      curElement.onblur = function() {\n        p.focused = false;\n        if (!curSketch.options.globalKeyEvents) {\n          resetKeyPressed();\n        }\n      };\n\n      // 2) looping status is handled per page, based on the pauseOnBlur @pjs directive\n      if (curSketch.options.pauseOnBlur) {\n        attachEventHandler(window, 'focus', function() {\n          if (doLoop) {\n            p.loop();\n          }\n        });\n\n        attachEventHandler(window, 'blur', function() {\n          if (doLoop && loopStarted) {\n            p.noLoop();\n            doLoop = true; // make sure to keep this true after the noLoop call\n          }\n          resetKeyPressed();\n        });\n      }\n\n      // if keyboard events should be handled globally, the listeners should\n      // be bound to the document window, rather than to the current canvas\n      var keyTrigger = curSketch.options.globalKeyEvents ? window : curElement;\n      attachEventHandler(keyTrigger, \"keydown\", handleKeydown);\n      attachEventHandler(keyTrigger, \"keypress\", handleKeypress);\n      attachEventHandler(keyTrigger, \"keyup\", handleKeyup);\n\n      // Step through the libraries that were attached at doc load...\n      for (var i in Processing.lib) {\n        if (Processing.lib.hasOwnProperty(i)) {\n          if(Processing.lib[i].hasOwnProperty(\"attach\")) {\n            // use attach function if present\n            Processing.lib[i].attach(p);\n          } else if(Processing.lib[i] instanceof Function)  {\n            // Init the libraries in the context of this p_instance (legacy)\n            Processing.lib[i].call(this);\n          }\n        }\n      }\n\n      // sketch execute test interval, used to reschedule\n      // an execute when preloads have not yet finished.\n      var retryInterval = 100;\n\n      var executeSketch = function(processing) {\n        // Don't start until all specified images and fonts in the cache are preloaded\n        if (!(curSketch.imageCache.pending || PFont.preloading.pending(retryInterval))) {\n          // the opera preload cache can only be cleared once we start\n          if (window.opera) {\n            var link,\n                element,\n                operaCache=curSketch.imageCache.operaCache;\n            for (link in operaCache) {\n              if(operaCache.hasOwnProperty(link)) {\n                element = operaCache[link];\n                if (element !== null) {\n                  document.body.removeChild(element);\n                }\n                delete(operaCache[link]);\n              }\n            }\n          }\n\n          curSketch.attach(processing, defaultScope);\n\n          // pass a reference to the p instance for this sketch.\n          curSketch.onLoad(processing);\n\n          // Run void setup()\n          if (processing.setup) {\n            processing.setup();\n            // if any transforms were performed in setup reset to identity matrix\n            // so draw loop is unpolluted\n            processing.resetMatrix();\n            curSketch.onSetup();\n          }\n\n          // some pixels can be cached, flushing\n          resetContext();\n\n          if (processing.draw) {\n            if (!doLoop) {\n              processing.redraw();\n            } else {\n              processing.loop();\n            }\n          }\n        } else {\n          window.setTimeout(function() { executeSketch(processing); }, retryInterval);\n        }\n      };\n\n      // Only store an instance of non-createGraphics instances.\n      addInstance(this);\n\n      // The parser adds custom methods to the processing context\n      // this renames p to processing so these methods will run\n      executeSketch(p);\n    } else {\n      // No executable sketch was specified\n      // or called via createGraphics\n      curSketch = new Processing.Sketch();\n\n      wireDimensionalFunctions();\n\n      // Hack to make PGraphics work again after splitting size()\n      p.size = function(w, h, render) {\n        if (render && render === PConstants.WEBGL) {\n          wireDimensionalFunctions('3D');\n        } else {\n          wireDimensionalFunctions('2D');\n        }\n\n        p.size(w, h, render);\n      };\n    }\n  }; // Processing() ends\n\n  // Place-holder for overridable debugging function\n  Processing.debug = debug;\n\n  Processing.prototype = defaultScope;\n\n//#if PARSER\n  // Processing global methods and constants for the parser\n  function getGlobalMembers() {\n    // The names array contains the names of everything that is inside \"p.\"\n    // When something new is added to \"p.\" it must also be added to this list.\n    var names = [ /* this code is generated by jsglobals.js */\n      \"abs\", \"acos\", \"alpha\", \"ambient\", \"ambientLight\", \"append\", \"applyMatrix\",\n      \"arc\", \"arrayCopy\", \"asin\", \"atan\", \"atan2\", \"background\", \"beginCamera\",\n      \"beginDraw\", \"beginShape\", \"bezier\", \"bezierDetail\", \"bezierPoint\",\n      \"bezierTangent\", \"bezierVertex\", \"binary\", \"blend\", \"blendColor\",\n      \"blit_resize\", \"blue\", \"box\", \"breakShape\", \"brightness\",\n      \"camera\", \"ceil\", \"Character\", \"color\", \"colorMode\",\n      \"concat\", \"constrain\", \"copy\", \"cos\", \"createFont\",\n      \"createGraphics\", \"createImage\", \"cursor\", \"curve\", \"curveDetail\",\n      \"curvePoint\", \"curveTangent\", \"curveTightness\", \"curveVertex\", \"day\",\n      \"degrees\", \"directionalLight\", \"disableContextMenu\",\n      \"dist\", \"draw\", \"ellipse\", \"ellipseMode\", \"emissive\", \"enableContextMenu\",\n      \"endCamera\", \"endDraw\", \"endShape\", \"exit\", \"exp\", \"expand\", \"externals\",\n      \"fill\", \"filter\", \"floor\", \"focused\", \"frameCount\", \"frameRate\", \"frustum\",\n      \"get\", \"glyphLook\", \"glyphTable\", \"green\", \"height\", \"hex\", \"hint\", \"hour\",\n      \"hue\", \"image\", \"imageMode\", \"intersect\", \"join\", \"key\",\n      \"keyCode\", \"keyPressed\", \"keyReleased\", \"keyTyped\", \"lerp\", \"lerpColor\",\n      \"lightFalloff\", \"lights\", \"lightSpecular\", \"line\", \"link\", \"loadBytes\",\n      \"loadFont\", \"loadGlyphs\", \"loadImage\", \"loadPixels\", \"loadShape\", \"loadXML\",\n      \"loadStrings\", \"log\", \"loop\", \"mag\", \"map\", \"match\", \"matchAll\", \"max\",\n      \"millis\", \"min\", \"minute\", \"mix\", \"modelX\", \"modelY\", \"modelZ\", \"modes\",\n      \"month\", \"mouseButton\", \"mouseClicked\", \"mouseDragged\", \"mouseMoved\",\n      \"mouseOut\", \"mouseOver\", \"mousePressed\", \"mouseReleased\", \"mouseScroll\",\n      \"mouseScrolled\", \"mouseX\", \"mouseY\", \"name\", \"nf\", \"nfc\", \"nfp\", \"nfs\",\n      \"noCursor\", \"noFill\", \"noise\", \"noiseDetail\", \"noiseSeed\", \"noLights\",\n      \"noLoop\", \"norm\", \"normal\", \"noSmooth\", \"noStroke\", \"noTint\", \"ortho\",\n      \"param\", \"parseBoolean\", \"parseByte\", \"parseChar\", \"parseFloat\",\n      \"parseInt\", \"peg\", \"perspective\", \"PImage\", \"pixels\", \"PMatrix2D\",\n      \"PMatrix3D\", \"PMatrixStack\", \"pmouseX\", \"pmouseY\", \"point\",\n      \"pointLight\", \"popMatrix\", \"popStyle\", \"pow\", \"print\", \"printCamera\",\n      \"println\", \"printMatrix\", \"printProjection\", \"PShape\", \"PShapeSVG\",\n      \"pushMatrix\", \"pushStyle\", \"quad\", \"radians\", \"random\", \"Random\",\n      \"randomSeed\", \"rect\", \"rectMode\", \"red\", \"redraw\", \"requestImage\",\n      \"resetMatrix\", \"reverse\", \"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\",\n      \"round\", \"saturation\", \"save\", \"saveFrame\", \"saveStrings\", \"scale\",\n      \"screenX\", \"screenY\", \"screenZ\", \"second\", \"set\", \"setup\", \"shape\",\n      \"shapeMode\", \"shared\", \"shearX\", \"shearY\", \"shininess\", \"shorten\", \"sin\", \"size\", \"smooth\",\n      \"sort\", \"specular\", \"sphere\", \"sphereDetail\", \"splice\", \"split\",\n      \"splitTokens\", \"spotLight\", \"sq\", \"sqrt\", \"status\", \"str\", \"stroke\",\n      \"strokeCap\", \"strokeJoin\", \"strokeWeight\", \"subset\", \"tan\", \"text\",\n      \"textAlign\", \"textAscent\", \"textDescent\", \"textFont\", \"textLeading\",\n      \"textMode\", \"textSize\", \"texture\", \"textureMode\", \"textWidth\", \"tint\", \"toImageData\",\n      \"touchCancel\", \"touchEnd\", \"touchMove\", \"touchStart\", \"translate\", \"transform\",\n      \"triangle\", \"trim\", \"unbinary\", \"unhex\", \"updatePixels\", \"use3DContext\",\n      \"vertex\", \"width\", \"XMLElement\", \"XML\", \"year\", \"__contains\", \"__equals\",\n      \"__equalsIgnoreCase\", \"__frameRate\", \"__hashCode\", \"__int_cast\",\n      \"__instanceof\", \"__keyPressed\", \"__mousePressed\", \"__printStackTrace\",\n      \"__replace\", \"__replaceAll\", \"__replaceFirst\", \"__toCharArray\", \"__split\",\n      \"__codePointAt\", \"__startsWith\", \"__endsWith\"];\n\n    var members = {};\n    var i, l;\n    for (i = 0, l = names.length; i < l ; ++i) {\n      members[names[i]] = null;\n    }\n    for (var lib in Processing.lib) {\n      if (Processing.lib.hasOwnProperty(lib)) {\n        if (Processing.lib[lib].exports) {\n          var exportedNames = Processing.lib[lib].exports;\n          for (i = 0, l = exportedNames.length; i < l; ++i) {\n           members[exportedNames[i]] = null;\n          }\n        }\n      }\n    }\n    return members;\n  }\n\n/*\n\n    Parser converts Java-like syntax into JavaScript.\n    Creates an Abstract Syntax Tree -- \"Light AST\" from the Java-like code.\n\n    It is an object tree. The root object is created from the AstRoot class, which contains statements.\n\n    A statement object can be of type: AstForStatement, AstCatchStatement, AstPrefixStatement, AstMethod, AstClass,\n    AstInterface, AstFunction, AstStatementBlock and AstLabel.\n\n    AstPrefixStatement can be a statement of type: if, switch, while, with, do, else, finally, return, throw, try, break, and continue.\n\n    These object's toString function returns the JavaScript code for the statement.\n\n    Any processing calls need \"processing.\" prepended to them.\n\n    Similarly, calls from inside classes need \"$this_1.\", prepended to them,\n    with 1 being the depth level for inner classes.\n    This includes members passed down from inheritance.\n\n    The resulting code is then eval'd and run.\n\n*/\n\n  function parseProcessing(code) {\n    var globalMembers = getGlobalMembers();\n\n    // masks parentheses, brackets and braces with '\"A5\"'\n    // where A is the bracket type, and 5 is the index in an array containing all brackets split into atoms\n    // 'while(true){}' -> 'while\"B1\"\"A2\"'\n    // parentheses() = B, brackets[] = C and braces{} = A\n    function splitToAtoms(code) {\n      var atoms = [];\n      var items = code.split(/([\\{\\[\\(\\)\\]\\}])/);\n      var result = items[0];\n\n      var stack = [];\n      for(var i=1; i < items.length; i += 2) {\n        var item = items[i];\n        if(item === '[' || item === '{' || item === '(') {\n          stack.push(result); result = item;\n        } else if(item === ']' || item === '}' || item === ')') {\n          var kind = item === '}' ? 'A' : item === ')' ? 'B' : 'C';\n          var index = atoms.length; atoms.push(result + item);\n          result = stack.pop() + '\"' + kind + (index + 1) + '\"';\n        }\n        result += items[i + 1];\n      }\n      atoms.unshift(result);\n      return atoms;\n    }\n\n    // replaces strings and regexs keyed by index with an array of strings\n    function injectStrings(code, strings) {\n      return code.replace(/'(\\d+)'/g, function(all, index) {\n        var val = strings[index];\n        if(val.charAt(0) === \"/\") {\n          return val;\n        }\n        return (/^'((?:[^'\\\\\\n])|(?:\\\\.[0-9A-Fa-f]*))'$/).test(val) ? \"(new $p.Character(\" + val + \"))\" : val;\n      });\n    }\n\n    // trims off leading and trailing spaces\n    // returns an object. object.left, object.middle, object.right, object.untrim\n    function trimSpaces(string) {\n      var m1 = /^\\s*/.exec(string), result;\n      if(m1[0].length === string.length) {\n        result = {left: m1[0], middle: \"\", right: \"\"};\n      } else {\n        var m2 = /\\s*$/.exec(string);\n        result = {left: m1[0], middle: string.substring(m1[0].length, m2.index), right: m2[0]};\n      }\n      result.untrim = function(t) { return this.left + t + this.right; };\n      return result;\n    }\n\n    // simple trim of leading and trailing spaces\n    function trim(string) {\n      return string.replace(/^\\s+/,'').replace(/\\s+$/,'');\n    }\n\n    function appendToLookupTable(table, array) {\n      for(var i=0,l=array.length;i<l;++i) {\n        table[array[i]] = null;\n      }\n      return table;\n    }\n\n    function isLookupTableEmpty(table) {\n      for(var i in table) {\n        if(table.hasOwnProperty(i)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function getAtomIndex(templ) { return templ.substring(2, templ.length - 1); }\n\n    // remove carriage returns \"\\r\"\n    var codeWoExtraCr = code.replace(/\\r\\n?|\\n\\r/g, \"\\n\");\n\n    // masks strings and regexs with \"'5'\", where 5 is the index in an array containing all strings and regexs\n    // also removes all comments\n    var strings = [];\n    var codeWoStrings = codeWoExtraCr.replace(/(\"(?:[^\"\\\\\\n]|\\\\.)*\")|('(?:[^'\\\\\\n]|\\\\.)*')|(([\\[\\(=|&!\\^:?]\\s*)(\\/(?![*\\/])(?:[^\\/\\\\\\n]|\\\\.)*\\/[gim]*)\\b)|(\\/\\/[^\\n]*\\n)|(\\/\\*(?:(?!\\*\\/)(?:.|\\n))*\\*\\/)/g,\n    function(all, quoted, aposed, regexCtx, prefix, regex, singleComment, comment) {\n      var index;\n      if(quoted || aposed) { // replace strings\n        index = strings.length; strings.push(all);\n        return \"'\" + index + \"'\";\n      }\n      if(regexCtx) { // replace RegExps\n        index = strings.length; strings.push(regex);\n        return prefix + \"'\" + index + \"'\";\n      }\n      // kill comments\n      return comment !== \"\" ? \" \" : \"\\n\";\n    });\n\n    // protect character codes from namespace collision\n    codeWoStrings = codeWoStrings.replace(/__x([0-9A-F]{4})/g, function(all, hexCode) {\n      // $ = __x0024\n      // _ = __x005F\n      // this protects existing character codes from conversion\n      // __x0024 = __x005F_x0024\n      return \"__x005F_x\" + hexCode;\n    });\n\n    // convert dollar sign to character code\n    codeWoStrings = codeWoStrings.replace(/\\$/g, \"__x0024\");\n\n    // removes generics\n    var genericsWereRemoved;\n    var codeWoGenerics = codeWoStrings;\n    var replaceFunc = function(all, before, types, after) {\n      if(!!before || !!after) {\n        return all;\n      }\n      genericsWereRemoved = true;\n      return \"\";\n    };\n\n    do {\n      genericsWereRemoved = false;\n      codeWoGenerics = codeWoGenerics.replace(/([<]?)<\\s*((?:\\?|[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\[\\])*(?:\\s+(?:extends|super)\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)?(?:\\s*,\\s*(?:\\?|[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\[\\])*(?:\\s+(?:extends|super)\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)?)*)\\s*>([=]?)/g, replaceFunc);\n    } while (genericsWereRemoved);\n\n    var atoms = splitToAtoms(codeWoGenerics);\n    var replaceContext;\n    var declaredClasses = {}, currentClassId, classIdSeed = 0;\n\n    function addAtom(text, type) {\n      var lastIndex = atoms.length;\n      atoms.push(text);\n      return '\"' + type + lastIndex + '\"';\n    }\n\n    function generateClassId() {\n      return \"class\" + (++classIdSeed);\n    }\n\n    function appendClass(class_, classId, scopeId) {\n      class_.classId = classId;\n      class_.scopeId = scopeId;\n      declaredClasses[classId] = class_;\n    }\n\n    // functions defined below\n    var transformClassBody, transformInterfaceBody, transformStatementsBlock, transformStatements, transformMain, transformExpression;\n\n    var classesRegex = /\\b((?:(?:public|private|final|protected|static|abstract)\\s+)*)(class|interface)\\s+([A-Za-z_$][\\w$]*\\b)(\\s+extends\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\b)*)?(\\s+implements\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\b)*)?\\s*(\"A\\d+\")/g;\n    var methodsRegex = /\\b((?:(?:public|private|final|protected|static|abstract|synchronized)\\s+)*)((?!(?:else|new|return|throw|function|public|private|protected)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*([A-Za-z_$][\\w$]*\\b)\\s*(\"B\\d+\")(\\s*throws\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)*)?\\s*(\"A\\d+\"|;)/g;\n    var fieldTest = /^((?:(?:public|private|final|protected|static)\\s+)*)((?!(?:else|new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*([A-Za-z_$][\\w$]*\\b)\\s*(?:\"C\\d+\"\\s*)*([=,]|$)/;\n    var cstrsRegex = /\\b((?:(?:public|private|final|protected|static|abstract)\\s+)*)((?!(?:new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b)\\s*(\"B\\d+\")(\\s*throws\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)*)?\\s*(\"A\\d+\")/g;\n    var attrAndTypeRegex = /^((?:(?:public|private|final|protected|static)\\s+)*)((?!(?:new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*/;\n    var functionsRegex = /\\bfunction(?:\\s+([A-Za-z_$][\\w$]*))?\\s*(\"B\\d+\")\\s*(\"A\\d+\")/g;\n\n    // This converts classes, methods and functions into atoms, and adds them to the atoms array.\n    // classes = E, methods = D and functions = H\n    function extractClassesAndMethods(code) {\n      var s = code;\n      s = s.replace(classesRegex, function(all) {\n        return addAtom(all, 'E');\n      });\n      s = s.replace(methodsRegex, function(all) {\n        return addAtom(all, 'D');\n      });\n      s = s.replace(functionsRegex, function(all) {\n        return addAtom(all, 'H');\n      });\n      return s;\n    }\n\n    // This converts constructors into atoms, and adds them to the atoms array.\n    // constructors = G\n    function extractConstructors(code, className) {\n      var result = code.replace(cstrsRegex, function(all, attr, name, params, throws_, body) {\n        if(name !== className) {\n          return all;\n        }\n        return addAtom(all, 'G');\n      });\n      return result;\n    }\n\n    // AstParam contains the name of a parameter inside a function declaration\n    function AstParam(name) {\n      this.name = name;\n    }\n    AstParam.prototype.toString = function() {\n      return this.name;\n    };\n    // AstParams contains an array of AstParam objects\n    function AstParams(params, methodArgsParam) {\n      this.params = params;\n      this.methodArgsParam = methodArgsParam;\n    }\n    AstParams.prototype.getNames = function() {\n      var names = [];\n      for(var i=0,l=this.params.length;i<l;++i) {\n        names.push(this.params[i].name);\n      }\n      return names;\n    };\n    AstParams.prototype.prependMethodArgs = function(body) {\n      if (!this.methodArgsParam) {\n        return body;\n      }\n      return \"{\\nvar \" + this.methodArgsParam.name +\n        \" = Array.prototype.slice.call(arguments, \" +\n        this.params.length + \");\\n\" + body.substring(1);\n    };\n    AstParams.prototype.toString = function() {\n      if(this.params.length === 0) {\n        return \"()\";\n      }\n      var result = \"(\";\n      for(var i=0,l=this.params.length;i<l;++i) {\n        result += this.params[i] + \", \";\n      }\n      return result.substring(0, result.length - 2) + \")\";\n    };\n\n    function transformParams(params) {\n      var paramsWoPars = trim(params.substring(1, params.length - 1));\n      var result = [], methodArgsParam = null;\n      if(paramsWoPars !== \"\") {\n        var paramList = paramsWoPars.split(\",\");\n        for(var i=0; i < paramList.length; ++i) {\n          var param = /\\b([A-Za-z_$][\\w$]*\\b)(\\s*\"[ABC][\\d]*\")*\\s*$/.exec(paramList[i]);\n          if (i === paramList.length - 1 && paramList[i].indexOf('...') >= 0) {\n            methodArgsParam = new AstParam(param[1]);\n            break;\n          }\n          result.push(new AstParam(param[1]));\n        }\n      }\n      return new AstParams(result, methodArgsParam);\n    }\n\n    function preExpressionTransform(expr) {\n      var s = expr;\n      // new type[] {...} --> {...}\n      s = s.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\s*\"C\\d+\")+\\s*(\"A\\d+\")/g, function(all, type, init) {\n        return init;\n      });\n      // new Runnable() {...} --> \"F???\"\n      s = s.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\s*\"B\\d+\")\\s*(\"A\\d+\")/g, function(all, type, init) {\n        return addAtom(all, 'F');\n      });\n      // function(...) { } --> \"H???\"\n      s = s.replace(functionsRegex, function(all) {\n        return addAtom(all, 'H');\n      });\n      // new type[?] --> createJavaArray('type', [?])\n      s = s.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)\\s*(\"C\\d+\"(?:\\s*\"C\\d+\")*)/g, function(all, type, index) {\n        var args = index.replace(/\"C(\\d+)\"/g, function(all, j) { return atoms[j]; })\n          .replace(/\\[\\s*\\]/g, \"[null]\").replace(/\\s*\\]\\s*\\[\\s*/g, \", \");\n        var arrayInitializer = \"{\" + args.substring(1, args.length - 1) + \"}\";\n        var createArrayArgs = \"('\" + type + \"', \" + addAtom(arrayInitializer, 'A') + \")\";\n        return '$p.createJavaArray' + addAtom(createArrayArgs, 'B');\n      });\n      // .length() --> .length\n      s = s.replace(/(\\.\\s*length)\\s*\"B\\d+\"/g, \"$1\");\n      // #000000 --> 0x000000\n      s = s.replace(/#([0-9A-Fa-f]{6})\\b/g, function(all, digits) {\n        return \"0xFF\" + digits;\n      });\n      // delete (type)???, except (int)???\n      s = s.replace(/\"B(\\d+)\"(\\s*(?:[\\w$']|\"B))/g, function(all, index, next) {\n        var atom = atoms[index];\n        if(!/^\\(\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\s*(?:\"C\\d+\"\\s*)*\\)$/.test(atom)) {\n          return all;\n        }\n        if(/^\\(\\s*int\\s*\\)$/.test(atom)) {\n          return \"(int)\" + next;\n        }\n        var indexParts = atom.split(/\"C(\\d+)\"/g);\n        if(indexParts.length > 1) {\n          // even items contains atom numbers, can check only first\n          if(! /^\\[\\s*\\]$/.test(atoms[indexParts[1]])) {\n            return all; // fallback - not a cast\n          }\n        }\n        return \"\" + next;\n      });\n      // (int)??? -> __int_cast(???)\n      s = s.replace(/\\(int\\)([^,\\]\\)\\}\\?\\:\\*\\+\\-\\/\\^\\|\\%\\&\\~<\\>\\=]+)/g, function(all, arg) {\n        var trimmed = trimSpaces(arg);\n        return trimmed.untrim(\"__int_cast(\" + trimmed.middle + \")\");\n      });\n      // super() -> $superCstr(), super. -> $super.;\n      s = s.replace(/\\bsuper(\\s*\"B\\d+\")/g, \"$$superCstr$1\").replace(/\\bsuper(\\s*\\.)/g, \"$$super$1\");\n      // 000.43->0.43 and 0010f->10, but not 0010\n      s = s.replace(/\\b0+((\\d*)(?:\\.[\\d*])?(?:[eE][\\-\\+]?\\d+)?[fF]?)\\b/, function(all, numberWo0, intPart) {\n        if( numberWo0 === intPart) {\n          return all;\n        }\n        return intPart === \"\" ? \"0\" + numberWo0 : numberWo0;\n      });\n      // 3.0f -> 3.0\n      s = s.replace(/\\b(\\.?\\d+\\.?)[fF]\\b/g, \"$1\");\n      // Weird (?) parsing errors with %\n      s = s.replace(/([^\\s])%([^=\\s])/g, \"$1 % $2\");\n      // Since frameRate() and frameRate are different things,\n      // we need to differentiate them somehow. So when we parse\n      // the Processing.js source, replace frameRate so it isn't\n      // confused with frameRate(), as well as keyPressed and mousePressed\n      s = s.replace(/\\b(frameRate|keyPressed|mousePressed)\\b(?!\\s*\"B)/g, \"__$1\");\n      // \"boolean\", \"byte\", \"int\", etc. => \"parseBoolean\", \"parseByte\", \"parseInt\", etc.\n      s = s.replace(/\\b(boolean|byte|char|float|int)\\s*\"B/g, function(all, name) {\n        return \"parse\" + name.substring(0, 1).toUpperCase() + name.substring(1) + \"\\\"B\";\n      });\n      // \"pixels\" replacements:\n      //   pixels[i] = c => pixels.setPixel(i,c) | pixels[i] => pixels.getPixel(i)\n      //   pixels.length => pixels.getLength()\n      //   pixels = ar => pixels.set(ar) | pixels => pixels.toArray()\n      s = s.replace(/\\bpixels\\b\\s*((\"C(\\d+)\")|\\.length)?(\\s*=(?!=)([^,\\]\\)\\}]+))?/g,\n        function(all, indexOrLength, index, atomIndex, equalsPart, rightSide) {\n          if(index) {\n            var atom = atoms[atomIndex];\n            if(equalsPart) {\n              return \"pixels.setPixel\" + addAtom(\"(\" +atom.substring(1, atom.length - 1) +\n                \",\" + rightSide + \")\", 'B');\n            }\n            return \"pixels.getPixel\" + addAtom(\"(\" + atom.substring(1, atom.length - 1) +\n              \")\", 'B');\n          }\n          if(indexOrLength) {\n            // length\n            return \"pixels.getLength\" + addAtom(\"()\", 'B');\n          }\n          if(equalsPart) {\n            return \"pixels.set\" + addAtom(\"(\" + rightSide + \")\", 'B');\n          }\n          return \"pixels.toArray\" + addAtom(\"()\", 'B');\n        });\n      // Java method replacements for: replace, replaceAll, replaceFirst, equals, hashCode, etc.\n      //   xxx.replace(yyy) -> __replace(xxx, yyy)\n      //   \"xx\".replace(yyy) -> __replace(\"xx\", yyy)\n      var repeatJavaReplacement;\n      function replacePrototypeMethods(all, subject, method, atomIndex) {\n        var atom = atoms[atomIndex];\n        repeatJavaReplacement = true;\n        var trimmed = trimSpaces(atom.substring(1, atom.length - 1));\n        return \"__\" + method  + ( trimmed.middle === \"\" ? addAtom(\"(\" + subject.replace(/\\.\\s*$/, \"\") + \")\", 'B') :\n          addAtom(\"(\" + subject.replace(/\\.\\s*$/, \"\") + \",\" + trimmed.middle + \")\", 'B') );\n      }\n      do {\n        repeatJavaReplacement = false;\n        s = s.replace(/((?:'\\d+'|\\b[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\")*)\\s*\\.\\s*(?:[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\"\\s*)*\\.\\s*)*)(replace|replaceAll|replaceFirst|contains|equals|equalsIgnoreCase|hashCode|toCharArray|printStackTrace|split|startsWith|endsWith|codePointAt)\\s*\"B(\\d+)\"/g,\n          replacePrototypeMethods);\n      } while (repeatJavaReplacement);\n      // xxx instanceof yyy -> __instanceof(xxx, yyy)\n      function replaceInstanceof(all, subject, type) {\n        repeatJavaReplacement = true;\n        return \"__instanceof\" + addAtom(\"(\" + subject + \", \" + type + \")\", 'B');\n      }\n      do {\n        repeatJavaReplacement = false;\n        s = s.replace(/((?:'\\d+'|\\b[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\")*)\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\"\\s*)*)*)instanceof\\s+([A-Za-z_$][\\w$]*\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*)*)/g,\n          replaceInstanceof);\n      } while (repeatJavaReplacement);\n      // this() -> $constr()\n      s = s.replace(/\\bthis(\\s*\"B\\d+\")/g, \"$$constr$1\");\n\n      return s;\n    }\n\n    function AstInlineClass(baseInterfaceName, body) {\n      this.baseInterfaceName = baseInterfaceName;\n      this.body = body;\n      body.owner = this;\n    }\n    AstInlineClass.prototype.toString = function() {\n      return \"new (\" + this.body + \")\";\n    };\n\n    function transformInlineClass(class_) {\n      var m = new RegExp(/\\bnew\\s*([A-Za-z_$][\\w$]*\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*)*)\\s*\"B\\d+\"\\s*\"A(\\d+)\"/).exec(class_);\n      var oldClassId = currentClassId, newClassId = generateClassId();\n      currentClassId = newClassId;\n      var uniqueClassName = m[1] + \"$\" + newClassId;\n      var inlineClass = new AstInlineClass(uniqueClassName,\n        transformClassBody(atoms[m[2]], uniqueClassName, \"\", \"implements \" + m[1]));\n      appendClass(inlineClass, newClassId, oldClassId);\n      currentClassId = oldClassId;\n      return inlineClass;\n    }\n\n    function AstFunction(name, params, body) {\n      this.name = name;\n      this.params = params;\n      this.body = body;\n    }\n    AstFunction.prototype.toString = function() {\n      var oldContext = replaceContext;\n      // saving \"this.\" and parameters\n      var names = appendToLookupTable({\"this\":null}, this.params.getNames());\n      replaceContext = function (subject) {\n        return names.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n      };\n      var result = \"function\";\n      if(this.name) {\n        result += \" \" + this.name;\n      }\n      var body = this.params.prependMethodArgs(this.body.toString());\n      result += this.params + \" \" + body;\n      replaceContext = oldContext;\n      return result;\n    };\n\n    function transformFunction(class_) {\n      var m = new RegExp(/\\b([A-Za-z_$][\\w$]*)\\s*\"B(\\d+)\"\\s*\"A(\\d+)\"/).exec(class_);\n      return new AstFunction( m[1] !== \"function\" ? m[1] : null,\n        transformParams(atoms[m[2]]), transformStatementsBlock(atoms[m[3]]));\n    }\n\n    function AstInlineObject(members) {\n      this.members = members;\n    }\n    AstInlineObject.prototype.toString = function() {\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n          return subject.name === \"this\" ? \"this\" : oldContext(subject); // saving \"this.\"\n      };\n      var result = \"\";\n      for(var i=0,l=this.members.length;i<l;++i) {\n        if(this.members[i].label) {\n          result += this.members[i].label + \": \";\n        }\n        result += this.members[i].value.toString() + \", \";\n      }\n      replaceContext = oldContext;\n      return result.substring(0, result.length - 2);\n    };\n\n    function transformInlineObject(obj) {\n      var members = obj.split(',');\n      for(var i=0; i < members.length; ++i) {\n        var label = members[i].indexOf(':');\n        if(label < 0) {\n          members[i] = { value: transformExpression(members[i]) };\n        } else {\n          members[i] = { label: trim(members[i].substring(0, label)),\n            value: transformExpression( trim(members[i].substring(label + 1)) ) };\n        }\n      }\n      return new AstInlineObject(members);\n    }\n\n    function expandExpression(expr) {\n      if(expr.charAt(0) === '(' || expr.charAt(0) === '[') {\n        return expr.charAt(0) + expandExpression(expr.substring(1, expr.length - 1)) + expr.charAt(expr.length - 1);\n      }\n      if(expr.charAt(0) === '{') {\n        if(/^\\{\\s*(?:[A-Za-z_$][\\w$]*|'\\d+')\\s*:/.test(expr)) {\n          return \"{\" + addAtom(expr.substring(1, expr.length - 1), 'I') + \"}\";\n        }\n        return \"[\" + expandExpression(expr.substring(1, expr.length - 1)) + \"]\";\n      }\n      var trimmed = trimSpaces(expr);\n      var result = preExpressionTransform(trimmed.middle);\n      result = result.replace(/\"[ABC](\\d+)\"/g, function(all, index) {\n        return expandExpression(atoms[index]);\n      });\n      return trimmed.untrim(result);\n    }\n\n    function replaceContextInVars(expr) {\n      return expr.replace(/(\\.\\s*)?((?:\\b[A-Za-z_]|\\$)[\\w$]*)(\\s*\\.\\s*([A-Za-z_$][\\w$]*)(\\s*\\()?)?/g,\n        function(all, memberAccessSign, identifier, suffix, subMember, callSign) {\n          if(memberAccessSign) {\n            return all;\n          }\n          var subject = { name: identifier, member: subMember, callSign: !!callSign };\n          return replaceContext(subject) + (suffix === undef ? \"\" : suffix);\n        });\n    }\n\n    function AstExpression(expr, transforms) {\n      this.expr = expr;\n      this.transforms = transforms;\n    }\n    AstExpression.prototype.toString = function() {\n      var transforms = this.transforms;\n      var expr = replaceContextInVars(this.expr);\n      return expr.replace(/\"!(\\d+)\"/g, function(all, index) {\n        return transforms[index].toString();\n      });\n    };\n\n    transformExpression = function(expr) {\n      var transforms = [];\n      var s = expandExpression(expr);\n      s = s.replace(/\"H(\\d+)\"/g, function(all, index) {\n        transforms.push(transformFunction(atoms[index]));\n        return '\"!' + (transforms.length - 1) + '\"';\n      });\n      s = s.replace(/\"F(\\d+)\"/g, function(all, index) {\n        transforms.push(transformInlineClass(atoms[index]));\n        return '\"!' + (transforms.length - 1) + '\"';\n      });\n      s = s.replace(/\"I(\\d+)\"/g, function(all, index) {\n        transforms.push(transformInlineObject(atoms[index]));\n        return '\"!' + (transforms.length - 1) + '\"';\n      });\n\n      return new AstExpression(s, transforms);\n    };\n\n    function AstVarDefinition(name, value, isDefault) {\n      this.name = name;\n      this.value = value;\n      this.isDefault = isDefault;\n    }\n    AstVarDefinition.prototype.toString = function() {\n      return this.name + ' = ' + this.value;\n    };\n\n    function transformVarDefinition(def, defaultTypeValue) {\n      var eqIndex = def.indexOf(\"=\");\n      var name, value, isDefault;\n      if(eqIndex < 0) {\n        name = def;\n        value = defaultTypeValue;\n        isDefault = true;\n      } else {\n        name = def.substring(0, eqIndex);\n        value = transformExpression(def.substring(eqIndex + 1));\n        isDefault = false;\n      }\n      return new AstVarDefinition( trim(name.replace(/(\\s*\"C\\d+\")+/g, \"\")),\n        value, isDefault);\n    }\n\n    function getDefaultValueForType(type) {\n        if(type === \"int\" || type === \"float\") {\n          return \"0\";\n        }\n        if(type === \"boolean\") {\n          return \"false\";\n        }\n        if(type === \"color\") {\n          return \"0x00000000\";\n        }\n        return \"null\";\n    }\n\n    function AstVar(definitions, varType) {\n      this.definitions = definitions;\n      this.varType = varType;\n    }\n    AstVar.prototype.getNames = function() {\n      var names = [];\n      for(var i=0,l=this.definitions.length;i<l;++i) {\n        names.push(this.definitions[i].name);\n      }\n      return names;\n    };\n    AstVar.prototype.toString = function() {\n      return \"var \" + this.definitions.join(\",\");\n    };\n    function AstStatement(expression) {\n      this.expression = expression;\n    }\n    AstStatement.prototype.toString = function() {\n      return this.expression.toString();\n    };\n\n    function transformStatement(statement) {\n      if(fieldTest.test(statement)) {\n        var attrAndType = attrAndTypeRegex.exec(statement);\n        var definitions = statement.substring(attrAndType[0].length).split(\",\");\n        var defaultTypeValue = getDefaultValueForType(attrAndType[2]);\n        for(var i=0; i < definitions.length; ++i) {\n          definitions[i] = transformVarDefinition(definitions[i], defaultTypeValue);\n        }\n        return new AstVar(definitions, attrAndType[2]);\n      }\n      return new AstStatement(transformExpression(statement));\n    }\n\n    function AstForExpression(initStatement, condition, step) {\n      this.initStatement = initStatement;\n      this.condition = condition;\n      this.step = step;\n    }\n    AstForExpression.prototype.toString = function() {\n      return \"(\" + this.initStatement + \"; \" + this.condition + \"; \" + this.step + \")\";\n    };\n\n    function AstForInExpression(initStatement, container) {\n      this.initStatement = initStatement;\n      this.container = container;\n    }\n    AstForInExpression.prototype.toString = function() {\n      var init = this.initStatement.toString();\n      if(init.indexOf(\"=\") >= 0) { // can be without var declaration\n        init = init.substring(0, init.indexOf(\"=\"));\n      }\n      return \"(\" + init + \" in \" + this.container + \")\";\n    };\n\n    function AstForEachExpression(initStatement, container) {\n      this.initStatement = initStatement;\n      this.container = container;\n    }\n    AstForEachExpression.iteratorId = 0;\n    AstForEachExpression.prototype.toString = function() {\n      var init = this.initStatement.toString();\n      var iterator = \"$it\" + (AstForEachExpression.iteratorId++);\n      var variableName = init.replace(/^\\s*var\\s*/, \"\").split(\"=\")[0];\n      var initIteratorAndVariable = \"var \" + iterator + \" = new $p.ObjectIterator(\" + this.container + \"), \" +\n         variableName + \" = void(0)\";\n      var nextIterationCondition = iterator + \".hasNext() && ((\" +\n         variableName + \" = \" + iterator + \".next()) || true)\";\n      return \"(\" + initIteratorAndVariable + \"; \" + nextIterationCondition + \";)\";\n    };\n\n    function transformForExpression(expr) {\n      var content;\n      if (/\\bin\\b/.test(expr)) {\n        content = expr.substring(1, expr.length - 1).split(/\\bin\\b/g);\n        return new AstForInExpression( transformStatement(trim(content[0])),\n          transformExpression(content[1]));\n      }\n      if (expr.indexOf(\":\") >= 0 && expr.indexOf(\";\") < 0) {\n        content = expr.substring(1, expr.length - 1).split(\":\");\n        return new AstForEachExpression( transformStatement(trim(content[0])),\n          transformExpression(content[1]));\n      }\n      content = expr.substring(1, expr.length - 1).split(\";\");\n      return new AstForExpression( transformStatement(trim(content[0])),\n        transformExpression(content[1]), transformExpression(content[2]));\n    }\n\n    function sortByWeight(array) {\n      array.sort(function (a,b) {\n        return b.weight - a.weight;\n      });\n    }\n\n    function AstInnerInterface(name, body, isStatic) {\n      this.name = name;\n      this.body = body;\n      this.isStatic = isStatic;\n      body.owner = this;\n    }\n    AstInnerInterface.prototype.toString = function() {\n      return \"\" + this.body;\n    };\n    function AstInnerClass(name, body, isStatic) {\n      this.name = name;\n      this.body = body;\n      this.isStatic = isStatic;\n      body.owner = this;\n    }\n    AstInnerClass.prototype.toString = function() {\n      return \"\" + this.body;\n    };\n\n    function transformInnerClass(class_) {\n      var m = classesRegex.exec(class_); // 1 - attr, 2 - class|int, 3 - name, 4 - extends, 5 - implements, 6 - body\n      classesRegex.lastIndex = 0;\n      var isStatic = m[1].indexOf(\"static\") >= 0;\n      var body = atoms[getAtomIndex(m[6])], innerClass;\n      var oldClassId = currentClassId, newClassId = generateClassId();\n      currentClassId = newClassId;\n      if(m[2] === \"interface\") {\n        innerClass = new AstInnerInterface(m[3], transformInterfaceBody(body, m[3], m[4]), isStatic);\n      } else {\n        innerClass = new AstInnerClass(m[3], transformClassBody(body, m[3], m[4], m[5]), isStatic);\n      }\n      appendClass(innerClass, newClassId, oldClassId);\n      currentClassId = oldClassId;\n      return innerClass;\n    }\n\n    function AstClassMethod(name, params, body, isStatic) {\n      this.name = name;\n      this.params = params;\n      this.body = body;\n      this.isStatic = isStatic;\n    }\n    AstClassMethod.prototype.toString = function(){\n      var paramNames = appendToLookupTable({}, this.params.getNames());\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n        return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n      };\n      var body = this.params.prependMethodArgs(this.body.toString());\n      var result = \"function \" + this.methodId + this.params + \" \" + body +\"\\n\";\n      replaceContext = oldContext;\n      return result;\n    };\n\n    function transformClassMethod(method) {\n      var m = methodsRegex.exec(method);\n      methodsRegex.lastIndex = 0;\n      var isStatic = m[1].indexOf(\"static\") >= 0;\n      var body = m[6] !== ';' ? atoms[getAtomIndex(m[6])] : \"{}\";\n      return new AstClassMethod(m[3], transformParams(atoms[getAtomIndex(m[4])]),\n        transformStatementsBlock(body), isStatic );\n    }\n\n    function AstClassField(definitions, fieldType, isStatic) {\n      this.definitions = definitions;\n      this.fieldType = fieldType;\n      this.isStatic = isStatic;\n    }\n    AstClassField.prototype.getNames = function() {\n      var names = [];\n      for(var i=0,l=this.definitions.length;i<l;++i) {\n        names.push(this.definitions[i].name);\n      }\n      return names;\n    };\n    AstClassField.prototype.toString = function() {\n      var thisPrefix = replaceContext({ name: \"[this]\" });\n      if(this.isStatic) {\n        var className = this.owner.name;\n        var staticDeclarations = [];\n        for(var i=0,l=this.definitions.length;i<l;++i) {\n          var definition = this.definitions[i];\n          var name = definition.name, staticName = className + \".\" + name;\n          var declaration = \"if(\" + staticName + \" === void(0)) {\\n\" +\n            \" \" + staticName + \" = \" + definition.value + \"; }\\n\" +\n            \"$p.defineProperty(\" + thisPrefix + \", \" +\n            \"'\" + name + \"', { get: function(){return \" + staticName + \";}, \" +\n            \"set: function(val){\" + staticName + \" = val;} });\\n\";\n          staticDeclarations.push(declaration);\n        }\n        return staticDeclarations.join(\"\");\n      }\n      return thisPrefix + \".\" + this.definitions.join(\"; \" + thisPrefix + \".\");\n    };\n\n    function transformClassField(statement) {\n      var attrAndType = attrAndTypeRegex.exec(statement);\n      var isStatic = attrAndType[1].indexOf(\"static\") >= 0;\n      var definitions = statement.substring(attrAndType[0].length).split(/,\\s*/g);\n      var defaultTypeValue = getDefaultValueForType(attrAndType[2]);\n      for(var i=0; i < definitions.length; ++i) {\n        definitions[i] = transformVarDefinition(definitions[i], defaultTypeValue);\n      }\n      return new AstClassField(definitions, attrAndType[2], isStatic);\n    }\n\n    function AstConstructor(params, body) {\n      this.params = params;\n      this.body = body;\n    }\n    AstConstructor.prototype.toString = function() {\n      var paramNames = appendToLookupTable({}, this.params.getNames());\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n        return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n      };\n      var prefix = \"function $constr_\" + this.params.params.length + this.params.toString();\n      var body = this.params.prependMethodArgs(this.body.toString());\n      if(!/\\$(superCstr|constr)\\b/.test(body)) {\n        body = \"{\\n$superCstr();\\n\" + body.substring(1);\n      }\n      replaceContext = oldContext;\n      return prefix + body + \"\\n\";\n    };\n\n    function transformConstructor(cstr) {\n      var m = new RegExp(/\"B(\\d+)\"\\s*\"A(\\d+)\"/).exec(cstr);\n      var params = transformParams(atoms[m[1]]);\n\n      return new AstConstructor(params, transformStatementsBlock(atoms[m[2]]));\n    }\n\n    function AstInterfaceBody(name, interfacesNames, methodsNames, fields, innerClasses, misc) {\n      var i,l;\n      this.name = name;\n      this.interfacesNames = interfacesNames;\n      this.methodsNames = methodsNames;\n      this.fields = fields;\n      this.innerClasses = innerClasses;\n      this.misc = misc;\n      for(i=0,l=fields.length; i<l; ++i) {\n        fields[i].owner = this;\n      }\n    }\n    AstInterfaceBody.prototype.getMembers = function(classFields, classMethods, classInners) {\n      if(this.owner.base) {\n        this.owner.base.body.getMembers(classFields, classMethods, classInners);\n      }\n      var i, j, l, m;\n      for(i=0,l=this.fields.length;i<l;++i) {\n        var fieldNames = this.fields[i].getNames();\n        for(j=0,m=fieldNames.length;j<m;++j) {\n          classFields[fieldNames[j]] = this.fields[i];\n        }\n      }\n      for(i=0,l=this.methodsNames.length;i<l;++i) {\n        var methodName = this.methodsNames[i];\n        classMethods[methodName] = true;\n      }\n      for(i=0,l=this.innerClasses.length;i<l;++i) {\n        var innerClass = this.innerClasses[i];\n        classInners[innerClass.name] = innerClass;\n      }\n    };\n    AstInterfaceBody.prototype.toString = function() {\n      function getScopeLevel(p) {\n        var i = 0;\n        while(p) {\n          ++i;\n          p=p.scope;\n        }\n        return i;\n      }\n\n      var scopeLevel = getScopeLevel(this.owner);\n\n      var className = this.name;\n      var staticDefinitions = \"\";\n      var metadata = \"\";\n\n      var thisClassFields = {}, thisClassMethods = {}, thisClassInners = {};\n      this.getMembers(thisClassFields, thisClassMethods, thisClassInners);\n\n      var i, l, j, m;\n\n      if (this.owner.interfaces) {\n        // interface name can be present, but interface is not\n        var resolvedInterfaces = [], resolvedInterface;\n        for (i = 0, l = this.interfacesNames.length; i < l; ++i) {\n          if (!this.owner.interfaces[i]) {\n            continue;\n          }\n          resolvedInterface = replaceContext({name: this.interfacesNames[i]});\n          resolvedInterfaces.push(resolvedInterface);\n          staticDefinitions += \"$p.extendInterfaceMembers(\" + className + \", \" + resolvedInterface + \");\\n\";\n        }\n        metadata += className + \".$interfaces = [\" + resolvedInterfaces.join(\", \") + \"];\\n\";\n      }\n      metadata += className + \".$isInterface = true;\\n\";\n      metadata += className + \".$methods = [\\'\" + this.methodsNames.join(\"\\', \\'\") + \"\\'];\\n\";\n\n      sortByWeight(this.innerClasses);\n      for (i = 0, l = this.innerClasses.length; i < l; ++i) {\n        var innerClass = this.innerClasses[i];\n        if (innerClass.isStatic) {\n          staticDefinitions += className + \".\" + innerClass.name + \" = \" + innerClass + \";\\n\";\n        }\n      }\n\n      for (i = 0, l = this.fields.length; i < l; ++i) {\n        var field = this.fields[i];\n        if (field.isStatic) {\n          staticDefinitions += className + \".\" + field.definitions.join(\";\\n\" + className + \".\") + \";\\n\";\n        }\n      }\n\n      return \"(function() {\\n\" +\n        \"function \" + className + \"() { throw \\'Unable to create the interface\\'; }\\n\" +\n        staticDefinitions +\n        metadata +\n        \"return \" + className + \";\\n\" +\n        \"})()\";\n    };\n\n    transformInterfaceBody = function(body, name, baseInterfaces) {\n      var declarations = body.substring(1, body.length - 1);\n      declarations = extractClassesAndMethods(declarations);\n      declarations = extractConstructors(declarations, name);\n      var methodsNames = [], classes = [];\n      declarations = declarations.replace(/\"([DE])(\\d+)\"/g, function(all, type, index) {\n        if(type === 'D') { methodsNames.push(index); }\n        else if(type === 'E') { classes.push(index); }\n        return \"\";\n      });\n      var fields = declarations.split(/;(?:\\s*;)*/g);\n      var baseInterfaceNames;\n      var i, l;\n\n      if(baseInterfaces !== undef) {\n        baseInterfaceNames = baseInterfaces.replace(/^\\s*extends\\s+(.+?)\\s*$/g, \"$1\").split(/\\s*,\\s*/g);\n      }\n\n      for(i = 0, l = methodsNames.length; i < l; ++i) {\n        var method = transformClassMethod(atoms[methodsNames[i]]);\n        methodsNames[i] = method.name;\n      }\n      for(i = 0, l = fields.length - 1; i < l; ++i) {\n        var field = trimSpaces(fields[i]);\n        fields[i] = transformClassField(field.middle);\n      }\n      var tail = fields.pop();\n      for(i = 0, l = classes.length; i < l; ++i) {\n        classes[i] = transformInnerClass(atoms[classes[i]]);\n      }\n\n      return new AstInterfaceBody(name, baseInterfaceNames, methodsNames, fields, classes, { tail: tail });\n    };\n\n    function AstClassBody(name, baseClassName, interfacesNames, functions, methods, fields, cstrs, innerClasses, misc) {\n      var i,l;\n      this.name = name;\n      this.baseClassName = baseClassName;\n      this.interfacesNames = interfacesNames;\n      this.functions = functions;\n      this.methods = methods;\n      this.fields = fields;\n      this.cstrs = cstrs;\n      this.innerClasses = innerClasses;\n      this.misc = misc;\n      for(i=0,l=fields.length; i<l; ++i) {\n        fields[i].owner = this;\n      }\n    }\n    AstClassBody.prototype.getMembers = function(classFields, classMethods, classInners) {\n      if(this.owner.base) {\n        this.owner.base.body.getMembers(classFields, classMethods, classInners);\n      }\n      var i, j, l, m;\n      for(i=0,l=this.fields.length;i<l;++i) {\n        var fieldNames = this.fields[i].getNames();\n        for(j=0,m=fieldNames.length;j<m;++j) {\n          classFields[fieldNames[j]] = this.fields[i];\n        }\n      }\n      for(i=0,l=this.methods.length;i<l;++i) {\n        var method = this.methods[i];\n        classMethods[method.name] = method;\n      }\n      for(i=0,l=this.innerClasses.length;i<l;++i) {\n        var innerClass = this.innerClasses[i];\n        classInners[innerClass.name] = innerClass;\n      }\n    };\n    AstClassBody.prototype.toString = function() {\n      function getScopeLevel(p) {\n        var i = 0;\n        while(p) {\n          ++i;\n          p=p.scope;\n        }\n        return i;\n      }\n\n      var scopeLevel = getScopeLevel(this.owner);\n\n      var selfId = \"$this_\" + scopeLevel;\n      var className = this.name;\n      var result = \"var \" + selfId + \" = this;\\n\";\n      var staticDefinitions = \"\";\n      var metadata = \"\";\n\n      var thisClassFields = {}, thisClassMethods = {}, thisClassInners = {};\n      this.getMembers(thisClassFields, thisClassMethods, thisClassInners);\n\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n        var name = subject.name;\n        if(name === \"this\") {\n          // returns \"$this_N.$self\" pointer instead of \"this\" in cases:\n          // \"this()\", \"this.XXX()\", \"this\", but not for \"this.XXX\"\n          return subject.callSign || !subject.member ? selfId + \".$self\" : selfId;\n        }\n        if(thisClassFields.hasOwnProperty(name)) {\n          return thisClassFields[name].isStatic ? className + \".\" + name : selfId + \".\" + name;\n        }\n        if(thisClassInners.hasOwnProperty(name)) {\n          return selfId + \".\" + name;\n        }\n        if(thisClassMethods.hasOwnProperty(name)) {\n          return thisClassMethods[name].isStatic ? className + \".\" + name : selfId + \".$self.\" + name;\n        }\n        return oldContext(subject);\n      };\n\n      var resolvedBaseClassName;\n      if (this.baseClassName) {\n        resolvedBaseClassName = oldContext({name: this.baseClassName});\n        result += \"var $super = { $upcast: \" + selfId + \" };\\n\";\n        result += \"function $superCstr(){\" + resolvedBaseClassName +\n          \".apply($super,arguments);if(!('$self' in $super)) $p.extendClassChain($super)}\\n\";\n        metadata += className + \".$base = \" + resolvedBaseClassName + \";\\n\";\n      } else {\n        result += \"function $superCstr(){$p.extendClassChain(\"+ selfId +\")}\\n\";\n      }\n\n      if (this.owner.base) {\n        // base class name can be present, but class is not\n        staticDefinitions += \"$p.extendStaticMembers(\" + className + \", \" + resolvedBaseClassName + \");\\n\";\n      }\n\n      var i, l, j, m;\n\n      if (this.owner.interfaces) {\n        // interface name can be present, but interface is not\n        var resolvedInterfaces = [], resolvedInterface;\n        for (i = 0, l = this.interfacesNames.length; i < l; ++i) {\n          if (!this.owner.interfaces[i]) {\n            continue;\n          }\n          resolvedInterface = oldContext({name: this.interfacesNames[i]});\n          resolvedInterfaces.push(resolvedInterface);\n          staticDefinitions += \"$p.extendInterfaceMembers(\" + className + \", \" + resolvedInterface + \");\\n\";\n        }\n        metadata += className + \".$interfaces = [\" + resolvedInterfaces.join(\", \") + \"];\\n\";\n      }\n\n      if (this.functions.length > 0) {\n        result += this.functions.join('\\n') + '\\n';\n      }\n\n      sortByWeight(this.innerClasses);\n      for (i = 0, l = this.innerClasses.length; i < l; ++i) {\n        var innerClass = this.innerClasses[i];\n        if (innerClass.isStatic) {\n          staticDefinitions += className + \".\" + innerClass.name + \" = \" + innerClass + \";\\n\";\n          result += selfId + \".\" + innerClass.name + \" = \" + className + \".\" + innerClass.name + \";\\n\";\n        } else {\n          result += selfId + \".\" + innerClass.name + \" = \" + innerClass + \";\\n\";\n        }\n      }\n\n      for (i = 0, l = this.fields.length; i < l; ++i) {\n        var field = this.fields[i];\n        if (field.isStatic) {\n          staticDefinitions += className + \".\" + field.definitions.join(\";\\n\" + className + \".\") + \";\\n\";\n          for (j = 0, m = field.definitions.length; j < m; ++j) {\n            var fieldName = field.definitions[j].name, staticName = className + \".\" + fieldName;\n            result += \"$p.defineProperty(\" + selfId + \", '\" + fieldName + \"', {\" +\n              \"get: function(){return \" + staticName + \"}, \" +\n              \"set: function(val){\" + staticName + \" = val}});\\n\";\n          }\n        } else {\n          result += selfId + \".\" + field.definitions.join(\";\\n\" + selfId + \".\") + \";\\n\";\n        }\n      }\n      var methodOverloads = {};\n      for (i = 0, l = this.methods.length; i < l; ++i) {\n        var method = this.methods[i];\n        var overload = methodOverloads[method.name];\n        var methodId = method.name + \"$\" + method.params.params.length;\n        var hasMethodArgs = !!method.params.methodArgsParam;\n        if (overload) {\n          ++overload;\n          methodId += \"_\" + overload;\n        } else {\n          overload = 1;\n        }\n        method.methodId = methodId;\n        methodOverloads[method.name] = overload;\n        if (method.isStatic) {\n          staticDefinitions += method;\n          staticDefinitions += \"$p.addMethod(\" + className + \", '\" + method.name + \"', \" + methodId + \", \" + hasMethodArgs + \");\\n\";\n          result += \"$p.addMethod(\" + selfId + \", '\" + method.name + \"', \" + methodId + \", \" + hasMethodArgs + \");\\n\";\n        } else {\n          result += method;\n          result += \"$p.addMethod(\" + selfId + \", '\" + method.name + \"', \" + methodId + \", \" + hasMethodArgs + \");\\n\";\n        }\n      }\n      result += trim(this.misc.tail);\n\n      if (this.cstrs.length > 0) {\n        result += this.cstrs.join('\\n') + '\\n';\n      }\n\n      result += \"function $constr() {\\n\";\n      var cstrsIfs = [];\n      for (i = 0, l = this.cstrs.length; i < l; ++i) {\n        var paramsLength = this.cstrs[i].params.params.length;\n        var methodArgsPresent = !!this.cstrs[i].params.methodArgsParam;\n        cstrsIfs.push(\"if(arguments.length \" + (methodArgsPresent ? \">=\" : \"===\") +\n          \" \" + paramsLength + \") { \" +\n          \"$constr_\" + paramsLength + \".apply(\" + selfId + \", arguments); }\");\n      }\n      if(cstrsIfs.length > 0) {\n        result += cstrsIfs.join(\" else \") + \" else \";\n      }\n      // ??? add check if length is 0, otherwise fail\n      result += \"$superCstr();\\n}\\n\";\n      result += \"$constr.apply(null, arguments);\\n\";\n\n      replaceContext = oldContext;\n      return \"(function() {\\n\" +\n        \"function \" + className + \"() {\\n\" + result + \"}\\n\" +\n        staticDefinitions +\n        metadata +\n        \"return \" + className + \";\\n\" +\n        \"})()\";\n    };\n\n    transformClassBody = function(body, name, baseName, interfaces) {\n      var declarations = body.substring(1, body.length - 1);\n      declarations = extractClassesAndMethods(declarations);\n      declarations = extractConstructors(declarations, name);\n      var methods = [], classes = [], cstrs = [], functions = [];\n      declarations = declarations.replace(/\"([DEGH])(\\d+)\"/g, function(all, type, index) {\n        if(type === 'D') { methods.push(index); }\n        else if(type === 'E') { classes.push(index); }\n        else if(type === 'H') { functions.push(index); }\n        else { cstrs.push(index); }\n        return \"\";\n      });\n      var fields = declarations.replace(/^(?:\\s*;)+/, \"\").split(/;(?:\\s*;)*/g);\n      var baseClassName, interfacesNames;\n      var i;\n\n      if(baseName !== undef) {\n        baseClassName = baseName.replace(/^\\s*extends\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)\\s*$/g, \"$1\");\n      }\n\n      if(interfaces !== undef) {\n        interfacesNames = interfaces.replace(/^\\s*implements\\s+(.+?)\\s*$/g, \"$1\").split(/\\s*,\\s*/g);\n      }\n\n      for(i = 0; i < functions.length; ++i) {\n        functions[i] = transformFunction(atoms[functions[i]]);\n      }\n      for(i = 0; i < methods.length; ++i) {\n        methods[i] = transformClassMethod(atoms[methods[i]]);\n      }\n      for(i = 0; i < fields.length - 1; ++i) {\n        var field = trimSpaces(fields[i]);\n        fields[i] = transformClassField(field.middle);\n      }\n      var tail = fields.pop();\n      for(i = 0; i < cstrs.length; ++i) {\n        cstrs[i] = transformConstructor(atoms[cstrs[i]]);\n      }\n      for(i = 0; i < classes.length; ++i) {\n        classes[i] = transformInnerClass(atoms[classes[i]]);\n      }\n\n      return new AstClassBody(name, baseClassName, interfacesNames, functions, methods, fields, cstrs,\n        classes, { tail: tail });\n    };\n\n    function AstInterface(name, body) {\n      this.name = name;\n      this.body = body;\n      body.owner = this;\n    }\n    AstInterface.prototype.toString = function() {\n      return \"var \" + this.name + \" = \" + this.body + \";\\n\" +\n        \"$p.\" + this.name + \" = \" + this.name + \";\\n\";\n    };\n    function AstClass(name, body) {\n      this.name = name;\n      this.body = body;\n      body.owner = this;\n    }\n    AstClass.prototype.toString = function() {\n      return \"var \" + this.name + \" = \" + this.body + \";\\n\" +\n        \"$p.\" + this.name + \" = \" + this.name + \";\\n\";\n    };\n\n    function transformGlobalClass(class_) {\n      var m = classesRegex.exec(class_); // 1 - attr, 2 - class|int, 3 - name, 4 - extends, 5 - implements, 6 - body\n      classesRegex.lastIndex = 0;\n      var body = atoms[getAtomIndex(m[6])];\n      var oldClassId = currentClassId, newClassId = generateClassId();\n      currentClassId = newClassId;\n      var globalClass;\n      if(m[2] === \"interface\") {\n        globalClass = new AstInterface(m[3], transformInterfaceBody(body, m[3], m[4]) );\n      } else {\n        globalClass = new AstClass(m[3], transformClassBody(body, m[3], m[4], m[5]) );\n      }\n      appendClass(globalClass, newClassId, oldClassId);\n      currentClassId = oldClassId;\n      return globalClass;\n    }\n\n    function AstMethod(name, params, body) {\n      this.name = name;\n      this.params = params;\n      this.body = body;\n    }\n    AstMethod.prototype.toString = function(){\n      var paramNames = appendToLookupTable({}, this.params.getNames());\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n        return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n      };\n      var body = this.params.prependMethodArgs(this.body.toString());\n      var result = \"function \" + this.name + this.params + \" \" + body + \"\\n\" +\n        \"$p.\" + this.name + \" = \" + this.name + \";\";\n      replaceContext = oldContext;\n      return result;\n    };\n\n    function transformGlobalMethod(method) {\n      var m = methodsRegex.exec(method);\n      var result =\n      methodsRegex.lastIndex = 0;\n      return new AstMethod(m[3], transformParams(atoms[getAtomIndex(m[4])]),\n        transformStatementsBlock(atoms[getAtomIndex(m[6])]));\n    }\n\n    function preStatementsTransform(statements) {\n      var s = statements;\n      // turns multiple catch blocks into one, because we have no way to properly get into them anyway.\n      s = s.replace(/\\b(catch\\s*\"B\\d+\"\\s*\"A\\d+\")(\\s*catch\\s*\"B\\d+\"\\s*\"A\\d+\")+/g, \"$1\");\n      return s;\n    }\n\n    function AstForStatement(argument, misc) {\n      this.argument = argument;\n      this.misc = misc;\n    }\n    AstForStatement.prototype.toString = function() {\n      return this.misc.prefix + this.argument.toString();\n    };\n    function AstCatchStatement(argument, misc) {\n      this.argument = argument;\n      this.misc = misc;\n    }\n    AstCatchStatement.prototype.toString = function() {\n      return this.misc.prefix + this.argument.toString();\n    };\n    function AstPrefixStatement(name, argument, misc) {\n      this.name = name;\n      this.argument = argument;\n      this.misc = misc;\n    }\n    AstPrefixStatement.prototype.toString = function() {\n      var result = this.misc.prefix;\n      if(this.argument !== undef) {\n        result += this.argument.toString();\n      }\n      return result;\n    };\n    function AstSwitchCase(expr) {\n      this.expr = expr;\n    }\n    AstSwitchCase.prototype.toString = function() {\n      return \"case \" + this.expr + \":\";\n    };\n    function AstLabel(label) {\n      this.label = label;\n    }\n    AstLabel.prototype.toString = function() {\n      return this.label;\n    };\n\n    transformStatements = function(statements, transformMethod, transformClass) {\n      var nextStatement = new RegExp(/\\b(catch|for|if|switch|while|with)\\s*\"B(\\d+)\"|\\b(do|else|finally|return|throw|try|break|continue)\\b|(\"[ADEH](\\d+)\")|\\b(case)\\s+([^:]+):|\\b([A-Za-z_$][\\w$]*\\s*:)|(;)/g);\n      var res = [];\n      statements = preStatementsTransform(statements);\n      var lastIndex = 0, m, space;\n      // m contains the matches from the nextStatement regexp, null if there are no matches.\n      // nextStatement.exec starts searching at nextStatement.lastIndex.\n      while((m = nextStatement.exec(statements)) !== null) {\n        if(m[1] !== undef) { // catch, for ...\n          var i = statements.lastIndexOf('\"B', nextStatement.lastIndex);\n          var statementsPrefix = statements.substring(lastIndex, i);\n          if(m[1] === \"for\") {\n            res.push(new AstForStatement(transformForExpression(atoms[m[2]]),\n              { prefix: statementsPrefix }) );\n          } else if(m[1] === \"catch\") {\n            res.push(new AstCatchStatement(transformParams(atoms[m[2]]),\n              { prefix: statementsPrefix }) );\n          } else {\n            res.push(new AstPrefixStatement(m[1], transformExpression(atoms[m[2]]),\n              { prefix: statementsPrefix }) );\n          }\n        } else if(m[3] !== undef) { // do, else, ...\n            res.push(new AstPrefixStatement(m[3], undef,\n              { prefix: statements.substring(lastIndex, nextStatement.lastIndex) }) );\n        } else if(m[4] !== undef) { // block, class and methods\n          space = statements.substring(lastIndex, nextStatement.lastIndex - m[4].length);\n          if(trim(space).length !== 0) { continue; } // avoiding new type[] {} construct\n          res.push(space);\n          var kind = m[4].charAt(1), atomIndex = m[5];\n          if(kind === 'D') {\n            res.push(transformMethod(atoms[atomIndex]));\n          } else if(kind === 'E') {\n            res.push(transformClass(atoms[atomIndex]));\n          } else if(kind === 'H') {\n            res.push(transformFunction(atoms[atomIndex]));\n          } else {\n            res.push(transformStatementsBlock(atoms[atomIndex]));\n          }\n        } else if(m[6] !== undef) { // switch case\n          res.push(new AstSwitchCase(transformExpression(trim(m[7]))));\n        } else if(m[8] !== undef) { // label\n          space = statements.substring(lastIndex, nextStatement.lastIndex - m[8].length);\n          if(trim(space).length !== 0) { continue; } // avoiding ?: construct\n          res.push(new AstLabel(statements.substring(lastIndex, nextStatement.lastIndex)) );\n        } else { // semicolon\n          var statement = trimSpaces(statements.substring(lastIndex, nextStatement.lastIndex - 1));\n          res.push(statement.left);\n          res.push(transformStatement(statement.middle));\n          res.push(statement.right + \";\");\n        }\n        lastIndex = nextStatement.lastIndex;\n      }\n      var statementsTail = trimSpaces(statements.substring(lastIndex));\n      res.push(statementsTail.left);\n      if(statementsTail.middle !== \"\") {\n        res.push(transformStatement(statementsTail.middle));\n        res.push(\";\" + statementsTail.right);\n      }\n      return res;\n    };\n\n    function getLocalNames(statements) {\n      var localNames = [];\n      for(var i=0,l=statements.length;i<l;++i) {\n        var statement = statements[i];\n        if(statement instanceof AstVar) {\n          localNames = localNames.concat(statement.getNames());\n        } else if(statement instanceof AstForStatement &&\n          statement.argument.initStatement instanceof AstVar) {\n          localNames = localNames.concat(statement.argument.initStatement.getNames());\n        } else if(statement instanceof AstInnerInterface || statement instanceof AstInnerClass ||\n          statement instanceof AstInterface || statement instanceof AstClass ||\n          statement instanceof AstMethod || statement instanceof AstFunction) {\n          localNames.push(statement.name);\n        }\n      }\n      return appendToLookupTable({}, localNames);\n    }\n\n    function AstStatementsBlock(statements) {\n      this.statements = statements;\n    }\n    AstStatementsBlock.prototype.toString = function() {\n      var localNames = getLocalNames(this.statements);\n      var oldContext = replaceContext;\n\n      // replacing context only when necessary\n      if(!isLookupTableEmpty(localNames)) {\n        replaceContext = function (subject) {\n          return localNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n        };\n      }\n\n      var result = \"{\\n\" + this.statements.join('') + \"\\n}\";\n      replaceContext = oldContext;\n      return result;\n    };\n\n    transformStatementsBlock = function(block) {\n      var content = trimSpaces(block.substring(1, block.length - 1));\n      return new AstStatementsBlock(transformStatements(content.middle));\n    };\n\n    function AstRoot(statements) {\n      this.statements = statements;\n    }\n    AstRoot.prototype.toString = function() {\n      var classes = [], otherStatements = [], statement;\n      for (var i = 0, len = this.statements.length; i < len; ++i) {\n        statement = this.statements[i];\n        if (statement instanceof AstClass || statement instanceof AstInterface) {\n          classes.push(statement);\n        } else {\n          otherStatements.push(statement);\n        }\n      }\n      sortByWeight(classes);\n\n      var localNames = getLocalNames(this.statements);\n      replaceContext = function (subject) {\n        var name = subject.name;\n        if(localNames.hasOwnProperty(name)) {\n          return name;\n        }\n        if(globalMembers.hasOwnProperty(name) ||\n           PConstants.hasOwnProperty(name) ||\n           defaultScope.hasOwnProperty(name)) {\n          return \"$p.\" + name;\n        }\n        return name;\n      };\n      var result = \"// this code was autogenerated from PJS\\n\" +\n        \"(function($p) {\\n\" +\n        classes.join('') + \"\\n\" +\n        otherStatements.join('') + \"\\n})\";\n      replaceContext = null;\n      return result;\n    };\n\n    transformMain = function() {\n      var statements = extractClassesAndMethods(atoms[0]);\n      statements = statements.replace(/\\bimport\\s+[^;]+;/g, \"\");\n      return new AstRoot( transformStatements(statements,\n        transformGlobalMethod, transformGlobalClass) );\n    };\n\n    function generateMetadata(ast) {\n      var globalScope = {};\n      var id, class_;\n      for(id in declaredClasses) {\n        if(declaredClasses.hasOwnProperty(id)) {\n          class_ = declaredClasses[id];\n          var scopeId = class_.scopeId, name = class_.name;\n          if(scopeId) {\n            var scope = declaredClasses[scopeId];\n            class_.scope = scope;\n            if(scope.inScope === undef) {\n              scope.inScope = {};\n            }\n            scope.inScope[name] = class_;\n          } else {\n            globalScope[name] = class_;\n          }\n        }\n      }\n\n      function findInScopes(class_, name) {\n        var parts = name.split('.');\n        var currentScope = class_.scope, found;\n        while(currentScope) {\n          if(currentScope.hasOwnProperty(parts[0])) {\n            found = currentScope[parts[0]]; break;\n          }\n          currentScope = currentScope.scope;\n        }\n        if(found === undef) {\n          found = globalScope[parts[0]];\n        }\n        for(var i=1,l=parts.length;i<l && found;++i) {\n          found = found.inScope[parts[i]];\n        }\n        return found;\n      }\n\n      for(id in declaredClasses) {\n        if(declaredClasses.hasOwnProperty(id)) {\n          class_ = declaredClasses[id];\n          var baseClassName = class_.body.baseClassName;\n          if(baseClassName) {\n            var parent = findInScopes(class_, baseClassName);\n            if (parent) {\n              class_.base = parent;\n              if (!parent.derived) {\n                parent.derived = [];\n              }\n              parent.derived.push(class_);\n            }\n          }\n          var interfacesNames = class_.body.interfacesNames,\n            interfaces = [], i, l;\n          if (interfacesNames && interfacesNames.length > 0) {\n            for (i = 0, l = interfacesNames.length; i < l; ++i) {\n              var interface_ = findInScopes(class_, interfacesNames[i]);\n              interfaces.push(interface_);\n              if (!interface_) {\n                continue;\n              }\n              if (!interface_.derived) {\n                interface_.derived = [];\n              }\n              interface_.derived.push(class_);\n            }\n            if (interfaces.length > 0) {\n              class_.interfaces = interfaces;\n            }\n          }\n        }\n      }\n    }\n\n    function setWeight(ast) {\n      var queue = [], tocheck = {};\n      var id, scopeId, class_;\n      // queue most inner and non-inherited\n      for (id in declaredClasses) {\n        if (declaredClasses.hasOwnProperty(id)) {\n          class_ = declaredClasses[id];\n          if (!class_.inScope && !class_.derived) {\n            queue.push(id);\n            class_.weight = 0;\n          } else {\n            var dependsOn = [];\n            if (class_.inScope) {\n              for (scopeId in class_.inScope) {\n                if (class_.inScope.hasOwnProperty(scopeId)) {\n                  dependsOn.push(class_.inScope[scopeId]);\n                }\n              }\n            }\n            if (class_.derived) {\n              dependsOn = dependsOn.concat(class_.derived);\n            }\n            tocheck[id] = dependsOn;\n          }\n        }\n      }\n      function removeDependentAndCheck(targetId, from) {\n        var dependsOn = tocheck[targetId];\n        if (!dependsOn) {\n          return false; // no need to process\n        }\n        var i = dependsOn.indexOf(from);\n        if (i < 0) {\n          return false;\n        }\n        dependsOn.splice(i, 1);\n        if (dependsOn.length > 0) {\n          return false;\n        }\n        delete tocheck[targetId];\n        return true;\n      }\n      while (queue.length > 0) {\n        id = queue.shift();\n        class_ = declaredClasses[id];\n        if (class_.scopeId && removeDependentAndCheck(class_.scopeId, class_)) {\n          queue.push(class_.scopeId);\n          declaredClasses[class_.scopeId].weight = class_.weight + 1;\n        }\n        if (class_.base && removeDependentAndCheck(class_.base.classId, class_)) {\n          queue.push(class_.base.classId);\n          class_.base.weight = class_.weight + 1;\n        }\n        if (class_.interfaces) {\n          var i, l;\n          for (i = 0, l = class_.interfaces.length; i < l; ++i) {\n            if (!class_.interfaces[i] ||\n                !removeDependentAndCheck(class_.interfaces[i].classId, class_)) {\n              continue;\n            }\n            queue.push(class_.interfaces[i].classId);\n            class_.interfaces[i].weight = class_.weight + 1;\n          }\n        }\n      }\n    }\n\n    var transformed = transformMain();\n    generateMetadata(transformed);\n    setWeight(transformed);\n\n    var redendered = transformed.toString();\n\n    // remove empty extra lines with space\n    redendered = redendered.replace(/\\s*\\n(?:[\\t ]*\\n)+/g, \"\\n\\n\");\n\n    // convert character codes to characters\n    redendered = redendered.replace(/__x([0-9A-F]{4})/g, function(all, hexCode) {\n      return String.fromCharCode(parseInt(hexCode,16));\n    });\n\n    return injectStrings(redendered, strings);\n  }// Parser ends\n\n  function preprocessCode(aCode, sketch) {\n    // Parse out @pjs directive, if any.\n    var dm = new RegExp(/\\/\\*\\s*@pjs\\s+((?:[^\\*]|\\*+[^\\*\\/])*)\\*\\//g).exec(aCode);\n    if (dm && dm.length === 2) {\n      // masks contents of a JSON to be replaced later\n      // to protect the contents from further parsing\n      var jsonItems = [],\n          directives = dm.splice(1, 2)[0].replace(/\\{([\\s\\S]*?)\\}/g, (function() {\n            return function(all, item) {\n              jsonItems.push(item);\n              return \"{\" + (jsonItems.length-1) + \"}\";\n            };\n          }())).replace('\\n', '').replace('\\r', '').split(\";\");\n\n      // We'll L/RTrim, and also remove any surrounding double quotes (e.g., just take string contents)\n      var clean = function(s) {\n        return s.replace(/^\\s*[\"']?/, '').replace(/[\"']?\\s*$/, '');\n      };\n\n      for (var i = 0, dl = directives.length; i < dl; i++) {\n        var pair = directives[i].split('=');\n        if (pair && pair.length === 2) {\n          var key = clean(pair[0]),\n              value = clean(pair[1]),\n              list = [];\n          // A few directives require work beyond storying key/value pairings\n          if (key === \"preload\") {\n            list = value.split(',');\n            // All pre-loaded images will get put in imageCache, keyed on filename\n            for (var j = 0, jl = list.length; j < jl; j++) {\n              var imageName = clean(list[j]);\n              sketch.imageCache.add(imageName);\n            }\n          // fonts can be declared as a string containing a url,\n          // or a JSON object, containing a font name, and a url\n          } else if (key === \"font\") {\n            list = value.split(\",\");\n            for (var x = 0, xl = list.length; x < xl; x++) {\n              var fontName = clean(list[x]),\n                  index = /^\\{(\\d*?)\\}$/.exec(fontName);\n              // if index is not null, send JSON, otherwise, send string\n              PFont.preloading.add(index ? JSON.parse(\"{\" + jsonItems[index[1]] + \"}\") : fontName);\n            }\n          } else if (key === \"pauseOnBlur\") {\n            sketch.options.pauseOnBlur = value === \"true\";\n          } else if (key === \"globalKeyEvents\") {\n            sketch.options.globalKeyEvents = value === \"true\";\n          } else if (key.substring(0, 6) === \"param-\") {\n            sketch.params[key.substring(6)] = value;\n          } else {\n            sketch.options[key] = value;\n          }\n        }\n      }\n    }\n    return aCode;\n  }\n\n  // Parse/compiles Processing (Java-like) syntax to JavaScript syntax\n  Processing.compile = function(pdeCode) {\n    var sketch = new Processing.Sketch();\n    var code = preprocessCode(pdeCode, sketch);\n    var compiledPde = parseProcessing(code);\n    sketch.sourceCode = compiledPde;\n    return sketch;\n  };\n//#endif\n\n  // tinylog lite JavaScript library\n  // https://github.com/eligrey/tinylog\n  /*global tinylog,print*/\n  var tinylogLite = (function() {\n    \"use strict\";\n\n    var tinylogLite = {},\n      undef = \"undefined\",\n      func = \"function\",\n      False = !1,\n      True = !0,\n      logLimit = 512,\n      log = \"log\";\n\n    if (typeof tinylog !== undef && typeof tinylog[log] === func) {\n      // pre-existing tinylog present\n      tinylogLite[log] = tinylog[log];\n    } else if (typeof document !== undef && !document.fake) {\n      (function() {\n        // DOM document\n        var doc = document,\n\n        $div = \"div\",\n        $style = \"style\",\n        $title = \"title\",\n\n        containerStyles = {\n          zIndex: 10000,\n          position: \"fixed\",\n          bottom: \"0px\",\n          width: \"100%\",\n          height: \"15%\",\n          fontFamily: \"sans-serif\",\n          color: \"#ccc\",\n          backgroundColor: \"black\"\n        },\n        outputStyles = {\n          position: \"relative\",\n          fontFamily: \"monospace\",\n          overflow: \"auto\",\n          height: \"100%\",\n          paddingTop: \"5px\"\n        },\n        resizerStyles = {\n          height: \"5px\",\n          marginTop: \"-5px\",\n          cursor: \"n-resize\",\n          backgroundColor: \"darkgrey\"\n        },\n        closeButtonStyles = {\n          position: \"absolute\",\n          top: \"5px\",\n          right: \"20px\",\n          color: \"#111\",\n          MozBorderRadius: \"4px\",\n          webkitBorderRadius: \"4px\",\n          borderRadius: \"4px\",\n          cursor: \"pointer\",\n          fontWeight: \"normal\",\n          textAlign: \"center\",\n          padding: \"3px 5px\",\n          backgroundColor: \"#333\",\n          fontSize: \"12px\"\n        },\n        entryStyles = {\n          //borderBottom: \"1px solid #d3d3d3\",\n          minHeight: \"16px\"\n        },\n        entryTextStyles = {\n          fontSize: \"12px\",\n          margin: \"0 8px 0 8px\",\n          maxWidth: \"100%\",\n          whiteSpace: \"pre-wrap\",\n          overflow: \"auto\"\n        },\n\n        view = doc.defaultView,\n          docElem = doc.documentElement,\n          docElemStyle = docElem[$style],\n\n        setStyles = function() {\n          var i = arguments.length,\n            elemStyle, styles, style;\n\n          while (i--) {\n            styles = arguments[i--];\n            elemStyle = arguments[i][$style];\n\n            for (style in styles) {\n              if (styles.hasOwnProperty(style)) {\n                elemStyle[style] = styles[style];\n              }\n            }\n          }\n        },\n\n        observer = function(obj, event, handler) {\n          if (obj.addEventListener) {\n            obj.addEventListener(event, handler, False);\n          } else if (obj.attachEvent) {\n            obj.attachEvent(\"on\" + event, handler);\n          }\n          return [obj, event, handler];\n        },\n        unobserve = function(obj, event, handler) {\n          if (obj.removeEventListener) {\n            obj.removeEventListener(event, handler, False);\n          } else if (obj.detachEvent) {\n            obj.detachEvent(\"on\" + event, handler);\n          }\n        },\n        clearChildren = function(node) {\n          var children = node.childNodes,\n            child = children.length;\n\n          while (child--) {\n            node.removeChild(children.item(0));\n          }\n        },\n        append = function(to, elem) {\n          return to.appendChild(elem);\n        },\n        createElement = function(localName) {\n          return doc.createElement(localName);\n        },\n        createTextNode = function(text) {\n          return doc.createTextNode(text);\n        },\n\n        createLog = tinylogLite[log] = function(message) {\n          // don't show output log until called once\n          var uninit,\n            originalPadding = docElemStyle.paddingBottom,\n            container = createElement($div),\n            containerStyle = container[$style],\n            resizer = append(container, createElement($div)),\n            output = append(container, createElement($div)),\n            closeButton = append(container, createElement($div)),\n            resizingLog = False,\n            previousHeight = False,\n            previousScrollTop = False,\n            messages = 0,\n\n            updateSafetyMargin = function() {\n              // have a blank space large enough to fit the output box at the page bottom\n              docElemStyle.paddingBottom = container.clientHeight + \"px\";\n            },\n            setContainerHeight = function(height) {\n              var viewHeight = view.innerHeight,\n                resizerHeight = resizer.clientHeight;\n\n              // constrain the container inside the viewport's dimensions\n              if (height < 0) {\n                height = 0;\n              } else if (height + resizerHeight > viewHeight) {\n                height = viewHeight - resizerHeight;\n              }\n\n              containerStyle.height = height / viewHeight * 100 + \"%\";\n\n              updateSafetyMargin();\n            },\n            observers = [\n              observer(doc, \"mousemove\", function(evt) {\n                if (resizingLog) {\n                  setContainerHeight(view.innerHeight - evt.clientY);\n                  output.scrollTop = previousScrollTop;\n                }\n              }),\n\n              observer(doc, \"mouseup\", function() {\n                if (resizingLog) {\n                  resizingLog = previousScrollTop = False;\n                }\n              }),\n\n              observer(resizer, \"dblclick\", function(evt) {\n                evt.preventDefault();\n\n                if (previousHeight) {\n                  setContainerHeight(previousHeight);\n                  previousHeight = False;\n                } else {\n                  previousHeight = container.clientHeight;\n                  containerStyle.height = \"0px\";\n                }\n              }),\n\n              observer(resizer, \"mousedown\", function(evt) {\n                evt.preventDefault();\n                resizingLog = True;\n                previousScrollTop = output.scrollTop;\n              }),\n\n              observer(resizer, \"contextmenu\", function() {\n                resizingLog = False;\n              }),\n\n              observer(closeButton, \"click\", function() {\n                uninit();\n              })\n            ];\n\n          uninit = function() {\n            // remove observers\n            var i = observers.length;\n\n            while (i--) {\n              unobserve.apply(tinylogLite, observers[i]);\n            }\n\n            // remove tinylog lite from the DOM\n            docElem.removeChild(container);\n            docElemStyle.paddingBottom = originalPadding;\n\n            clearChildren(output);\n            clearChildren(container);\n\n            tinylogLite[log] = createLog;\n          };\n\n          setStyles(\n          container, containerStyles, output, outputStyles, resizer, resizerStyles, closeButton, closeButtonStyles);\n\n          closeButton[$title] = \"Close Log\";\n          append(closeButton, createTextNode(\"\\u2716\"));\n\n          resizer[$title] = \"Double-click to toggle log minimization\";\n\n          docElem.insertBefore(container, docElem.firstChild);\n\n          tinylogLite[log] = function(message) {\n            if (messages === logLimit) {\n              output.removeChild(output.firstChild);\n            } else {\n              messages++;\n            }\n\n            var entry = append(output, createElement($div)),\n              entryText = append(entry, createElement($div));\n\n            entry[$title] = (new Date()).toLocaleTimeString();\n\n            setStyles(\n            entry, entryStyles, entryText, entryTextStyles);\n\n            append(entryText, createTextNode(message));\n            output.scrollTop = output.scrollHeight;\n          };\n\n          tinylogLite[log](message);\n          updateSafetyMargin();\n        };\n      }());\n    } else if (typeof print === func) { // JS shell\n      tinylogLite[log] = print;\n    }\n\n    return tinylogLite;\n  }());\n  // end of tinylog lite JavaScript library\n\n  Processing.logger = tinylogLite;\n\n  Processing.version = \"@VERSION@\";\n\n  // Share lib space\n  Processing.lib = {};\n\n  Processing.registerLibrary = function(name, desc) {\n    Processing.lib[name] = desc;\n\n    if(desc.hasOwnProperty(\"init\")) {\n      desc.init(defaultScope);\n    }\n  };\n\n  // Store Processing instances. Only Processing.instances,\n  // Processing.getInstanceById are exposed.\n  Processing.instances = processingInstances;\n\n  Processing.getInstanceById = function(name) {\n    return processingInstances[processingInstanceIds[name]];\n  };\n\n  Processing.Sketch = function(attachFunction) {\n    this.attachFunction = attachFunction; // can be optional\n    this.options = {\n      pauseOnBlur: false,\n      globalKeyEvents: false\n    };\n\n    /* Optional Sketch event hooks:\n     *   onLoad - parsing/preloading is done, before sketch starts\n     *   onSetup - setup() has been called, before first draw()\n     *   onPause - noLoop() has been called, pausing draw loop\n     *   onLoop - loop() has been called, resuming draw loop\n     *   onFrameStart - draw() loop about to begin\n     *   onFrameEnd - draw() loop finished\n     *   onExit - exit() done being called\n     */\n    this.onLoad = nop;\n    this.onSetup = nop;\n    this.onPause = nop;\n    this.onLoop = nop;\n    this.onFrameStart = nop;\n    this.onFrameEnd = nop;\n    this.onExit = nop;\n\n    this.params = {};\n    this.imageCache = {\n      pending: 0,\n      images: {},\n      // Opera requires special administration for preloading\n      operaCache: {},\n      // Specify an optional img arg if the image is already loaded in the DOM,\n      // otherwise href will get loaded.\n      add: function(href, img) {\n        // Prevent muliple loads for an image, in case it gets\n        // preloaded more than once, or is added via JS and then preloaded.\n        if (this.images[href]) {\n          return;\n        }\n\n        if (!isDOMPresent) {\n          this.images[href] = null;\n        }\n\n        // No image in the DOM, kick-off a background load\n        if (!img) {\n          img = new Image();\n          img.onload = (function(owner) {\n            return function() {\n              owner.pending--;\n            };\n          }(this));\n          this.pending++;\n          img.src = href;\n        }\n\n        this.images[href] = img;\n\n        // Opera will not load images until they are inserted into the DOM.\n        if (window.opera) {\n          var div = document.createElement(\"div\");\n          div.appendChild(img);\n          // we can't use \"display: none\", since that makes it invisible, and thus not load\n          div.style.position = \"absolute\";\n          div.style.opacity = 0;\n          div.style.width = \"1px\";\n          div.style.height= \"1px\";\n          if (!this.operaCache[href]) {\n            document.body.appendChild(div);\n            this.operaCache[href] = div;\n          }\n        }\n      }\n    };\n    this.sourceCode = undefined;\n    this.attach = function(processing) {\n      // either attachFunction or sourceCode must be present on attach\n      if(typeof this.attachFunction === \"function\") {\n        this.attachFunction(processing);\n      } else if(this.sourceCode) {\n        var func = ((new Function(\"return (\" + this.sourceCode + \");\"))());\n        func(processing);\n        this.attachFunction = func;\n      } else {\n        throw \"Unable to attach sketch to the processing instance\";\n      }\n    };\n//#if PARSER\n    this.toString = function() {\n      var i;\n      var code = \"((function(Sketch) {\\n\";\n      code += \"var sketch = new Sketch(\\n\" + this.sourceCode + \");\\n\";\n      for(i in this.options) {\n        if(this.options.hasOwnProperty(i)) {\n          var value = this.options[i];\n          code += \"sketch.options.\" + i + \" = \" +\n            (typeof value === 'string' ? '\\\"' + value + '\\\"' : \"\" + value) + \";\\n\";\n        }\n      }\n      for(i in this.imageCache) {\n        if(this.options.hasOwnProperty(i)) {\n          code += \"sketch.imageCache.add(\\\"\" + i + \"\\\");\\n\";\n        }\n      }\n      // TODO serialize fonts\n      code += \"return sketch;\\n})(Processing.Sketch))\";\n      return code;\n    };\n//#endif\n  };\n\n//#if PARSER\n  /**\n   * aggregate all source code into a single file, then rewrite that\n   * source and bind to canvas via new Processing(canvas, sourcestring).\n   * @param {CANVAS} canvas The html canvas element to bind to\n   * @param {String[]} source The array of files that must be loaded\n   */\n  var loadSketchFromSources = function(canvas, sources) {\n    var code = [], errors = [], sourcesCount = sources.length, loaded = 0;\n\n    function ajaxAsync(url, callback) {\n      var xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          var error;\n          if (xhr.status !== 200 && xhr.status !== 0) {\n            error = \"Invalid XHR status \" + xhr.status;\n          } else if (xhr.responseText === \"\") {\n            // Give a hint when loading fails due to same-origin issues on file:/// urls\n            if ( (\"withCredentials\" in new XMLHttpRequest()) &&\n                 (new XMLHttpRequest()).withCredentials === false &&\n                 window.location.protocol === \"file:\" ) {\n              error = \"XMLHttpRequest failure, possibly due to a same-origin policy violation. You can try loading this page in another browser, or load it from http://localhost using a local webserver. See the Processing.js README for a more detailed explanation of this problem and solutions.\";\n            } else {\n              error = \"File is empty.\";\n            }\n          }\n\n          callback(xhr.responseText, error);\n        }\n      };\n      xhr.open(\"GET\", url, true);\n      if (xhr.overrideMimeType) {\n        xhr.overrideMimeType(\"application/json\");\n      }\n      xhr.setRequestHeader(\"If-Modified-Since\", \"Fri, 01 Jan 1960 00:00:00 GMT\"); // no cache\n      xhr.send(null);\n    }\n\n    function loadBlock(index, filename) {\n      function callback(block, error) {\n        code[index] = block;\n        ++loaded;\n        if (error) {\n          errors.push(filename + \" ==> \" + error);\n        }\n        if (loaded === sourcesCount) {\n          if (errors.length === 0) {\n            try {\n              return new Processing(canvas, code.join(\"\\n\"));\n            } catch(e) {\n              throw \"Processing.js: Unable to execute pjs sketch: \" + e;\n            }\n          } else {\n            throw \"Processing.js: Unable to load pjs sketch files: \" + errors.join(\"\\n\");\n          }\n        }\n      }\n      if (filename.charAt(0) === '#') {\n        // trying to get script from the element\n        var scriptElement = document.getElementById(filename.substring(1));\n        if (scriptElement) {\n          callback(scriptElement.text || scriptElement.textContent);\n        } else {\n          callback(\"\", \"Unable to load pjs sketch: element with id \\'\" + filename.substring(1) + \"\\' was not found\");\n        }\n        return;\n      }\n\n      ajaxAsync(filename, callback);\n    }\n\n    for (var i = 0; i < sourcesCount; ++i) {\n      loadBlock(i, sources[i]);\n    }\n  };\n\n  /**\n   * Automatic initialization function.\n   */\n  var init = function() {\n    document.removeEventListener('DOMContentLoaded', init, false);\n\n    // before running through init, clear the instances list, to prevent\n    // sketch duplication when page content is dynamically swapped without\n    // swapping out processing.js\n    processingInstances = [];\n\n    var canvas = document.getElementsByTagName('canvas'),\n      filenames;\n\n    for (var i = 0, l = canvas.length; i < l; i++) {\n      // datasrc and data-src are deprecated.\n      var processingSources = canvas[i].getAttribute('data-processing-sources');\n      if (processingSources === null) {\n        // Temporary fallback for datasrc and data-src\n        processingSources = canvas[i].getAttribute('data-src');\n        if (processingSources === null) {\n          processingSources = canvas[i].getAttribute('datasrc');\n        }\n      }\n      if (processingSources) {\n        filenames = processingSources.split(/\\s+/g);\n        for (var j = 0; j < filenames.length;) {\n          if (filenames[j]) {\n            j++;\n          } else {\n            filenames.splice(j, 1);\n          }\n        }\n        loadSketchFromSources(canvas[i], filenames);\n      }\n    }\n\n    // also process all <script>-indicated sketches, if there are any\n    var s, last, source, instance,\n        nodelist = document.getElementsByTagName('script'),\n        scripts=[];\n\n    // snapshot the DOM, as the nodelist is only a DOM view, and is\n    // updated instantly when a script element is added or removed.\n    for (s = nodelist.length - 1; s >= 0; s--) {\n      scripts.push(nodelist[s]);\n    }\n\n    // iterate over all script elements to see if they contain Processing code\n    for (s = 0, last = scripts.length; s < last; s++) {\n      var script = scripts[s];\n      if (!script.getAttribute) {\n        continue;\n      }\n\n      var type = script.getAttribute(\"type\");\n      if (type && (type.toLowerCase() === \"text/processing\" || type.toLowerCase() === \"application/processing\")) {\n        var target = script.getAttribute(\"data-processing-target\");\n        canvas = undef;\n        if (target) {\n          canvas = document.getElementById(target);\n        } else {\n          var nextSibling = script.nextSibling;\n          while (nextSibling && nextSibling.nodeType !== 1) {\n            nextSibling = nextSibling.nextSibling;\n          }\n          if (nextSibling && nextSibling.nodeName.toLowerCase() === \"canvas\") {\n            canvas = nextSibling;\n          }\n        }\n\n        if (canvas) {\n          if (script.getAttribute(\"src\")) {\n            filenames = script.getAttribute(\"src\").split(/\\s+/);\n            loadSketchFromSources(canvas, filenames);\n            continue;\n          }\n          source =  script.textContent || script.text;\n          instance = new Processing(canvas, source);\n        }\n      }\n    }\n  };\n\n  /**\n   * Make Processing run through init after already having\n   * been set up for a page. This function exists mostly for pages\n   * that swap content in/out without reloading a page.\n   */\n  Processing.reload = function() {\n    if (processingInstances.length > 0) {\n      // unload sketches\n      for (var i = processingInstances.length - 1; i >= 0; i--) {\n        if (processingInstances[i]) {\n          processingInstances[i].exit();\n        }\n      }\n    }\n    // rerun init() to scan the DOM for sketches\n    init();\n  };\n\n  /**\n   * Make loadSketchFromSources publically visible\n   */\n  Processing.loadSketchFromSources = loadSketchFromSources;\n\n  /**\n   * Disable the automatic loading of all sketches on the page\n   */\n  Processing.disableInit = function() {\n    if(isDOMPresent) {\n      document.removeEventListener('DOMContentLoaded', init, false);\n    }\n  };\n//#endif\n\n  if(isDOMPresent) {\n    window['Processing'] = Processing;\n//#if PARSER\n    document.addEventListener('DOMContentLoaded', init, false);\n//#endif\n  } else {\n    // DOM is not found\n    this.Processing = Processing;\n  }\n}(window, window.document, Math));\n","// lib/handlebars/base.js\nvar Handlebars = {};\n\nHandlebars.VERSION = \"1.0.beta.6\";\n\nHandlebars.helpers  = {};\nHandlebars.partials = {};\n\nHandlebars.registerHelper = function(name, fn, inverse) {\n  if(inverse) { fn.not = inverse; }\n  this.helpers[name] = fn;\n};\n\nHandlebars.registerPartial = function(name, str) {\n  this.partials[name] = str;\n};\n\nHandlebars.registerHelper('helperMissing', function(arg) {\n  if(arguments.length === 2) {\n    return undefined;\n  } else {\n    throw new Error(\"Could not find property '\" + arg + \"'\");\n  }\n});\n\nvar toString = Object.prototype.toString, functionType = \"[object Function]\";\n\nHandlebars.registerHelper('blockHelperMissing', function(context, options) {\n  var inverse = options.inverse || function() {}, fn = options.fn;\n\n\n  var ret = \"\";\n  var type = toString.call(context);\n\n  if(type === functionType) { context = context.call(this); }\n\n  if(context === true) {\n    return fn(this);\n  } else if(context === false || context == null) {\n    return inverse(this);\n  } else if(type === \"[object Array]\") {\n    if(context.length > 0) {\n      for(var i=0, j=context.length; i<j; i++) {\n        ret = ret + fn(context[i]);\n      }\n    } else {\n      ret = inverse(this);\n    }\n    return ret;\n  } else {\n    return fn(context);\n  }\n});\n\nHandlebars.registerHelper('each', function(context, options) {\n  var fn = options.fn, inverse = options.inverse;\n  var ret = \"\";\n\n  if(context && context.length > 0) {\n    for(var i=0, j=context.length; i<j; i++) {\n      ret = ret + fn(context[i]);\n    }\n  } else {\n    ret = inverse(this);\n  }\n  return ret;\n});\n\nHandlebars.registerHelper('if', function(context, options) {\n  var type = toString.call(context);\n  if(type === functionType) { context = context.call(this); }\n\n  if(!context || Handlebars.Utils.isEmpty(context)) {\n    return options.inverse(this);\n  } else {\n    return options.fn(this);\n  }\n});\n\nHandlebars.registerHelper('unless', function(context, options) {\n  var fn = options.fn, inverse = options.inverse;\n  options.fn = inverse;\n  options.inverse = fn;\n\n  return Handlebars.helpers['if'].call(this, context, options);\n});\n\nHandlebars.registerHelper('with', function(context, options) {\n  return options.fn(context);\n});\n\nHandlebars.registerHelper('log', function(context) {\n  Handlebars.log(context);\n});\n;\n// lib/handlebars/utils.js\nHandlebars.Exception = function(message) {\n  var tmp = Error.prototype.constructor.apply(this, arguments);\n\n  for (var p in tmp) {\n    if (tmp.hasOwnProperty(p)) { this[p] = tmp[p]; }\n  }\n\n  this.message = tmp.message;\n};\nHandlebars.Exception.prototype = new Error;\n\n// Build out our basic SafeString type\nHandlebars.SafeString = function(string) {\n  this.string = string;\n};\nHandlebars.SafeString.prototype.toString = function() {\n  return this.string.toString();\n};\n\n(function() {\n  var escape = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"`\": \"&#x60;\"\n  };\n\n  var badChars = /&(?!\\w+;)|[<>\"'`]/g;\n  var possible = /[&<>\"'`]/;\n\n  var escapeChar = function(chr) {\n    return escape[chr] || \"&amp;\";\n  };\n\n  Handlebars.Utils = {\n    escapeExpression: function(string) {\n      // don't escape SafeStrings, since they're already safe\n      if (string instanceof Handlebars.SafeString) {\n        return string.toString();\n      } else if (string == null || string === false) {\n        return \"\";\n      }\n\n      if(!possible.test(string)) { return string; }\n      return string.replace(badChars, escapeChar);\n    },\n\n    isEmpty: function(value) {\n      if (typeof value === \"undefined\") {\n        return true;\n      } else if (value === null) {\n        return true;\n      } else if (value === false) {\n        return true;\n      } else if(Object.prototype.toString.call(value) === \"[object Array]\" && value.length === 0) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  };\n})();;\n// lib/handlebars/runtime.js\nHandlebars.VM = {\n  template: function(templateSpec) {\n    // Just add water\n    var container = {\n      escapeExpression: Handlebars.Utils.escapeExpression,\n      invokePartial: Handlebars.VM.invokePartial,\n      programs: [],\n      program: function(i, fn, data) {\n        var programWrapper = this.programs[i];\n        if(data) {\n          return Handlebars.VM.program(fn, data);\n        } else if(programWrapper) {\n          return programWrapper;\n        } else {\n          programWrapper = this.programs[i] = Handlebars.VM.program(fn);\n          return programWrapper;\n        }\n      },\n      programWithDepth: Handlebars.VM.programWithDepth,\n      noop: Handlebars.VM.noop\n    };\n\n    return function(context, options) {\n      options = options || {};\n      return templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);\n    };\n  },\n\n  programWithDepth: function(fn, data, $depth) {\n    var args = Array.prototype.slice.call(arguments, 2);\n\n    return function(context, options) {\n      options = options || {};\n\n      return fn.apply(this, [context, options.data || data].concat(args));\n    };\n  },\n  program: function(fn, data) {\n    return function(context, options) {\n      options = options || {};\n\n      return fn(context, options.data || data);\n    };\n  },\n  noop: function() { return \"\"; },\n  invokePartial: function(partial, name, context, helpers, partials, data) {\n    options = { helpers: helpers, partials: partials, data: data };\n\n    if(partial === undefined) {\n      throw new Handlebars.Exception(\"The partial \" + name + \" could not be found\");\n    } else if(partial instanceof Function) {\n      return partial(context, options);\n    } else if (!Handlebars.compile) {\n      throw new Handlebars.Exception(\"The partial \" + name + \" could not be compiled when running in runtime-only mode\");\n    } else {\n      partials[name] = Handlebars.compile(partial);\n      return partials[name](context, options);\n    }\n  }\n};\n\nHandlebars.template = Handlebars.VM.template;\n;\n","!function(e){if(\"object\"==typeof exports)module.exports=e();else if(\"function\"==typeof define&&define.amd)define(e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.jade=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = function merge(a, b) {\n  if (arguments.length === 1) {\n    var attrs = a[0];\n    for (var i = 1; i < a.length; i++) {\n      attrs = merge(attrs, a[i]);\n    }\n    return attrs;\n  }\n  var ac = a['class'];\n  var bc = b['class'];\n\n  if (ac || bc) {\n    ac = ac || [];\n    bc = bc || [];\n    if (!Array.isArray(ac)) ac = [ac];\n    if (!Array.isArray(bc)) bc = [bc];\n    a['class'] = ac.concat(bc).filter(nulls);\n  }\n\n  for (var key in b) {\n    if (key != 'class') {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Filter null `val`s.\n *\n * @param {*} val\n * @return {Boolean}\n * @api private\n */\n\nfunction nulls(val) {\n  return val != null && val !== '';\n}\n\n/**\n * join array as classes.\n *\n * @param {*} val\n * @return {String}\n */\nexports.joinClasses = joinClasses;\nfunction joinClasses(val) {\n  return Array.isArray(val) ? val.map(joinClasses).filter(nulls).join(' ') : val;\n}\n\n/**\n * Render the given classes.\n *\n * @param {Array} classes\n * @param {Array.<Boolean>} escaped\n * @return {String}\n */\nexports.cls = function cls(classes, escaped) {\n  var buf = [];\n  for (var i = 0; i < classes.length; i++) {\n    if (escaped && escaped[i]) {\n      buf.push(exports.escape(joinClasses([classes[i]])));\n    } else {\n      buf.push(joinClasses(classes[i]));\n    }\n  }\n  var text = joinClasses(buf);\n  if (text.length) {\n    return ' class=\"' + text + '\"';\n  } else {\n    return '';\n  }\n};\n\n/**\n * Render the given attribute.\n *\n * @param {String} key\n * @param {String} val\n * @param {Boolean} escaped\n * @param {Boolean} terse\n * @return {String}\n */\nexports.attr = function attr(key, val, escaped, terse) {\n  if ('boolean' == typeof val || null == val) {\n    if (val) {\n      return ' ' + (terse ? key : key + '=\"' + key + '\"');\n    } else {\n      return '';\n    }\n  } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n    return ' ' + key + \"='\" + JSON.stringify(val).replace(/'/g, '&apos;') + \"'\";\n  } else if (escaped) {\n    return ' ' + key + '=\"' + exports.escape(val) + '\"';\n  } else {\n    return ' ' + key + '=\"' + val + '\"';\n  }\n};\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} escaped\n * @return {String}\n */\nexports.attrs = function attrs(obj, terse){\n  var buf = [];\n\n  var keys = Object.keys(obj);\n\n  if (keys.length) {\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i]\n        , val = obj[key];\n\n      if ('class' == key) {\n        if (val = joinClasses(val)) {\n          buf.push(' ' + key + '=\"' + val + '\"');\n        }\n      } else {\n        buf.push(exports.attr(key, val, false, terse));\n      }\n    }\n  }\n\n  return buf.join('');\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function escape(html){\n  var result = String(html)\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n  if (result === '' + html) return html;\n  else return result;\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the jade in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @api private\n */\n\nexports.rethrow = function rethrow(err, filename, lineno, str){\n  if (!(err instanceof Error)) throw err;\n  if ((typeof window != 'undefined' || !filename) && !str) {\n    err.message += ' on line ' + lineno;\n    throw err;\n  }\n  try {\n    str =  str || require('fs').readFileSync(filename, 'utf8')\n  } catch (ex) {\n    rethrow(err, null, lineno)\n  }\n  var context = 3\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Jade') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n\n},{\"fs\":2}],2:[function(require,module,exports){\n\n},{}]},{},[1])\n(1)\n});","describe 'foo', ->\n  it 'should return',->\n    expect(true).to.be.true\n"]}